
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="shortcut icon" href="https://www.yourkit.com/favicon.ico">
    <link rel='stylesheet' type='text/css' href='resources/bootstrap.min.css'>
    <title>YourKit Java Profiler 2017 Offline Help</title>

    <style type="text/css">
      * {
        margin: 0;
        padding: 0;
      }

      body, html {
        font-family: sans-serif;
        font-size: 15px;
        line-height: 1.35em;
      }

      body {
        border: 0;
        color: rgb(51, 51, 51);
        background-color: white;
        display: flex;
        flex-direction: column;
      }

      #header-wrapper-id {
        font-size: 1.7em; /* like h1 */
        padding-top: 0.5rem;
        padding-bottom: 0.5rem;
        box-shadow: 0 8px 7px -7px rgb(120, 120, 120);
      }

      #header-id {
        display: flex;
        align-items: center;
        color: white;
      }

      #hlp-article-id {
        margin-top: 1.5rem;
        margin-bottom: 1.5rem;
      }

      /* < md / phones and tablets  */
      @media (max-width: 992px) {
        #hlp-article-id {
          margin-left: 1.5rem;
          margin-right: 1.5rem;
        }
      }

      #footer-id {
        padding-top: 0.5rem;
        padding-bottom: 0.5rem;
        color: white;
        box-shadow: 0 -8px 7px -7px rgb(120, 120, 120);
      }

      /* ------------------------------------------------------------------------------------------------
         Help index
      ------------------------------------------------------------------------------------------------ */

      #hlp-index-id {
        line-height: 1.35em;
        padding: 0;
        margin: 0;
        background: unset;
        font-size: unset;
      }

      #hlp-index-id ul, #hlp-index-id li {
        padding: 0;
      }

      /* Right shift for second and deeper ULs */
      #hlp-index-id ul ul {
        margin-left : 1.5rem;
      }

      #hlp-index-id ul li {
        list-style-image : none;
        list-style-type : none;
        background-image: none;
        margin: 0 0 0.4rem 0;
      }

      /* ------------------------------------------------------------------------------------------------
         Responsive image inside <figure> tag. It changes size according to parent.
      ------------------------------------------------------------------------------------------------ */

      figure {
        text-align: center;
        margin-bottom: 1.5rem;;
      }

      figure > img {
        display: inline-block;
        max-width: 100%;
        height: auto;
      }

      /* ------------------------------------------------------------------------------------------------
          Code
      ------------------------------------------------------------------------------------------------ */

      h1 {
        font-size: 1.7rem;
        font-weight: 700;
        color: rgb(51, 51, 51);
        white-space: nowrap;
        margin-bottom: 1.4rem;
      }

      h2 {
        font-size: 1.4rem;
        font-weight: 700;
        color: rgb(51, 51, 51);
        white-space: nowrap;
        margin-bottom: 1rem;
      }

      .color-theme {
        background-color: #6484A4;
      }

      pre {
        padding: 1rem 1rem;
        margin-bottom: 1.5rem;
        font-family: fnt-mono, monospace;
      }

      code, pre code {
        font-family: fnt-mono, monospace;
        color: #222480;
        text-align: start;
      }

      pre, pre code {
        white-space: pre;
      }

      /* ------------------------------------------------------------------------------------------------
        Other
      ------------------------------------------------------------------------------------------------ */

      hr {
        margin-bottom: 1.5rem;
        margin-top: 1.5rem;
        background-color: rgb(221, 221, 221);
        height: 1px;
        border: none;
      }

      img {
        border: none;
      }

      a {
        color: rgb(0, 120, 202);
        transition: color 0.25s;
        text-decoration: none;
        outline: 0; /* Do not show dotted focus border */
      }

      a:hover {
        color: #333;
        transition: color 0.25s;
      }

      p {
        margin-bottom: 1.5em;
      }

      a.ext {
        padding-right: 10px;
        background: url(resources/link_external.gif) no-repeat center right;
      }

      a.mail {
        padding-right: 10px;
        background: url(resources/link_mail.gif) no-repeat center right;
      }

      .yk_top_link {
        text-align: right;
      }

      .hint {
        padding: 10px 20px 10px 40px;
        background: rgb(255, 255, 225) url("resources/attention.png") no-repeat 10px center;
        border: 1px solid rgb(221, 221, 221);
        border-radius: 2px;
      }

      .help_rc_warning {
        padding: 20px 20px 20px 50px;
        background: rgba(255, 0, 0, 0.45) url("resources/attention.png") no-repeat 20px center;
        border-radius: 2px;
      }

      ul {
        list-style-type: none;
        padding: 0 0 1em 0;
        margin: 0;
      }

      ul li {
        margin: 0 0 3px 0;
        list-style-image: none;
        background: url("resources/disc5_grey70.png") no-repeat 0px 7px;
        padding-left: 0.9em;
        text-align: left;
      }

      ul.yk_disc_grey li {
        background: url("resources/disc5_grey200.png") no-repeat 0px 7px;
      }

      /* ------------------------------------------------------------------------------------------------
        Tables
      ------------------------------------------------------------------------------------------------ */

      table {
        border-spacing: 0;
        border-collapse: collapse;
      }

      .tbl-with-border {
        margin-bottom: 1rem;
      }

      .tbl-with-border td {
        border: 1px solid rgb(221, 221, 221);
        padding: 1rem 1rem;
      }

      table thead, .tbl-with-vheader td:first-child {
        background-color: #EEEEEE;
        text-align: center;
      }

      /*Top left cell*/
      table.tbl-with-vheader > thead > tr:first-child > td:first-child {
        background: white;
        border: none;
      }

      table.tbl-with-strong-thead thead {
        font-weight: 700;
      }

      /* ---------------------------------------------------------------------------------------------------- */
    </style>
  </head>

  <body>
    <div class="container-fluid">
      <div class="row">
        <div id="header-wrapper-id" class="row color-theme ">
          <div id="header-id"
               class="col-xs-offset-0 col-xs-12    col-md-offset-1 col-md-10    col-lg-offset-2 col-lg-8"

          >
            <div><a href="https://www.yourkit.com" target="_blank" style="padding-right: 2rem"><img src="resources/yk48.png" alt="YourKit"></a></div>
            <div>YourKit Java Profiler 2017 Offline Help</div>
          </div>
        </div>
      </div>

      <div id="top" class="row">
        <div id="hlp-article-id"
             class="col-xs-offset-0 col-xs-12    col-md-offset-1 col-md-10    col-lg-offset-2 col-lg-8"
        >
          <div id='hlp-index-id'><ul>
<li>1&nbsp;&nbsp;<a href="#running_profiler">Running the profiler</a></li>
<li>2&nbsp;&nbsp;<a href="#running_with_profiler">Running applications with the profiler</a></li>
<ul>
<li>2.1&nbsp;&nbsp;<a href="#local_profiling">Local profiling</a></li>
<li>2.2&nbsp;&nbsp;<a href="#remote_profiling">Remote profiling</a></li>
<ul>
<li>2.2.1&nbsp;&nbsp;<a href="#profiling_j2ee_remote">Console version of Java EE server integration wizard</a></li>
<li>2.2.2&nbsp;&nbsp;<a href="#attach_wizard">Remote attach wizard</a></li>
</ul>
<li>2.3&nbsp;&nbsp;<a href="#startup_options">Startup options</a></li>
<li>2.4&nbsp;&nbsp;<a href="#attach_agent">Attaching profiler agent to a running JVM</a></li>
<li>2.5&nbsp;&nbsp;<a href="#overhead">Profiling overhead: how to reduce or avoid</a></li>
<li>2.6&nbsp;&nbsp;<a href="#agent">Enabling profiling manually</a></li>
<li>2.7&nbsp;&nbsp;<a href="#jvmti">About JVMTI (advanced topic)</a></li>
</ul>
<li>3&nbsp;&nbsp;<a href="#connect">Connect to profiled application</a></li>
<li>4&nbsp;&nbsp;<a href="#performance_problems">Solving performance problems</a></li>
<ul>
<li>4.1&nbsp;&nbsp;<a href="#performance_bottlenecks">Performance bottlenecks</a></li>
<li>4.2&nbsp;&nbsp;<a href="#high_memory_usage">Optimizing memory usage</a></li>
<li>4.3&nbsp;&nbsp;<a href="#memory_leaks">Memory leaks</a></li>
<ul>
<li>4.3.1&nbsp;&nbsp;<a href="#gc_roots">GC roots</a></li>
</ul>
<li>4.4&nbsp;&nbsp;<a href="#excessive_gc">Excessive garbage allocation</a></li>
<li>4.5&nbsp;&nbsp;<a href="#out_of_memory">Out of memory error (OutOfMemoryError and -XX:+HeapDumpOnOutOfMemoryError)</a></li>
</ul>
<li>5&nbsp;&nbsp;<a href="#cpu_profiling">CPU profiling</a></li>
<ul>
<li>5.1&nbsp;&nbsp;<a href="#cpu_telemetry">CPU usage telemetry</a></li>
<li>5.2&nbsp;&nbsp;<a href="#cpu_intro">Start CPU profiling. Sampling, tracing, call counting.</a></li>
<li>5.3&nbsp;&nbsp;<a href="#sampling_settings">CPU sampling settings</a></li>
<li>5.4&nbsp;&nbsp;<a href="#tracing_settings">CPU tracing settings</a></li>
<li>5.5&nbsp;&nbsp;<a href="#cpu_stat">CPU view</a></li>
<li>5.6&nbsp;&nbsp;<a href="#cpu_callees_list_view">Callees list view</a></li>
<li>5.7&nbsp;&nbsp;<a href="#cpu_method_merged_callees">Method merged callees view</a></li>
<li>5.8&nbsp;&nbsp;<a href="#cpu_method_back_traces">Method back traces view</a></li>
<li>5.9&nbsp;&nbsp;<a href="#cpu_high_level">Java EE high-level statistics</a></li>
<li>5.10&nbsp;&nbsp;<a href="#cpu_what_if">What-if: an ability to ignore particular methods or focus on particular methods only</a></li>
<li>5.11&nbsp;&nbsp;<a href="#cpu_compare_snapshots">Comparing performance snapshots</a></li>
<li>5.12&nbsp;&nbsp;<a href="#cpu_usage_estimation">CPU usage estimation</a></li>
</ul>
<li>6&nbsp;&nbsp;<a href="#threads">Threads</a></li>
<li>7&nbsp;&nbsp;<a href="#deadlocks">Deadlock detector</a></li>
<li>8&nbsp;&nbsp;Memory profiling</li>
<ul>
<li>8.1&nbsp;&nbsp;<a href="#memory_telemetry">Memory telemetry</a></li>
<li>8.2&nbsp;&nbsp;<a href="#memory_snapshots">Memory snapshot</a></li>
<li>8.3&nbsp;&nbsp;<a href="#allocations">Object allocation recording</a></li>
<li>8.4&nbsp;&nbsp;<a href="#sizes">Shallow and retained sizes</a></li>
<li>8.5&nbsp;&nbsp;Memory views</li>
<ul>
<li>8.5.1&nbsp;&nbsp;<a href="#objects_view">Objects view</a></li>
<ul>
<li>8.5.1.1&nbsp;&nbsp;<a href="#class_list">Class list</a></li>
<li>8.5.1.2&nbsp;&nbsp;<a href="#class_tree">Class and package</a></li>
<li>8.5.1.3&nbsp;&nbsp;<a href="#class_loaders">Class loaders</a></li>
<li>8.5.1.4&nbsp;&nbsp;<a href="#web_applications">Web applications</a></li>
<li>8.5.1.5&nbsp;&nbsp;<a href="#generations">Object generations</a></li>
<li>8.5.1.6&nbsp;&nbsp;<a href="#reachability">Reachability scopes</a></li>
<li>8.5.1.7&nbsp;&nbsp;<a href="#shallow_size_view">Shallow size</a></li>
<li>8.5.1.8&nbsp;&nbsp;<a href="#objects_view_explorer">Object explorer</a></li>
<li>8.5.1.9&nbsp;&nbsp;<a href="#biggest_objects">Biggest objects (dominators)</a></li>
<li>8.5.1.10&nbsp;&nbsp;<a href="#objects_view_alloc">Allocations</a></li>
<li>8.5.1.11&nbsp;&nbsp;<a href="#ages">Object ages</a></li>
<li>8.5.1.12&nbsp;&nbsp;<a href="#merged_paths">Merged paths</a></li>
<li>8.5.1.13&nbsp;&nbsp;<a href="#class_hierarchy">Class hierarchy</a></li>
</ul>
<li>8.5.2&nbsp;&nbsp;<a href="#mem_method_merged_callees">Method merged callees view</a></li>
<li>8.5.3&nbsp;&nbsp;<a href="#mem_method_back_traces">Method back traces view</a></li>
<li>8.5.4&nbsp;&nbsp;<a href="#quick_info">Quick info view</a></li>
<li>8.5.5&nbsp;&nbsp;<a href="#gc_roots_view">GC roots view</a></li>
<li>8.5.6&nbsp;&nbsp;<a href="#paths">Leak detection: working with paths</a></li>
</ul>
<li>8.6&nbsp;&nbsp;<a href="#inspections_mem">Memory inspections</a></li>
<li>8.7&nbsp;&nbsp;<a href="#compare_snapshots">Comparing memory snapshots</a></li>
<li>8.8&nbsp;&nbsp;<a href="#hprof_snapshots">Support of HPROF format snapshots</a></li>
<li>8.9&nbsp;&nbsp;<a href="#primitive_values">Values of primitive types</a></li>
<li>8.10&nbsp;&nbsp;<a href="#memory_actions">Useful actions</a></li>
<li>8.11&nbsp;&nbsp;<a href="#language">Set description language</a></li>
</ul>
<li>9&nbsp;&nbsp;<a href="#garbage_collection">Garbage collection</a></li>
<li>10&nbsp;&nbsp;<a href="#monitor_profiling">Monitor profiling</a></li>
<li>11&nbsp;&nbsp;<a href="#exception_telemetry">Exception telemetry</a></li>
<li>12&nbsp;&nbsp;<a href="#probes">Probes: monitor events of various kinds</a></li>
<ul>
<li>12.1&nbsp;&nbsp;<a href="#probes_ui">Events in user interface</a></li>
<ul>
<li>12.1.1&nbsp;&nbsp;<a href="#probes_ui_tables">Events by Table</a></li>
<ul>
<li>12.1.1.1&nbsp;&nbsp;<a href="#probes_ui_table_messages">Profiler events in table 'Messages'</a></li>
</ul>
<li>12.1.2&nbsp;&nbsp;<a href="#probes_ui_timeline">Event Timeline</a></li>
<li>12.1.3&nbsp;&nbsp;<a href="#probes_ui_timeline_chart">Event Timeline Chart</a></li>
<li>12.1.4&nbsp;&nbsp;<a href="#probes_ui_call_tree">Event Call Tree</a></li>
<li>12.1.5&nbsp;&nbsp;<a href="#probes_ui_stacks">Event stack traces</a></li>
<li>12.1.6&nbsp;&nbsp;<a href="#probes_ui_navigation">Navigation between views</a></li>
<li>12.1.7&nbsp;&nbsp;<a href="#probes_ui_range">Events in range</a></li>
</ul>
<li>12.2&nbsp;&nbsp;<a href="#event_inspections">Event inspections</a></li>
<li>12.3&nbsp;&nbsp;<a href="#builtin_probes">Built-in probes</a></li>
<ul>
<li>12.3.1&nbsp;&nbsp;<a href="#threads_probe">com.yourkit.probes.builtin.Threads</a></li>
<li>12.3.2&nbsp;&nbsp;<a href="#classloading">Class loading probe</a></li>
<li>12.3.3&nbsp;&nbsp;<a href="#awtevents">com.yourkit.probes.builtin.AWTEvents</a></li>
<li>12.3.4&nbsp;&nbsp;<a href="#messages">com.yourkit.probes.builtin.Messages</a></li>
</ul>
<li>12.4&nbsp;&nbsp;<a href="#probe_class">Probe classes</a></li>
<ul>
<li>12.4.1&nbsp;&nbsp;<a href="#compile_probes">Compiling probe classes</a></li>
<li>12.4.2&nbsp;&nbsp;<a href="#register_probes">Probe registration, activity modes</a></li>
<li>12.4.3&nbsp;&nbsp;<a href="#unregister_probes">Probe unregistration</a></li>
</ul>
<li>12.5&nbsp;&nbsp;<a href="#event_method_call">Monitoring method invocation events</a></li>
<ul>
<li>12.5.1&nbsp;&nbsp;<a href="#method_pattern">Probe class annotation @MethodPattern</a></li>
<li>12.5.2&nbsp;&nbsp;<a href="#onenter">Callback onEnter()</a></li>
<li>12.5.3&nbsp;&nbsp;<a href="#onreturn">Callback onReturn()</a></li>
<li>12.5.4&nbsp;&nbsp;<a href="#onexception">Callbacks onUncaughtException() and onUncaughtExceptionExt()</a></li>
<li>12.5.5&nbsp;&nbsp;<a href="#annot_param">Callback method parameter annotation @Param</a></li>
<li>12.5.6&nbsp;&nbsp;<a href="#annot_params">Callback method parameter annotation @Params</a></li>
<li>12.5.7&nbsp;&nbsp;<a href="#annot_this">Callback method parameter annotation @This</a></li>
<li>12.5.8&nbsp;&nbsp;<a href="#annot_classref">Callback method parameter annotation @ClassRef</a></li>
<li>12.5.9&nbsp;&nbsp;<a href="#annot_methodname">Callback method parameter annotation @MethodName</a></li>
<li>12.5.10&nbsp;&nbsp;<a href="#annot_methodparametertypes">Callback method parameter annotation @MethodParameterTypes</a></li>
<li>12.5.11&nbsp;&nbsp;<a href="#annot_methodsignature">Callback method parameter annotation @MethodSignature</a></li>
<li>12.5.12&nbsp;&nbsp;<a href="#annot_onenterresult">Callback method parameter annotation @OnEnterResult</a></li>
<li>12.5.13&nbsp;&nbsp;<a href="#annot_returnvalue">Callback method parameter annotation @ReturnValue</a></li>
<li>12.5.14&nbsp;&nbsp;<a href="#annot_thrownexception">Callback method parameter annotation @ThrownException</a></li>
<li>12.5.15&nbsp;&nbsp;<a href="#probe_class_rules">Probe application rules</a></li>
</ul>
<li>12.6&nbsp;&nbsp;<a href="#data_storage">Data storage</a></li>
<ul>
<li>12.6.1&nbsp;&nbsp;<a href="#tables">Tables, rows, columns</a></li>
<li>12.6.2&nbsp;&nbsp;<a href="#event_kinds">Lasting events and point events</a></li>
<li>12.6.3&nbsp;&nbsp;<a href="#table_api">Table API</a></li>
<li>12.6.4&nbsp;&nbsp;<a href="#scalability">Scalability</a></li>
</ul>
</ul>
<li>13&nbsp;&nbsp;<a href="#perf_charts">Performance charts</a></li>
<li>14&nbsp;&nbsp;<a href="#inspections">Inspections: automatic recognition of typical problems</a></li>
<li>15&nbsp;&nbsp;<a href="#triggers">Automatically trigger actions on event</a></li>
<ul>
<li>15.1&nbsp;&nbsp;<a href="#snapshot_on_high_memory_usage">Automatically capture snapshot on high memory usage</a></li>
<li>15.2&nbsp;&nbsp;<a href="#periodic">Capture snapshots periodically</a></li>
</ul>
<li>16&nbsp;&nbsp;<a href="#summary">Summary, snapshot annotation, automatic deobfuscation</a></li>
<li>17&nbsp;&nbsp;<a href="#ide_integration">IDE integration</a></li>
<ul>
<li>17.1&nbsp;&nbsp;<a href="#eclipse">Eclipse</a></li>
<li>17.2&nbsp;&nbsp;<a href="#eclipse_update_site">Completing Eclipse plugin installation</a></li>
<ul>
<li>17.2.1&nbsp;&nbsp;<a href="#complete_eclipse35">Completing Eclipse 3.5-4.x plugin installation</a></li>
<li>17.2.2&nbsp;&nbsp;<a href="#complete_myeclipse2014">Completing MyEclipse 2014 or newer plugin installation</a></li>
<li>17.2.3&nbsp;&nbsp;<a href="#complete_myeclipse85">Completing MyEclipse 8.5-2013 plugin installation</a></li>
</ul>
<li>17.3&nbsp;&nbsp;<a href="#idea">IntelliJ IDEA</a></li>
<li>17.4&nbsp;&nbsp;<a href="#netbeans">NetBeans</a></li>
<li>17.5&nbsp;&nbsp;<a href="#jdeveloper">JDeveloper</a></li>
</ul>
<li>18&nbsp;&nbsp;<a href="#times">Time measurement (CPU time, wall time)</a></li>
<li>19&nbsp;&nbsp;<a href="#filters">Filters</a></li>
<li>20&nbsp;&nbsp;<a href="#snapshot_dir">Snapshot directory customization</a></li>
<li>21&nbsp;&nbsp;<a href="#export">Export of profiling results to HTML, CSV, XML, plain text</a></li>
<li>22&nbsp;&nbsp;<a href="#api">Profiler API</a></li>
<li>23&nbsp;&nbsp;<a href="#command_line_tool">Command line tool to control profiling</a></li>
</ul>
</div><br><h1 id='running_profiler'>1&nbsp;Running the profiler</h1>

  <p>Please follow instructions for your operating system on how to launch the profiler UI:</p>

  <h2>Windows</h2>
  <p>
    Launch <span class="ui_text">YourKit Java Profiler</span> from in the Start menu
  </p>

  <h2>Mac OS X</h2>
  <p>
    Download the application, unzip; optionally, move to <code class="nobr">/Applications</code>.
  </p>

  <h3>Troubleshooting: what to do if the profiler crashes on startup</h3>

  <p>Try to avoid using the native application launcher by running the following command the Terminal:
  </p>
  <p>
    <code class="nobr"><i>&lt;profiler installation directory&gt;</i>/Contents/Resources/bin/yjp.sh</code>
  </p>
  <p>
    Although the profiler started this way will have minor UI defects
    such as non-native main menu style and an incorrect application icon in the dock,
    in general it will work just fine.
  </p>
  <p>
    Note: since build 14112 the profiler falls back to this approach automatically,
    i.e. tries to restart itself via <code class="nobr">yjp.sh</code> after a crash.
  </p>




  <h2>Linux, Solaris, AIX, HP-UX, FreeBSD</h2>
  <p>
    Unpack the installation bundle and run
    <code class="nobr"><i>&lt;Profiler Installation Directory&gt;</i>/bin/yjp.sh</code>
  </p>
  <p>
    The profiler UI requires Java 8 to run.
    The download bundle contains JRE for Linux x64 and should run out of the box on that platform.
    On other platforms, please ensure that the appropriate Java version is installed.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='running_with_profiler'>2&nbsp;Running applications with the profiler</h1>

  <h2>Local and remote profiling</h2>

  <p>
    The profiled application and the profiler can run on the same machine or on different machines.
  </p>
  <p>
    These modes are called <a href="#local_profiling">local profiling</a> and <a href="#remote_profiling">remote profiling</a>
    respectively.
  </p>

  <h2>The profiler agent</h2>

  <p>
    To profile a Java application, be it local or remote, the profiler agent should be loaded into the JVM.
  </p>

  <h3>Approach 1: Start JVM with the profiler agent</h3>
  <p>
    This approach is <strong>recommended</strong> as it provides the full set of profiling capabilities.
    To learn how to apply it, see appropriate subtopic:
  </p>
  <ul>
    <li><a href="#local_profiling">Local profiling</a></li>
    <li><a href="#remote_profiling">Remote profiling</a></li>
  </ul>

  <h3>Approach 2: Attach the profiler to a running JVM instance started without the agent</h3>

  <p>
    Attaching the profiler agent to a running JVM instance simplifies profiling,
    as it avoids a special step to enable profiling:
    any running Java application can be profiled on demand.
  </p>
  <p>
    However, attaching to a running JVM is <strong>not always possible</strong>,
    and some profiling features are <strong>not available</strong>.
  </p>
  <p>
    <a href="#attach_agent">Read more...</a>
  </p>

  <h2>Supported JVMs</h2>

  <ul>
    <li>Sun/Oracle Java 6, Java 7, Java 8, Java 9 (EA)</li>
    <li>JRockit 6 (R27.2.0 and newer)</li>
    <li>IBM Java 6 (SR3 and newer), Java 7, Java 8</li>
  </ul>

  <h2>Supported platforms</h2>

  <ul>
    <li>
      <p>
        Windows, 32-bit Java (x86) and 64-bit Java (x86-64):
      </p>
      <ul>
        <li>Windows 10, Windows Server 2016</li>
        <li>Windows 8.1, Windows Server 2012 R2</li>
        <li>Windows 8, Windows Server 2012</li>
        <li>Windows 7, Windows Server 2008 R2</li>
        <li>Windows Vista, Windows Server 2008</li>
        <li>Windows XP, Windows Server 2003</li>
      </ul>
    </li>
    <li>
      <p>
        Linux, 32-bit Java and 64-bit Java:
      </p>
      <ul>
        <li>x86/x86-64</li>
        <li>ppc/ppc64/ppc64le</li>
        <li>ARM</li>
      </ul>
    </li>
    <li>Mac OS X 10.6 and newer, Intel, 32-bit and 64-bit Java</li>
    <li>Solaris 9 and newer, SPARC, 32-bit and 64-bit Java</li>
    <li>Solaris 10 and newer, x86, 32-bit and 64-bit Java</li>
    <li>
      FreeBSD 8 and newer, i386 and amd64 (aka x86-64).
      Limitation:
      CPU profiling will always measure <a href="#times">wall time</a>
      and thread telemetry will show the same CPU time - the process CPU time - for all threads,
      because FreeBSD cannot measure per-thread CPU time.
    </li>
    <li>HP-UX IA64, 32-bit and 64-bit Java</li>
    <li>AIX, 32-bit Java (ppc) and 64-bit Java (ppc64)</li>
  </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='local_profiling'>2.1&nbsp;Local profiling</h1>

  <p>
    <i>Local profiling</i> is the case when the profiled application and the profiler UI run on the same machine,
    usually the developer workstation.
  </p>

  <p class="hint">
    See also: <a href="#remote_profiling">remote profiling</a>
  </p>

  <p>
    You should perform two actions to perform local profiling:
  </p>

  <h2 id="run">1. Ensure the local application is running with the profiler agent</h2>

  <p>
    To profile a Java application, be it local or remote, the profiler agent should be loaded into the JVM.
  </p>

  <p>
    There are different approaches depending on the application type:
  </p>

  <h3>Java SE application</h3>

  <p>
    Use one of the following:
  </p>

  <ul>
    <li>
      <a href="#ide_integration">IDE integration</a>:
      use the <span class="ui_action">Profile</span> action from within your IDE, like you do <span class="ui_action">Run</span> or <span class="ui_action">Debug</span>.
    </li>
    <li>
      To profile an application from outside an IDE,
      perform a few simple steps described in <a href="#agent">Enabling profiling manually</a>.
    </li>
    <li>
      <a href="#attach_agent">Attach profiler agent</a> to a running JVM.
    </li>
  </ul>

  <h3>Java EE application (EE server)</h3>

  <p>
    Use one of the following:
  </p>

  <ul>
    <li>
      <a href="#ide_integration">IDE integration</a>:
      use the <span class="ui_action">Profile</span> action from within your IDE, like you do <span class="ui_action">Run</span> or <span class="ui_action">Debug</span>.
    </li>
    <li>
      <p>
        Java EE server integration wizard:
        use if the application server runs standalone,
        i.e. you start it with a script or it runs as a service.
      </p>
      <p>
        The wizard automatically enables profiling in a number of popular application servers, generating appropriate startup scripts.
        Even if your server is not in the list of known servers,
        the wizard offers the "Generic server" option which will instruct you on how to manually perform the necessary changes.
      </p>
      <p>
        The wizard can be started from the profiler Welcome screen,
        or with the main menu item <span class="ui_action">Tools | Integrate with Standalone Java EE Server...</span>.
      </p>
    </li>
    <li>
      <a href="#attach_agent">Attach profiler agent</a> to a running JVM.
    </li>
  </ul>

  <h3>Profiling Java Web Start/JNLP</h3>

  <p>
    Use one of the following:
  </p>

  <ul>
    <li>
      <p>
        Start Java Web Start application with the profiler agent by
        setting the environment variable <code class="nobr">JAVAWS_VM_ARGS</code>:
      </p>

      <p>
        <code class="nobr">JAVAWS_VM_ARGS=-agentpath:<i>&lt;agent library path&gt;</i></code>
      </p>

      <p>
        If necessary, specify other VM options too:
      </p>

      <p>
        <code class="nobr">JAVAWS_VM_ARGS=-agentpath:<i>&lt;agent library path&gt;</i> <i>&lt;other VM options&gt;</i></code>
      </p>

      <p>
        Please learn how to specify <code class="nobr">-agentpath:<i>&lt;agent library path&gt;</i></code>
        in <a href="#agent">Enabling profiling manually</a>.
      </p>

      <p>
        Hint: on Windows, you can set <code class="nobr">JAVAWS_VM_ARGS</code> variable globally in "My Computer" settings.
      </p>
    </li>
    <li>
      <a href="#attach_agent">Attach profiler agent</a> to a running JVM.
    </li>
  </ul>

  <h3>Applet</h3>

  <p>
    Use one of the following:
  </p>

  <ul>
    <li>
      <a href="#ide_integration">IDE integration</a>:
      use the <span class="ui_action">Profile</span> action from within your IDE, like you do <span class="ui_action">Run</span> or <span class="ui_action">Debug</span>.
    </li>
    <li>
      To profile applets running in a browser:
      ensure the applet has started, then <a href="#attach_agent">attach</a> to the running JVM.
    </li>
    <li>
      To profile applets started with <code class="nobr">appletviewer</code> command
      pass <code class="nobr">-J-agentpath:<i>&lt;agent library path&gt;</i></code>
      (see <a href="#agent">Enabling profiling manually</a>) as a command line parameter.
    </li>
  </ul>

  <h2 id="connect">2. Connect to the local application</h2>

  <p>
    When the local application is running,
    <a href="#connect">connect</a> to it from the profiler UI to perform profiling.
  </p>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='remote_profiling'>2.2&nbsp;Remote profiling</h1>

  <p>
    <i>Remote profiling</i> is the case when the profiled application and the profiler UI run on different machines,
    usually on a server and your developer machine correspondingly.
  </p>

  <p class="hint">
    See also: <a href="#local_profiling">local profiling</a>
  </p>

  <p>
    You should perform two actions to perform remote profiling:
  </p>

  <h2 id="run">1. Ensure the remote application is running with the profiler agent</h2>

  <p class="hint">
    Note: an action is required on the remote machine.
  </p>

  <p>
    To profile a Java application, be it local or remote, the profiler agent should be loaded into the JVM.
  </p>

  <p>
    There are two approaches to remote profiling:
  </p>
  <ul>
    <li>
      Start JVM with the profiler agent by applying the
      <a href="#profiling_j2ee_remote">console version of Java EE server integration wizard</a>
      on the remote machine <strong>(recommended)</strong>, or <a href="#agent">manually</a>
    </li>
    <p>
    ... or ...
    </p>
    <li>
      Run the <a href="#attach_wizard">remote attach wizard</a> on the remote machine
    </li>
  </ul>

  <h2 id="connect">2. Connect to the remote application</h2>

  <p>
    When the remote application is running,
    <a href="#remote">connect</a> to it from the profiler UI to perform profiling.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='profiling_j2ee_remote'>2.2.1&nbsp;Console version of Java EE server integration wizard</h1>

  <p class="hint">
    The following describes profiling of a Java EE server running on a remote machine
    (i.e. the server and the profiler UI run on different machines).
    <br/>
    <br/>
    Read about profiling a local Java EE server (i.e. running on the same machine where you run the profiler UI) <a href="#local_profiling">here</a>.
  </p>

  <p>
    If you have only a console access (e.g. via ssh) to the machine where the Java EE server
    to be profiled is hosted, use the console version of the Java EE integration wizard.
  </p>
  <p>
    The wizard automatically enables profiling in a number of popular application servers, generating appropriate startup scripts.
    Even if your server is not in the list of known servers,
    the wizard offers the "Generic server" option which will instruct you on how to manually perform the necessary changes.
  </p>

  <h2>Running the wizard</h2>

  <ul>
    <li>
      <a href="https://www.yourkit.com/download/">Download</a> distribution bundle for the remote machine's platform
    </li>
    <li>
      Copy the distribution bundle file to the remote machine and unpack to arbitrary directory
      (or install if on Windows).
      <strong class="nobr">License key is NOT required</strong> to run the console version of the integration wizard.
    </li>
    <li>
      <p>
        Run this command:
      </p>

      <h3>On Windows</h3>
      <p>
        <code class="nobr"><i>&lt;Profiler Installation Directory&gt;</i>\bin\integrate.bat</code><br/>
      </p>

      <h3>On other platforms</h3>
      <p>
        <code class="nobr"><i>&lt;directory with unpacked content&gt;</i>/bin/yjp.sh -integrate</code><br/>
      </p>
    </li>
    <li>
      <p>
        follow the instructions that will appear:
      </p>
      <figure>
        <img alt="" src="resources/profiling_j2ee_remote_wizard.gif"/>
      </figure>
    </li>
  </ul>
  <p>
    Note: the integration wizard generates output files (copies of configuration files, additional startup scripts)
    in directories where original files locate.
    Please ensure that you run the command with sufficient access rights.
  </p>

  <p class="hint">
    Also see <a href="#cpu_high_level">Java EE high-level profiling</a>
  </p>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='attach_wizard'>2.2.2&nbsp;Remote attach wizard</h1>

  <p class="hint">
    The following describes <a href="#attach_agent">attaching profiler to a running JVM</a>
    on a remote machine
    (i.e. the profiled JVM and the profiler UI run on different machines).
    <br/>
    <br/>
    If application runs locally, you can attach to it directly from the profiler's Welcome screen.
    <br/>
    <br/>
    Note that attaching profiler agent to a running JVM <a href="#attach_agent">has limitations</a>,
    which can be avoided <a href="#running_with_profiler">starting application with the profiler agent</a>.
  </p>

  <p>
    If you have only a console access (e.g. via ssh) to the machine where the application
    to be profiled is hosted, use the console version of the attach wizard.
    The wizard will load the profiler agent to specified running JVM.
    After it succeeds, you will be able to connect to that application
    via "Connect to remote application..." on the Welcome screen.
  </p>
  <ul>
    <li>
      <a href="https://www.yourkit.com/download/">Download</a> distribution bundle for the remote machine's platform
    </li>
    <li>
      Copy the distribution bundle file to the remote machine and unpack to arbitrary directory
      (or install if on Windows).
      <strong class="nobr">License key is NOT required</strong> to run the console version of the attach wizard.
    </li>
    <li>
      <p>
        Run this command and follow instructions that appear:
      </p>

      <h3>On Windows</h3>
      <p>
        <code class="nobr"><i>&lt;Profiler Installation Directory&gt;</i>\bin\attach.bat</code>
        <br/>
        or <br/>
        <code class="nobr"><i>&lt;Profiler Installation Directory&gt;</i>\bin\attach.bat <i>&lt;PID&gt;</i></code>
        <br/>
        or <br/>
        <code class="nobr"><i>&lt;Profiler Installation Directory&gt;</i>\bin\attach.bat <i>&lt;PID&gt;</i> <i>&lt;startup_options&gt;</i></code>
        <br/>
      </p>

      <h3>On other platforms</h3>
      <p>
        <code class="nobr"><i>&lt;directory with unpacked content&gt;</i>/bin/yjp.sh -attach</code>
        <br/>
        or <br/>
        <code class="nobr"><i>&lt;directory with unpacked content&gt;</i>/bin/yjp.sh -attach <i>&lt;PID&gt;</i></code>
        <br/>
        or <br/>
        <code class="nobr"><i>&lt;directory with unpacked content&gt;</i>/bin/yjp.sh -attach <i>&lt;PID&gt;</i> <i>&lt;startup_options&gt;</i></code>
        <br/>
      </p>
      <p>
        <code class="nobr"><i>&lt;PID&gt;</i></code>
        is an optional parameter.
        Specify it to immediately attach the agent to particular application.
        If <code class="nobr"><i>&lt;PID&gt;</i></code> is not specified,
        the wizard will show the list of running JVMs
        and offer to choose to which JVM to connect.
      </p>
      <p>
        <code class="nobr"><i>&lt;startup_options&gt;</i></code>
        is an optional parameter to specify additional <a href="#startup_options">startup options</a>.
        If <code class="nobr"><i>&lt;PID&gt;</i></code> parameter is not specified,
        the wizard will offer to specify startup options.
      </p>
      <figure>
        <img alt="" src="resources/attach_wizard.gif"/>
      </figure>
    </li>
    <li>
      After the profiler agent is loaded, its port will be printed out.
      Use it to connect to the profiled application
      via "Connect to remote application..." on the Welcome screen.
    </li>
  </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='startup_options'>2.3&nbsp;Startup options</h1>

  <h2>What are the startup options?</h2>
  <p>
    The startup options allow to customize some aspects of profiling.
    These options can be configured when you start the profiled application.
  </p>

  <h2>When should I specify the startup options?</h2>
  <p>
    In most cases, you do not have to specify any of these options,
    because default behavior suits fine in most cases.
  </p>

  <h2>How can I specify the startup options?</h2>
  <p>
    These options can be configured when you start the profiled application:
  </p>

  <ul>
    <li>
      from <a href="#ide_integration">the IDE plug-in UI</a>, if you start the profiled application from IDE
    </li>
    <li>
      <a href="#local_profiling">local</a> or <a href="#profiling_j2ee_remote">remote</a> Java EE server integration wizard,
      if you profile a stand-alone Java EE server
    </li>
    <li>
      with the help of <a href="#agent">agent command line parameter</a>.
    </li>
  </ul>

  <p>
    The options are comma-separated if you specify more than one option.
  </p>

  <h2>Description of the startup options</h2>

  <table class="tbl-with-border">
    <thead>
      <tr>
        <td colspan="2">
          <h3>Main options</h3>

          These options can be switched on startup only, i.e. corresponding behavior cannot be altered during runtime.
        </td>
      </tr>
    </thead>

    <tr>
      <td>
        <code class="nobr">port</code>=<i>&lt;value&gt;</i>
      </td>
      <td id="port">
        <p>
          Specify the port that the profiler agent listens on for communication with the Profiler.
        </p>
        <p>
          By default, the port is chosen automatically:
          if port <em>10001</em> is free, it is used; otherwise, if port <em>10002</em> is free, it is used etc.;
          if no port in the range <em>10001..10010</em> is free, an arbitrary free port is used.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <code class="nobr">listen</code>=<i>&lt;ip:port&gt;</i>
      </td>
      <td id="listen">
        <p>
          Same as <code class="nobr">port</code> but this binds agent socket to a particular IP only.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">onlylocal</code></td>
      <td id="onlylocal">
        <p>
          Allow only local connections to the profiled application.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <code class="nobr">delay</code>=<i>&lt;milliseconds&gt;</i>
      </td>
      <td id="delay">
        <p>
          Postpone start of telemetry collection.
          This option is mostly intended to prevent startup issues of some Java EE servers.
        </p>
        <p>
          By default, lightweight telemetry is collected right from the start of
          the profiled application.
        </p>
        <p>
          The telemetry is collected via so called platform MBeans ("managed beans") -
          the components for monitoring and managing the JVM.
          Some Java EE servers install their own implementations of standard MBeans.
          In earliest stages of the server startup the MBeans can not be functional
          because they depend on other components of the server (such as
          custom logging) which have not initialized so far.
          Accessing such MBeans in earliest stages can cause the server startup failure
          (e.g. with ClassNotFoundException).
        </p>
        <p>
          The <code class="nobr">delay</code> option ensures that all MBeans are completely initialized before they are first accessed,
          by postponing the start of collecting the telemetry.
        </p>
        <p>
          The Java EE integration wizard by default uses <code class="nobr">delay=10000</code> to postpone the telemetry for 10 seconds.
          Although not all servers (and not all versions of particular server) suffer from the problem with MBeans,
          it is recommended to always use the delay when profiling a Java EE server to ensure that <i>any</i> Java EE server can successfully start.
          Furthermore, the telemetry of first few seconds of the server startup is unlikely of any interest for you,
          because the server's internals are being initialized during that time
          rather than your own application code.
        </p>
        <p>
          If the 10 seconds delay is not enough in your particular case, try a bigger value.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">telemetrylimit</code>=<i>&lt;hours&gt;</i></td>
      <td id="telemetrylimit">
        
        <p>
          The telemetry information is remembered in a circular buffer in the profiler agent memory.
          This allows you to connect to a profiled application on demand and discover how the application behaved in the past.
        </p>
        <p>
          By default, the telemetry buffer is limited to store approximately 1 hour of recent telemetry data.
        </p>
        <p>
          With the help of the <code class="nobr">telemetrylimit</code> option you can customize
          the time period within which the telemetry data is being stored.
        </p>
        <p>
          <strong>Do not use unnecessarily long buffers</strong>
        </p>
        <p>
          Extending the telemetry buffer will allocate additional amount of memory
          in the profiled application's address space.
          That is especially important for 32-bit processes
          because their address space is limited.
        </p>
        <p>
          Also, the longer the buffer, the more time it takes
          to retrieve the telemetry information from the profiler agent
          when you connect to a long running profiled application.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">telemetryperiod</code>=<i>&lt;milliseconds&gt;</i></td>
      <td id="telemetryperiod">
        <p>
          Specify how often telemetry information is obtained.
        </p>
        <p>
          By default, the period is 1 second (1000 milliseconds).
        </p>
        <p>
          Note that setting smaller period can add overhead.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">probetablelengthlimit</code>=<i>&lt;rows&gt;</i></td>
      <td id="probetablelengthlimit">
        Probes: limit the number of rows to be stored by the profiler agent per table.
        <a href="#scalability">Read more...</a>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">deadthreadlimit</code>=<i>&lt;threads&gt;</i></td>
      <td id="deadthreadlimit">
        <p>
          Specify the number of recently finished threads for which
          <a href="#cpu_intro">CPU sampling, tracing</a>
          and <a href="#monitor_profiling">monitor</a>
          profiling results are kept (the default value is 50).
          Profiling results for the finished threads beyond this limit are merged to
          <code class="nobr"><i>&lt;Oldest finished threads&gt;</i></code> pseudo-thread node.
          The intention is to limit collected data size when profiling applications constantly creating new short living threads.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">onexit=memory</code></td>
      <td id="onexit_memory">
        <p>
          Always capture a memory snapshot on profiled application exit.
        </p>
        <p>
          If this option is not specified,
          the memory snapshot will be captured on exit
          if <a href="#allocations">object allocation recording</a> is running at that moment.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">onexit=snapshot</code></td>
      <td id="onexit_snapshot">
        <p>
          Always capture a performance snapshot on profiled application exit.
        </p>
        <p>
          If this option is not specified,
          the performance snapshot will be captured on exit if
          <a href="#cpu_intro">CPU sampling or tracing</a>
          or <a href="#monitor_profiling">monitor profiling</a>
          is running at that moment.
        </p>
        <p>
          This option is automatically added
          when the profiled application is <a href="#ide_integration">started from the IDE</a>.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <code class="nobr">dir</code>=<i>&lt;directory for snapshots&gt;</i>
      </td>
      <td id="dir">
        <p>
          Specify custom <a href="#snapshot_dir">snapshot directory</a> for the particular profiled application
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">logdir</code>=<i>&lt;directory&gt;</i></td>
      <td id="logdir">
        <p>
          By default, the profiler agent log file is <code class="nobr"><i>&lt;user home&gt;</i>/.yjp/log/<i>&lt;session name&gt;</i>-<i>&lt;PID&gt;</i>.log</code>
        </p>
        <p>
          Use this option to create logs in different directory.
        </p>
        <p>
          For example, it can be useful when profiling applications running as a Windows service.
          They usually run under special user,
          thus the logs are located in that special user's home directory.
          For example, it can be <code class="nobr">C:\WINDOWS\system32\config\systemprofile</code>.
          It can be difficult to find that directory and to open it in explorer.
        </p>
        <p>
          Instead, make the logs created in an arbitrary easily accessible directory,
          e.g. <code class="nobr">logdir=c:\log</code>
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">united_log</code></td>
      <td id="united_log">
        <p>
          Store logs from several runs of the same application
          as a series of log files named <i>&lt;session name&gt;</i><code>.</code><i>&lt;running number&gt;</i><code class="nobr">.log</code>
          instead of creating an individual log file <code class="nobr"><i>&lt;session name&gt;</i>-<i>&lt;PID&gt;</i>.log</code>
          for each profiled process.
        </p>
        <p>
          This mode may simplify log maintenance and cleanup when profiling applications such as servers.
        </p>
        <p>
          <i>Session name</i> is the presentable name of the application;
          see the startup option <code class="nobr">sessionname</code>=<i>&lt;name&gt;</i> for detail.
        </p>
        <p>
          <i>Running number</i> starts with 1.
          If the first log file <i>&lt;session name&gt;</i><code class="nobr">.1.log</code> exceeds the size limit,
          a new log file <i>&lt;session name&gt;</i><code class="nobr">.2.log</code> will be created and used,
          then <i>&lt;session name&gt;</i><code class="nobr">.3.log</code> etc.
          The size limit is 1 MB by default,
          and can be changed with the startup option <code class="nobr">log_file_size_limit=</code><i>&lt;bytes&gt;</i>
        </p>
        <p>
          Note: the oldest log files are not automatically removed.
          If you need to clean them up, do it manually or write a script.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">sessionname</code>=<i>&lt;name&gt;</i></td>
      <td id="sessionname">
        <p>
          Specify alternate presentable name of the profiled application used in:
        </p>
        <ul>
          <li>the profiler UI;</li>
          <li>snapshot names;</li>
          <li>log file name.</li>
        </ul>
        <p>
          If this option is not specified, the session name is automatically chosen for particular application
          basing on its main jar file name, or its main class name,
          or the custom executable name,
          or on the run configuration name when profiling from within IDE.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">snapshot_name_format</code>=<i>&lt;format&gt;</i></td>
      <td id="snapshot_name_format">
        <p>
          Specify alternate rule to compose snapshot file names.
        </p>
        <p>
          Available macros:
        </p>
        <ul>
          <li><code>{sessionname}</code> - session name</li>
          <li><code>{date}</code> - snapshot capture date in format 'yyyy-MM-dd'</li>
          <li><code>{datetime}</code> - snapshot capture date and time in format 'yyyy-MM-dd-HH-mm'</li>
          <li><code>{pid}</code> - profiled process ID</li>
        </ul>
        <p>
          The default format is <code>{sessionname}-{date}</code>.
        </p>
        <p>
          Characters not allowed in file names, if specified, will be replaced with '-'.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">sampling_settings_path</code>=<i class="nobr">&lt;file path&gt;</i></td>
      <td id="sampling_settings_path">
        <p>
          Specify a custom location of the <a href="#sampling_settings">CPU sampling settings</a>
          configuration file.
        </p>
        <p>
          If this option is not specified,
          the settings are read from
          <code class="nobr"><i>&lt;user home&gt;</i>/.yjp/sampling.txt</code>,
          where <i>user home</i> corresponds to the account under which a profiled application is launched.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">tracing_settings_path</code>=<i class="nobr">&lt;file path&gt;</i></td>
      <td id="tracing_settings_path">
        <p>
          Specify a custom location of the <a href="#tracing_settings">CPU tracing settings</a>
          configuration file.
        </p>
        <p>
          If this option is not specified,
          the settings are read from
          <code class="nobr"><i>&lt;user home&gt;</i>/.yjp/tracing.txt</code>,
          where <i>user home</i> corresponds to the account under which a profiled application is launched.
        </p>
      </td>
    </tr>

    <thead>
      <tr>
        <td colspan="2">
          <h3>Control which profiling modes are turned on right from the start</h3>
          <p>
            Note that you do not have to perform measuring right from the start.
            Instead, in many cases it's better to start or stop measuring at a later moment -
            from the UI or by using the <a href="#api">Profiler API</a>.
          </p>
        </td>
      </tr>
    </thead>

    <tr>
      <td><code class="nobr">sampling</code></td>
      <td id="sampling">
        <p>
          Immediately start CPU profiling in the <a href="#cpu_intro">CPU sampling</a> mode.
          Note that you do not have to profile CPU right from the start;
          instead, in many cases it's better to start or stop measuring at a later moment -
          from the UI or by using the <a href="#api">Profiler API</a>.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">tracing</code></td>
      <td id="tracing">
        <p>
          Immediately start CPU profiling in the <a href="#cpu_intro">CPU tracing</a> mode.
          Note that you do not have to profile CPU right from the start;
          instead, in many cases it's better to start or stop measuring at a later moment -
          from the UI or by using the <a href="#api">Profiler API</a>.
          This option cannot be used in combination with <code class="nobr">disabletracing</code>.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">call_counting</code></td>
      <td id="call_counting">
        <p>
          Immediately start CPU profiling in the <a href="#cpu_intro">call counting</a> mode.
          Note that you do not have to profile CPU right from the start;
          instead, in many cases it's better to start or stop measuring at a later moment -
          from the UI or by using the <a href="#api">Profiler API</a>.
          This option cannot be used in combination with <code class="nobr">disabletracing</code>.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">alloceach</code>=<i>&lt;N&gt;</i></td>
      <td id="alloceach">
        <p>
          Immediately start <a href="#allocations">object allocation recording</a>,
          recording each N-th allocation.
        </p>
        <p>
          This option can be used in combination with <code class="nobr">allocsizelimit</code>, but is mutually exclusive with <code class="nobr">alloc_object_counting</code>.
          This option cannot be used in combination with <code class="nobr">disablealloc</code>.
        </p>
        <p>
          (Since 2016.02) To record only those objects whose size exceeds the threshold set with <code class="nobr">allocsizelimit</code>
          please specify <code class="nobr">alloceach=0</code>.
        </p>
        <p>
          Note that you do not have to record allocations right from the start;
          instead, you can start or stop recording later from the profiler UI or using <a href="#api">Profiler API</a>.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">allocsizelimit</code>=<i>&lt;size in bytes&gt;</i></td>
      <td id="allocsizelimit">
        <p>
          Immediately start <a href="#allocations">object allocation recording</a>,
          recording allocation of all objects with size bigger than or equal to specified value.
        </p>
        <p>
          This option can be used in combination with <code class="nobr">alloceach</code>, but is mutually exclusive with <code class="nobr">alloc_object_counting</code>.
          This option cannot be used in combination with <code class="nobr">disablealloc</code>.
        </p>
        <p>
          Note that you do not have to record allocations right from the start;
          instead, you can start or stop recording later from the profiler UI or using <a href="#api">Profiler API</a>.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">allocsampled</code></td>
      <td id="allocsampled">
        <p>
          Use sampled <a href="#allocations">object allocation recording</a>.
          This option influences only object allocation recording started
          <code class="nobr">alloceach</code> and <code class="nobr">allocsizelimit</code>.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">alloc_object_counting</code></td>
      <td id="alloc_object_counting">
        <p>
          Immediately start <a href="#allocations">object allocation recording</a> in the object counting mode.
        </p>
        <p>
          This option is mutually exclusive with <code class="nobr">alloceach</code> and <code class="nobr">allocsizelimit</code>.
          This option cannot be used in combination with <code class="nobr">disablealloc</code>.
        </p>
        <p>
          Note that you do not have to record allocations right from the start;
          instead, you can start or stop recording later from the profiler UI or using <a href="#api">Profiler API</a>.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">monitors</code></td>
      <td id="monitors">
        <p>
          Immediately start <a href="#monitor_profiling">monitor profiling</a>.
          Note that you do not have to profile monitor usage right from the start;
          instead, you can start or stop recording later from the profiler UI or using <a href="#api">Profiler API</a>.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">usedmem</code>=<i>&lt;percent&gt;</i></td>
      <td id="usedmem">
        <p>
          <a href="#snapshot_on_high_memory_usage">Automatically capture</a> a memory snapshot
          when used heap memory reaches the threshold.
        </p>
        <p>
          Note: this option just adds corresponding <a href="#triggers">trigger</a> on startup.
          Use triggers directly for a more sophisticated functionality.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">usedmemhprof</code>=<i>&lt;percent&gt;</i></td>
      <td id="usedmemhprof">
        <p>
          <a href="#snapshot_on_high_memory_usage">Automatically capture</a> a <a href="#hprof_snapshots">HPROF snapshot</a>
          when used heap memory reaches the threshold.
        </p>
        <p>
          Note: this option just adds corresponding <a href="#triggers">trigger</a> on startup.
          Use triggers directly for a more sophisticated functionality.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">periodicperf</code>=<i>&lt;period in seconds&gt;</i></td>
      <td id="periodicperf">
        <p>
          <a href="#periodic">Periodically capture</a> performance snapshots.
        </p>
        <p>
          Note: this option just adds corresponding <a href="#triggers">trigger</a> on startup.
          Use triggers directly for a more sophisticated functionality.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">periodicmem</code>=<i>&lt;period in seconds&gt;</i></td>
      <td id="periodicmem">
        <p>
          <a href="#periodic">Periodically capture</a> memory snapshots in the profiler's format (*.snapshot).
        </p>
        <p>
          Note: this option just adds corresponding <a href="#triggers">trigger</a> on startup.
          Use triggers directly for a more sophisticated functionality.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">periodichprof</code>=<i>&lt;period in seconds&gt;</i></td>
      <td>
        <div id="periodichprof">
          <p>
            <a href="#periodic">Periodically capture</a> <a href="#hprof_snapshots">HPROF snapshots</a>.
          </p>
          <p>
            Note: this option just adds corresponding <a href="#triggers">trigger</a> on startup.
            Use triggers directly for a more sophisticated functionality.
          </p>
        </div>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">disablestacktelemetry</code></td>
      <td id="disablestacktelemetry">
        <p>
          Do not collect thread stack and status information
          shown in <a href="#threads">Thread</a> view
          as well as in other telemetry views.
          This information can be very useful because it allows you
          to connect to the profiled application on demand and discover how the application behaved in the past.
          In most cases, there is no significant overhead of collecting this information.
          However, it makes sense to disable it in production Java EE servers
          in order to ensure minimum profiling overhead.
        </p>
        <p>
          See also: <a href="#overhead">Profiling overhead: how to reduce or avoid</a>.
        </p>
      </td>
    </tr>

    <tr>
      <td><code class="nobr">exceptions=on</code></td>
      <td id="exceptions_on">
        <p>
          Enable exception events in the JVM and immediately start recording the <a href="#exception_telemetry">exception telemetry</a>.
        </p>
        <p>
          This is the default mode on Sun/Oracle HotSpot, OpenJDK, JRockit (i.e. non-IBM JVMs).
        </p>
        <p>
          See also: <a href="#overhead">Profiling overhead: how to reduce or avoid</a>.
        </p>
      </td>
    </tr>

    <tr>
      <td><code class="nobr">exceptions=off</code></td>
      <td id="exceptions_off">
        <p>
          Enable exception events in the JVM but do not immediately start recording the <a href="#exception_telemetry">exception telemetry</a>
          that can instead be recorded later in runtime.
        </p>
        <p>
          See also: <a href="#overhead">Profiling overhead: how to reduce or avoid</a>.
        </p>
      </td>
    </tr>

    <tr>
      <td><code class="nobr">exceptions=disable</code></td>
      <td id="exceptions_disable">
        <p>
          Fully disable exception events in the JVM to totally eliminate corresponding overhead.
          The <a href="#exception_telemetry">exception telemetry</a> will not be available.
        </p>
        <p>
          This is the <strong>default mode on IBM JVMs</strong> because the overhead is significant.
        </p>
        <p>
          See also: <a href="#overhead">Profiling overhead: how to reduce or avoid</a>.
        </p>
      </td>
    </tr>

    <tr>
      <td><code class="nobr">disableoomedumper</code></td>
      <td id="disableoomedumper">
        <p>
          Disable <a href="#out_of_memory">on OutOfMemoryError snapshots</a>.
          Note that enabling on OutOfMemoryError snapshots adds absolutely no overhead.
          If OutOfMemoryError happens, memory snapshot is written to disk for further analysis.
          You may want to disable the snapshots in some very special situations,
          e.g. if you profile an application with a huge heap, for which capturing the snapshot
          may take significant resources (time and/or disk space),
          but do not plan to perform its memory analysis.
        </p>
      </td>
    </tr>

    <tr>
      <td>
        <p><code class="nobr">probe_on</code>=<i>&lt;pattern&gt;</i></p>
        <p><code class="nobr">probe_off</code>=<i>&lt;pattern&gt;</i></p>
        <p><code class="nobr">probe_auto</code>=<i>&lt;pattern&gt;</i></p>
        <p><code class="nobr">probe_disable</code>=<i>&lt;pattern&gt;</i></p>
      </td>
      <td>
        <p>
          Specify which probes should be registered on startup.
          <a href="#register_probes">Read more...</a>
        </p>
      </td>
    </tr>

    <tr>
      <td><code class="nobr">probeclasspath</code>=<i>&lt;classpath&gt;</i></td>
      <td id="probeclasspath">
        <p>
          Specify where to find probe class(es) which are registered by class name.
          <a href="#register_probes">Read more...</a>
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">probebootclasspath</code>=<i>&lt;classpath&gt;</i></td>
      <td id="probebootclasspath">
        <p>
          Specify where to find probe class(es) which are registered by class name.
          <a href="#register_probes">Read more...</a>
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">triggers</code>=<i>&lt;file path&gt;</i></td>
      <td id="triggers">
        <p>
          Specify the file with description of the <a href="#triggers">triggers</a>
          to be applied from startup.
        </p>
        <p>
          If this option is not specified, the trigger description is read from
          <code class="nobr"><i>&lt;user home&gt;</i>/.yjp/triggers.txt</code>,
          where <i>user home</i> corresponds to the account under which a profiled application is launched.
        </p>
        <p>
          By default, that file does not exist, thus no triggers are applied.
        </p>
      </td>
    </tr>

    <thead>
      <tr>
        <td colspan="2">
          <h3>Optimization options</h3>

          <p>Reduce profiling overhead by disabling some profiling capabilities.</p>

          <p>
            These options can be switched on startup only, i.e. corresponding behavior cannot be altered during runtime.
          </p>

          <p>See also: <a href="#overhead">Profiling overhead: how to reduce or avoid</a>.</p>
        </td>
      </tr>
    </thead>

    <tr>
      <td><code class="nobr">disablealloc</code></td>
      <td id="disablealloc">
        <p>
          Do not instrument bytecode with instructions needed for <a href="#allocations">object allocation recording</a>.
        </p>
        <p>
          See also: <a href="#overhead">Profiling overhead: how to reduce or avoid</a>.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">disabletracing</code></td>
      <td id="disabletracing">
        <p>
          Do not instrument bytecode with instructions needed for <a href="#cpu_intro">CPU tracing</a>.
          Only <a href="#cpu_intro">CPU sampling</a> will be available.
        </p>
        <p>
          See also: <a href="#overhead">Profiling overhead: how to reduce or avoid</a>.
        </p>
      </td>
    </tr>
    <tr>
      <td><code class="nobr">disableall</code></td>
      <td id="disableall">
        <p>
          Disable several capabilities at once:
          <code class="nobr">disablealloc</code>,
          <code class="nobr">disabletracing</code>,
          <code class="nobr">exceptions=disable</code>,
          <code class="nobr">disablestacktelemetry</code>,
          <code class="nobr">probe_disable=*</code>
        </p>
      </td>
    </tr>

    <thead>
      <tr>
        <td colspan="2">
          <h3>Miscellaneous</h3>
        </td>
      </tr>
    </thead>

    <tr>
      <td><code class="nobr">help</code></td>
      <td id="help">
        <p>
          Print brief description of startup options.
        </p>
      </td>
    </tr>
  </table>
  <br/>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='attach_agent'>2.4&nbsp;Attaching profiler agent to a running JVM</h1>


  <p>
    To profile a Java application, the profiler agent should be loaded into the JVM.
  </p>

  <p>
    There are two ways to do it:
  </p>

  <ul>
    <li>
      Start the profiled application with the profiler agent,
      using
      <a href="#ide_integration">IDE integration</a>,
      <a href="#local_profiling">local</a> and <a href="#profiling_j2ee_remote">remote</a> Java EE server integration wizard,
      or <a href="#agent">manually specifying</a> appropriate JVM option.
    </li>
    <li>
      Attach the profiler agent to a running JVM instance on demand.
    </li>
  </ul>

  <p>
    The second approach (attach mode) simplifies profiling,
    making it even more "on-demand profiling" than ever.
    Avoid a special step to enable profiling: any running Java application can be profiled.
  </p>

  <h2>How to attach to a local application</h2>

  <p>
    In Welcome screen,
    click corresponding element in the list.
  </p>
  <figure>
    <img alt="" src="resources/welcome_screen_attach.png"/>
  </figure>
  <p>
    The list of applications to attach
    (both in UI and when using <a href="#attach_wizard">remote attach wizard</a>)
    contains applications detected via standard JVM enumeration mechanism,
    as well as applications not detected via standard JVM enumeration mechanism,
    such as Tomcat running as Windows service,
    or processes <code class="nobr">java.exe</code> and <code class="nobr">javaw.exe</code> running under different user
    (in particular, other Java EE servers started as Windows service).
  </p>
  <p>
    Anyway, it is possible that a Java application which was not started with standard Java launcher
    (<code class="nobr">java</code>, <code class="nobr">java.exe</code>, <code class="nobr">javaw.exe</code>),
    or was started under a different user,
    will not be automatically detected and thus will not be shown in the list of locally running applications.
  </p>
  <p>
    To profile such application, use "Attach by PID"
    (you can learn the PID via Task Manager in Windows or <code class="nobr">ps</code> command on non-Windows).
    After successful attach, the application will appear in the list.
  </p>
  <figure>
    <img alt="" src="resources/attach_by_PID.png"/>
  </figure>

  <h2>How to attach to a remote application</h2>

  <p>
    Run <a href="#attach_wizard">attach wizard</a> on the remote machine,
    then use "Connect to remote application..." from Welcome screen.
  </p>

  <h2>The attach mode limitations</h2>

  <p>
    Unfortunately, the attach mode is not an ultimate solution.
    The problem is that existing JVMs provide only limited set of profiling capabilities for the attached agents.
    To get all profiling capabilities,
    you still have to
    <a href="#running_with_profiler">start the profiled application with the profiler agent</a>
    instead.
  </p>

  <ul>
    <li>
      <p>
        The attach mode is only supported for Sun Java (HotSpot) and JRockit.
      </p>
      <p>
        Existing IBM VMs do not provide necessary capabilities
        to let YourKit Java Profiler function in the attach mode.
        To profile on IBM Java,
        please <a href="#running_with_profiler">start application with the profiler agent</a>.
        If necessary capabilities are added in future versions of IBM Java,
        the profiler will support attach mode for IBM Java too.
      </p>
    </li>
    <li>
      <p>
        Attach may fail due to insufficient access rights.
        For example, it may not be possible to attach to a Java EE server
        running as a Windows service.
        If attempt to attach fails,
        <a href="#running_with_profiler">start the application with the profiler agent</a> instead.
      </p>
    </li>
    <li>
      <p>
        Client JVM can crash in attach mode due to a JVM bug
      </p>
      <p>
        Due to <a class="ext" href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6776659">a JVM bug 6776659</a>
        HotSpot client JVM can crash in attach mode.
      </p>
      <p>
        There is no crash for the server JVM:
        <strong>JVM option <code class="nobr">-server</code> solves the problem</strong>.
      </p>
    </li>
    <li>
      <p>
        A long pause is possible on first attempt to start CPU tracing or object allocation recording,
        because classes loaded before the profiler agent has attached
        need to be instrumented.
        Depending on application, it can take from several seconds to
        several tens of seconds, or even a few minutes in worst cases.
      </p>
      <p>
        The good news is that there will be no pause on
        subsequent starts of CPU tracing or object allocation recording
        for the same running JVM instance.
      </p>
    </li>

    <li>
      <p>
        No profiling results for some methods:
      </p>
      <ul>
        <li>
          JVM may not be able to apply bytecode instrumentation to methods of the objects that have been created before the agent attached.
          Instead, the old, non-instrumented version of the bytecode will keep running for them. This is a limitation of the JVM.
        </li>
        <li>
          Another JVM limitation is that native methods of classes that have loaded before the profiler agent attached
          cannot be instrumented at all.
          (There is no problem with classes loaded after the profiler has attached.)
        </li>
      </ul>
      <p>
        This means that their calls will be missing in:
      </p>
      <ul>
        <li>CPU tracing results (no problem for CPU sampling as it does not depend on bytecode instrumentation)</li>
        <li>results of <a href="#probes">probes</a> depending on instrumentation of those methods, in particular, in the "Events" and "Performance Charts" views</li>
      </ul>
    </li>

    <li>
      <a href="#exception_telemetry">Exception telemetry</a> is not available
    </li>
  </ul>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='overhead'>2.5&nbsp;Profiling overhead: how to reduce or avoid</h1>

  <p>
    The profiler may add some overhead to the performance of applications you profile.
    This overhead may vary from virtually zero to significant, depending on the conditions described below.
  </p>

  <h2>Overhead of running an application with the profiler</h2>

  <p>
    To enable such features as recording object allocation and CPU tracing,
    the profiler inserts some supporting code into the bytecode of the profiled application by means of bytecode instrumentation.
    When object allocation recording and CPU tracing are not performed, this inserted code is in inactive state
    but still adds a small overhead to the performance of instrumented methods (1-5%, depending on the application).
    The process of bytecode instrumentation itself, of course, also requires some fixed time that depends on the number of loaded
    classes and their methods.
  </p>
  <p>
    In most cases, such overhead is more than acceptable.
  </p>
  <p>
    For cases when maximum performance is needed, e.g. if profiling in production, this <b>overhead can be totally eliminated</b>
    by avoiding bytecode instrumentation.
    The price you pay is that some features are disabled.
    But even when they are disabled, you can still capture memory snapshots and perform CPU sampling,
    which is enough in many cases (see <a href="#performance_problems">Solving performance problems</a>).
  </p>

  <p>
    You can disable bytecode instrumentation
    by specifying "disabletracing", "disablealloc" and "probe_disable=*" <a href="#startup_options">startup options</a>.
  </p>

  <p>
    Since the greatest share of the overhead described above is caused by instrumentation needed for tracing,
    as a compromise you can disable this feature alone, keeping the ability to record object allocations on demand.
  </p>

  <p>
    There is another, almost negligible, issue:
    if JVM loads an agent that is capable of profiling
    heap memory, JVM class data sharing is disabled. This may slightly increase startup time,
    i.e. the time the JVM needs to load its core classes from <code class="nobr">rt.jar</code>.
    For details about class sharing, refer to this page on the Sun website:
    <a class="ext" href="http://java.sun.com/j2se/1.5.0/docs/guide/vm/class-data-sharing.html">http://java.sun.com/j2se/1.5.0/docs/guide/vm/class-data-sharing.html</a>
  </p>

  <h2>Overhead when measuring is performed</h2>

  <p>
    When <a href="#cpu_intro">CPU profiling</a> and/or <a href="#allocations">object allocation recording</a> are performed,
    the profiler adds extra overhead. After measuring is done and turned off, overhead should decrease to the level
    described above in "Overhead of running an application with the profiler".
  </p>

  <h2>Snapshot capture</h2>

  <p>
    During the capture, the profiled application is paused.
    The time it takes to capture a memory snapshot depends on the heap size.
    Capturing memory snapshots of huge heaps takes more time
    because of the intensive use of the system swap file
    (if little free physical memory is available).
  </p>

  <h2>Thread stack and status telemetry</h2>

  <p>
    Thread stack and status information is shown in
    <a href="#threads">Thread</a> view
    as well as in other telemetry views.
    This information can be very useful because it allows you
    to connect to the profiled application on demand and discover how the application behaved in the past.
    In most cases, there is no significant overhead of collecting this information.
  </p>
  <p>
    However, it makes sense to disable it in production Java EE servers
    in order to ensure minimum profiling overhead.
    This can be done with the help of "disablestacktelemetry" <a href="#startup_options">startup option</a>.
  </p>

  <h2>Exception telemetry</h2>

  <p>
    <a href="#exception_telemetry">Exception telemetry</a> helps discovering performance issues and logic errors.
    In most cases, there is no significant overhead of collecting this information.
  </p>
  <p>
    However, it makes sense to disable it in production Java EE servers
    in order to ensure minimum profiling overhead.
    This can be done with the help of "disablestacktelemetry" <a href="#startup_options">startup option</a>.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='agent'>2.6&nbsp;Enabling profiling manually</h1>

  <p class="hint">
    Most likely, you will not need to configure profiling manually.
    Please first consider the automated ways to enable profiling in
    your <a href="#local_profiling">local</a> or <a href="#remote_profiling">remote application</a>.
  </p>

  <h2>Step 1: Add VM option '-agentpath'</h2>

  <p>
    Add <code class="nobr">-agentpath:<i>&lt;full agent library path&gt;</i></code> VM option
    to the command line of Java application to be profiled.
  </p>

  <p>The agent library path depends on your OS:</p>

  <table class="tbl-with-border tbl-with-strong-thead">
    <thead>
      <tr>
        <td colspan="2">Platform</td>
        <td>VM option</td>
      </tr>
    </thead>

    <tr>
      <td rowspan="2">Windows</td>
      <td><span class="nobr">32-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>\bin\win32\yjpagent.dll</code></td>
    </tr>
    <tr>
      <td><span class="nobr">64-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>\bin\win64\yjpagent.dll</code></td>
    </tr>

    <tr>
      <td colspan="2">Mac OS X</td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/mac/libyjpagent.jnilib</code></td>
    </tr>

    <tr>
      <td rowspan="8">Linux</td>
      <td>x86, <span class="nobr">32-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/linux-x86-32/libyjpagent.so</code></td>
    </tr>
    <tr>
      <td>x86, <span class="nobr">64-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/linux-x86-64/libyjpagent.so</code></td>
    </tr>
    <tr>
      <td>ARMv7, <span class="nobr">hard-float</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/linux-armv7-hf/libyjpagent.so</code></td>
    </tr>
    <tr>
      <td>ARMv5, <span class="nobr">soft-float</span></td>
      <td>
        <p>
          <code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/linux-armv5-sf/libyjpagent.so</code>
        </p>
        <p class="hint">
          You may also need to add <code class="nobr">libstdc++.so.6</code> to <code class="nobr">LD_LIBRARY_PATH</code>
          to satisfy dependencies
        </p>
      </td>
    </tr>
    <tr>
      <td>ARM AArch64</td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/linux-aarch64/libyjpagent.so</code></td>
    </tr>
    <tr>
      <td>ppc, <span class="nobr">32-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/linux-ppc-32/libyjpagent.so</code></td>
    </tr>
    <tr>
      <td>ppc64, <span class="nobr">64-bit Java, big-endian</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/linux-ppc-64/libyjpagent.so</code></td>
    </tr>
    <tr>
      <td>ppc64le, <span class="nobr">64-bit Java, little-endian</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/linux-ppc-64/libyjpagent.so</code></td>
    </tr>

    <tr>
      <td rowspan="4">Solaris</td>
      <td>SPARC, <span class="nobr">32-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/solaris-sparc-32/libyjpagent.so</code></td>
    </tr>
    <tr>
      <td>SPARC, <span class="nobr">64-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/solaris-sparc-64/libyjpagent.so</code></td>
    </tr>
    <tr>
      <td>x86, <span class="nobr">32-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/solaris-x86-32/libyjpagent.so</code></td>
    </tr>
    <tr>
      <td>x86, <span class="nobr">64-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/solaris-x86-64/libyjpagent.so</code></td>
    </tr>

    <tr>
      <td rowspan="2">HP-UX</td>
      <td>IA64, <span class="nobr">32-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/hpux-ia64-32/libyjpagent.so</code></td>
    </tr>
    <tr>
      <td>IA64, <span class="nobr">64-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/hpux-ia64-64/libyjpagent.so</code></td>
    </tr>

    <tr>
      <td rowspan="2">AIX</td>
      <td>ppc, <span class="nobr">32-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/aix-ppc-32/libyjpagent.so</code></td>
    </tr>
    <tr>
      <td>ppc64, <span class="nobr">64-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/aix-ppc-64/libyjpagent.so</code></td>
    </tr>

    <tr>
      <td rowspan="2">FreeBSD</td>
      <td>x86, <span class="nobr">32-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/freebsd-x86-32/libyjpagent.so</code></td>
    </tr>
    <tr>
      <td>x86, <span class="nobr">64-bit Java</span></td>
      <td><code class="nobr">-agentpath:<i>&lt;profiler directory&gt;</i>/bin/freebsd-x86-64/libyjpagent.so</code></td>
    </tr>
  </table>
  <br/>

  <p>
    If you have copied the profiler agent library file from the profiler installation directory
    to another location, please change the path accordingly.
  </p>

  <p>
    You can find examples of startup scripts for your platform in
    <code class="nobr"><i>&lt;profiler directory&gt;</i>/samples</code>
  </p>

  <p>
    To check that Java can load the profiler agent, invoke the following command that
    prints a description of agent parameters:
  </p>
  <p>
    <code class="nobr">java -agentpath:<i>&lt;full agent library path&gt;</i>=help</code>
  </p>
  <p class="hint">
    If JVM reports an error,
    refer to <a href="https://www.yourkit.com/docs/kb/error2a.jsp">the knowledge base article</a> for troubleshooting.
  </p>

  <h2>Step 2: (Optional) Specify startup options</h2>

  <p>
    You can specify additional <a href="#startup_options">startup options</a>.
    In most cases there's no need to use them.
  </p>

  <p class="hint">
    To profile a Java EE server (especially JBoss!),
    specify startup option <a href="#delay">delay=10000</a>
  </p>

  <p>
    The options are comma separated: <code class="nobr">-agentpath:<i>&lt;full agent library path&gt;</i>[<strong>=</strong><i>&lt;option&gt;</i>, ...]</code>.
  </p>

  <h2>Examples</h2><br/>

  <p>
    <code class="nobr">java -agentpath:c:\yourkit\yjpagent.dll FooClass</code>
    <br/>
    <code class="nobr">java -agentpath:c:\yourkit\yjpagent.dll=alloceach=10,allocsizelimit=4096 FooClass</code>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='jvmti'>2.7&nbsp;About JVMTI (advanced topic)</h1>

  <p class="hint">
    This is an advanced topic.
    It provides details that you do not normally have to know to profile your applications.
    Read the following if you want to learn more about profiling capabilities provided by
    different versions of Java.
  </p>

  <h2>What a Java profiling API is</h2>

  <p>
    Any profiler, in order to provide profiling results, communicates with JVM by means of
    a special API.
    This API provides different services and influences the range of a profiler's capabilities.
  </p>

  <p>
    Starting with Java 5, a new standardized API was introduced -
    <a class="ext" href="http://download.oracle.com/javase/6/docs/technotes/guides/jvmti/index.html">JVMTI</a>.
    It had replaced JVMPI API used in previous Java versions.
  </p>

  <p>
    JVMTI utilizes so-called "bytecode instrumentation".
    This means that profilers, in order to collect profiling information, should modify the bytecode of profiled application, inserting
    at certain points some supporting bytecode instructions.
    There may be some <a href="#overhead">performance issues</a> because of this.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='connect'>3&nbsp;Connect to profiled application</h1>

  <p>
    Once you have <a href="#running_with_profiler">profiled application running</a>,
    you should connect to it to obtain and analyze profiling results.
  </p>

  <h2>Connect to locally running profiled application</h2>

  <p>
    "Locally running profiled application" means that the profiled application is running on the same computer
    where you are now using the profiler UI.
  </p>

  <p>
    The profiler can automatically detect all locally running profiled applications.
  </p>

  <p>
    To connect, use Welcome screen:
  </p>

  <figure>
    <img alt="" src="resources/connect_local.png"/>
  </figure>

  <p>
    Note: if you launch the profiled application from your <a href="#ide_integration">IDE</a>,
    the profiler UI will automatically start and connect to the application (unless you had turned this option off in the IDE).
  </p>

  <h2 id="remote">Connect to remote application</h2>

  <p class="hint">
    Important: first, you should
    <a href="#remote_profiling">enable profiling on the remote machine</a>.
    The remote application to profile should be running and
    have the profiler agent loaded.
  </p>

  <p>
    Use Welcome screen to connect to a profiled application that is running on a remote computer.
  </p>

  <figure>
    <img alt="" src="resources/connect_remote.png"/>
  </figure>

  <figure>
    <img alt="" src="resources/connect_remote_dialog.png"/>
  </figure>

  <p>
    You can simply specify the host (name or IP address) of the remote computer where the profiled application(s) is (are) running.
    In this case the profiler tries to automatically detect the profiled applications
    on ports in some predefined range. When the profiled application starts, the profiler agent first tries to
    use a port in this range, thus enabling an automatic scan of the applications on remote host.
  </p>

  <p>
    If you explicitly specified a port to be used by the profiler agent when launching the profiled application,
    you have to explicitly enter the port together with the host (using the syntax <code class="nobr">host:port</code>).
    Automatic detection will not work in this case.
    Also, you should specify the pair <code class="nobr">host:port</code> if
    there are so many profiled applications running simultaneously that for some of them there was no free port
    available in the predefined range.
  </p>

  <p>
    If you do not have a direct access to the host and port,
    you can use the built-in support for SSH tunneling.
  </p>

  <p>
    To establish an SSH tunnel, use the following syntax:
  </p>
  <p>
    <code class="nobr">user@ssh_server[:ssh_port] [host][:agent_port]</code>
  </p>
  <ul>
    <li>
      <code class="nobr">user</code> and <code class="nobr">ssh_server</code> are the credentials for the SSH connection to establish
    </li>
    <li>
      <code class="nobr">ssh_port</code> - specify if the server does not use the standard SSH port 22
    </li>
    <li>
      <code class="nobr">host</code> - the host on which the profiled application is running;
      <code class="nobr">ssh_server</code> will create a tunnel to that host.
      If the profiled application runs directly on <code class="nobr">ssh_server</code>, omit this parameter.
    </li>
    <li>
      <code class="nobr">agent_port</code> - profiler agent port. If not specified, all applications with agents
      listening on ports from the standard range will be discovered (the same as for a non-tunnelled connection).
    </li>
  </ul>

  <h3>Examples</h3>

  <ul>
    <li>
      <code class="nobr">john@server1</code> - connect to profiling application(s) running on host <code class="nobr">server1</code>;
      SSH will connect as <code class="nobr">john</code>
    </li>
    <li>
      <code class="nobr">john@server1 :12345</code> - connect to the profiling application running on <code class="nobr">server1</code>
      with the profiler agent listening on a custom port <code class="nobr">12345</code>;
      SSH will connect as <code class="nobr">john</code>.
    </li>
    <li>
      <code class="nobr">john@server1 server2</code> - connect to profiling application(s) running on host <code class="nobr">server2</code>,
      via SSH connection to <code class="nobr">server1</code> as <code class="nobr">john</code>
    </li>
    <li>
      <code class="nobr">john@server1 server2:12345</code> - connect to the profiling application running on <code class="nobr">server2</code>
      with the profiler agent listening on a custom port <code class="nobr">12345</code>,
      via SSH connection to <code class="nobr">server1</code> as <code class="nobr">john</code>.
    </li>
  </ul>

  <p>
    Authentication with a password or a private key is supported.
  </p>
  <p>
    You will be asked to provide the password each time you connect.
    The password is not stored anywhere, and is securely erased from memory once the SSH connection is established.
  </p>

  <figure>
    <img alt="" src="resources/connect_remote_auth.png"/>
  </figure>

  <p>
    Note: known hosts are not currently checked, and <code class="nobr">StrictHostKeyChecking</code> SSH parameter is set to <code class="nobr">no</code>.
  </p>


  <h2 id="troubleshooting">Remote profiling troubleshooting</h2>

  <p>
    If the remote profiled application cannot be found:
  </p>

  <ul>
    <li>
      <p>
        Ensure that the application is <a href="#remote_profiling">started with the profiler</a>
        and is running when you connect.
      </p>
      <p>
        If it didn't start or terminated by the moment, check the application's output, logs etc. for possible errors,
        or restart the application if it was intentionally shut down.
      </p>
    </li>
    <li>
      <p>
        If the application is up and running, ensure that the network connection is not blocked by a firewall,
        an antivirus etc.
      </p>
      <p>
        <strong>Check both the remote machine side and the local machine side.</strong>
        The profiler agent port must be allowed.
      </p>
      <p>
        Note: the profiler agent port is not one of the ports you may use to communicate with the profiled
        application or server, like HTTP 8080.
        Instead, it's a special dedicated port used solely by the profiler.
      </p>
      <p>
        By default, the profiler agent port is allocated from the range 10001-10010 or a random one is used
        if all ports in this range are busy,
        or can be explicitly specified with the <a href="#port">startup option 'port'</a>.
        If the profiler agent port is not in the default range 10001-10010,
        explicitly specify the port in the connect dialog as <code class="nobr">host:port</code>
      </p>
      <p>
        If you are unsure which port is used, look at the profiler agent log on the remote machine.
        It is created in <code class="nobr"><i>&lt;user home&gt;</i>/.yjp/log/<i>&lt;session name&gt;</i>-<i>&lt;PID&gt;</i>.log</code>,
        where <code class="nobr"><i>&lt;user home&gt;</i></code> corresponds to the account under which the profiled application is started.
      </p>
      <p>
        The log file location is also printed to stderr:<br/>
        <code class="nobr">[YourKit Java Profiler <i>&lt;version&gt;</i>] Loaded. Log file: <i>&lt;full path to the log file&gt;</i></code>
      </p>
      <p>
        Version 8.0.x and older agents used to print the port to stderr only:<br/>
        <code class="nobr">[YourKit Java Profiler <i>&lt;version&gt;</i>] Profiler agent is listening on port <i>&lt;port number&gt;</i>...</code>
      </p>
    </li>
  </ul>

  <h2 id="web">Web interface: check agent status in web browser</h2>

  <p>
    Since version 2015 build 15060, the profiler agent status can be checked by opening
    the URL <code class="nobr">http://localhost:<i>&lt;agent port&gt;</i></code> for a local profiled application
    or <code class="nobr">http://<i>&lt;remote host&gt;</i>:<i>&lt;agent port&gt;</i></code> for a remote profiled application
    in a web browser.
  </p>
  <p>
    The shown page resembles the content of the <a href="#summary">Summary</a> tab in the profiler UI
    plus provides detail on currently active profiling modes.
  </p>

  <h2 id="connected">In connected mode</h2>

  <p>
    After a connection is established successfully, the profiling session tab opens.
    It contains the toolbar to control profiling and displays application telemetry.
  </p>

  <figure>
    <img alt="" class="img-responsive" src="resources/toolbar.png"/>
  </figure>

  <p>
    1. Capture performance snapshot - save the profiling results to a file, for comprehensive analysis<br/>
    2. Control <a href="#cpu_intro">CPU profiling</a><br/>
    3. Control <a href="#threads">thread telemetry</a><br/>
    4. Control <a href="#memory_telemetry">memory profiling</a>:
        capture <a href="#memory_snapshots">memory snapshot</a>,
        start/stop <a href="#allocations">object allocation recording</a>,
        advance <a href="#generations">object generation</a>
        <br/>
    5. Configure <a href="#triggers">triggers</a><br/>
    6. Force garbage collection<br/>
    7. Control <a href="#monitor_profiling">monitor profiling</a><br/>
    8. Control <a href="#exception_telemetry">exception telemetry</a><br/>
    9. "Pause" - stop/start receiving data from profiled application.<br/>
     "Refresh" - immediately receive profiling data from the profiled application and update the views<br/>
    10. Scale graphs
  </p>
  <p>
    You can close the profiling session tab by selecting <span class="ui_action">File | Close Profiling Session</span>.
  </p>

  <p>
    You can connect to and disconnect from the profiled application as many times as you wish during its run time.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='performance_problems'>4&nbsp;Solving performance problems</h1>

  <h2>What performance problems may arise?</h2>

  <p>
    <ul>
      <li>Application algorithms are usually not optimal, which leads to <a href="#performance_bottlenecks">performance bottlenecks</a>.</li>
      <li>For memory-related issues see below.</li>
    </ul>
  </p>

  <h2>Why memory-related issues can cause performance problems?</h2>

  <p>
    Memory-related issues can affect an application's execution speed and stability:
  </p>
  <ul>
    <li>
      When Java Virtual Machine cannot allocate an object (because it is out
      of memory, and no more memory can be freed by the garbage collector),
      <code class="nobr">OutOfMemoryError</code> is thrown, which can cause an application crash or further unstable operation.
    </li>
    <li>
      An application that uses a lot of memory reduces available physical memory for itself and other programs, and
      thus forces the operating system to swap memory pages to and from the disk more frequently. This leads to serious overall system performance degradation.
    </li>
    <li>
      Java Virtual Machine spends more time to perform garbage collection when more objects exist and more temporary objects are created.
    </li>
  </ul>

  <p>
    Read more about memory-related problems:
  </p>
  <p>
    <ul>
      <li><a href="#high_memory_usage">Application uses more memory than it should</a></li>
      <li><a href="#memory_leaks">Memory leaks</a></li>
      <li><a href="#excessive_gc">Excessive garbage allocation</a>, i.e. application creates a lot of temporary objects</li>
      <li><a href="#out_of_memory">OutOfMemoryError occurs</a></li>
    </ul>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='performance_bottlenecks'>4.1&nbsp;Performance bottlenecks</h1>

  <h2>How to find a performance bottleneck using CPU profiling?</h2>

  <p>
    Let us assume there is a <i>task</i> in your application that you want to profile.
    Please do the following:
  </p>
  <ul>
    <li><a href="#running_with_profiler">Run application with the profiler</a></li>
    <li><a href="#connect">Connect</a> to the application</li>
    <li><a href="#cpu_intro">Start CPU profiling</a> right before the <i>task</i> is started</li>
    <li>Wait until the <i>task</i> finishes or performs long enough</li>
    <li>Capture CPU snapshot</li>
    <li>Open the snapshot and use <a href="#cpu_stat">CPU view</a></li>
  </ul>
  <p>
    <a href="#cpu_profiling">Read more about CPU profiling</a>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='high_memory_usage'>4.2&nbsp;Optimizing memory usage</h1>

  <h2>How to find out why application eats that much memory?</h2>

  <ul>
    <li><a href="#running_with_profiler">Run application with the profiler</a></li>
    <li><a href="#connect">Connect</a> to the application. DO NOT <a href="#allocations">record allocations</a> as they are not needed to solve this task.</li>
    <li>
      <p>
        Capture memory snapshot.
      </p>
      <p>
        To identify the moment when to capture the snapshot, use <a href="#memory_telemetry">Telemetry</a>
        to see when and how the used memory grows.
      </p>
      <p>
        Also, a snapshot can be captured automatically <a href="#snapshot_on_high_memory_usage">on high memory usage</a> and/or <a href="#out_of_memory">on out of memory</a>.
      </p>
    </li>
    <li>
      Open the snapshot and use the <a href="#objects_view">objects view</a>
    </li>
  </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='memory_leaks'>4.3&nbsp;Memory leaks</h1>

  <h2>What is a memory leak?</h2>

  <p>
    <i>Memory leak</i> is an existence of objects that are not needed anymore according to the application logic,
    but still retain memory and cannot be collected because they are referenced from other live objects,
    due to a bug in application itself.
    <br/>
    Obviously, each leaked object is accessible from at least one <a href="#gc_roots">GC root</a> or represents a <a href="#gc_roots">GC root</a>.
    In other words, for each leaked object there is always a path that starts from GC root(s) and contains (ends with) the leaked object.
  </p>

  <h2>How to find memory leaks?</h2>

  <h3>1. Detect memory leak, i.e. understand <i>what</i> objects do exist while they should not.</h3>

  <p>
    If you <strong>do not know yet what objects are leaked</strong>, YourKit Java Profiler can help you find out.
  </p>

  <p>
    You can suspect the presence of memory leaks with the help of
    the <a href="#memory_telemetry">memory telemetry</a>,
    by watching how used memory grows.
    You can use <span class="ui_text">Force Garbage Collection</span> to
    immediately see whether some of the objects that consume the memory can be collected, thus
    decreasing used memory. If after 2-3 explicit garbage collections the used memory remains
    on the same level or decreases insignificantly, this possibly means you have a leak.
    ("Possibly," because it can turn out not to be a leak, but simply high
    memory consumption -- <a href="#high_memory_usage">Learn how to deal with that case</a>)
  </p>

  <p>
    Also consider the <a href="#snapshot_on_high_memory_usage">capture snapshot on high memory usage</a> feature.
    Snapshots captured automatically using this feature may possibly be captured in the state
    when memory usage reaches the specified threshold because of memory leaks.
    Thus, the snapshots will provide information sufficient to discover and fix the leaks.
  </p>

  <p>
    To detect a memory leak, use the following scenario:
    <ul>
      <li><a href="#connect">Connect</a> to profiled application</li>
      <li><a href="#generations">Advance generation number</a> just before executing the task which is suspected to cause leak.</li>
      <li>Let the application perform the task.</li>
      <li>Capture memory snapshot and open it.</li>
      <li>Use the "Generations" view to see objects created during the task execution; leaked objects should be among them.</li>
    </ul>
  </p>

  <p>
    Using the generations feature helps a lot in finding memory leaks,
    but you can also effectively find memory leaks analyzing a snapshot which does not contain object generation information,
    e.g. if you have not advanced generation when appropriate or
    if you have a <a href="#hprof_snapshots">HPROF</a> snapshot.
    In this case use <a href="#objects_view">objects view</a>.
  </p>

  <p>
    Often, potential leaks in particular profiled application are <strong>well known in advance</strong>, i.e. you know a class of objects that have a "tendency" to
    leak while application is being developed, changed, refactored.
    You can easily check for the presence of such objects, with the help of <span class="ui_action">Memory | Instances by Class... (Ctrl+N)</span>.
    In more complex cases, you can use <a href="#language">Set description language</a> to declare sets of potentially leaked objects.
  </p>

  <p>
    Note that even one class can have objects legally and illegally (leaked objects) retained in memory.
    To distinguish between them, you can use <a href="#objects_view_explorer">objects explorer</a> to see outgoing and/or incoming references. For example,
    an object may have a <code class="nobr">String</code> field with the value that can identify this object among other objects of the same type.
  </p>


  <h3>2. Once you have found leaked object(s), it's time to understand why they are retained in memory</h3>


  <p>
    Select the leaked object(s) in a memory view, and use <span class="ui_action">Memory | Paths from GC Roots... (Ctrl+P)</span>.
    See <a href="#paths">Working with paths</a> for details.
  </p>

  <p>Let us look at a simple example of how to use paths.</p>
  <ul>
    <p>
      Assume that we are profiling an Editor application that can open, edit and close text files.
      There is a singleton object that acts as a manager of opened files,
      and the data of each opened file is represented with an instance of class <i>Document</i>.
    </p>

    <p>
      During the profiling session we open several text files, edit them, close them and take a memory snapshot.
    </p>

    <p>
      If everything is correct, there should be no instances of <i>Document</i> that cannot be collected.
      So, first of all, we use <span class="ui_action">Memory | Instances by Class... (Ctrl+N)</span>, to see if there are leaked <i>Document</i>s.
    </p>

    <p>
      Assume we have found such objects - so we do have a leak. There should be paths from GC roots to these objects (or, perhaps, some of them may belong to GC
      roots themselves - this will be indicated in the view).
    </p>

    <p>
      Thus we search for the paths from GC roots to one of the <i>Documents</i> (Ctrl+P), or to all <i>Documents</i> defining
      the set.<br/>
      If all the paths go through the manager singleton, the code responsible for closing files in our editor must have a bug.<br/>
      If none of the paths contains the manager singleton, then the closing operation works correctly, but there are object(s)
      in the path(s) that erroneously hold references to <i>Documents</i> and cause the memory leak.
    </p>
  </ul>

  <p class="hint">
    Browsing paths, use navigation feature of <a href="#ide_integration">IDE integration</a>.
  </p>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='gc_roots'>4.3.1&nbsp;GC roots</h1>

  <p>
    The so-called GC (Garbage Collector) roots are objects special for garbage collector.
    Garbage collector collects those objects that are not GC roots and are not accessible by references from GC roots.
  </p>

  <p>
    There are several kinds of GC roots. One object can belong to more than one kind of root.
    The root kinds are:
    <ul>
      <li>
        <b>Class</b> - class loaded by system class loader. Such classes can never be unloaded.
        They can hold objects via static fields.
        Please note that classes loaded by custom class loaders are not roots, unless
        corresponding instances of <code class="nobr">java.lang.Class</code> happen to be roots of other kind(s).
      </li>
      <li><b>Thread</b> - live thread</li>
      <li><b>Stack Local</b> - local variable or parameter of Java method</li>
      <li><b>JNI Local</b> - local variable or parameter of JNI method</li>
      <li><b>JNI Global</b> - global JNI reference</li>
      <li><b>Monitor Used</b> - objects used as a monitor for synchronization</li>
      <li>
        <b>Held by JVM</b> - objects held from garbage collection by JVM for its purposes.
        Actually the list of such objects depends on JVM implementation.
        Possible known cases are: the system class loader, a few important exception classes which the JVM knows
        about, a few pre-allocated objects for exception handling, and custom class loaders when they are
        in the process of loading classes.
        <b>
          Unfortunately, JVM provides absolutely no additional detail for such objects.
          Thus it is up to the analyst to decide to which case a certain "Held by JVM" belongs.
        </b>
      </li>
    </ul>
  </p>

  <p>
    If an object is a root, it is specially marked in all views showing individual objects.
    For example, the following picture shows a fragment of <a href="#paths">paths</a> view:
  </p>

  <figure>
    <img alt="" src="resources/gc_roots_in_explorer.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='excessive_gc'>4.4&nbsp;Excessive garbage allocation</h1>

  <h2>How to find excessive garbage allocation?</h2>

  <p>
    Purpose: Reduce time that garbage collector spends on collecting temporary objects.
  </p>

  <ul>
    <li><a href="#running_with_profiler">Run application with the profiler</a></li>
    <li><a href="#connect">Connect</a> to the application</li>
    <li><a href="#garbage_collection">Garbage collection telemetry</a> will help you estimate garbage collector load.</li>
  </ul>

  <p>
    If garbage collection takes a significant amount of time,
    it is advised to profile memory allocation to pin-point and optimize the problematic code.
  </p>

  <p>
    Let us assume there is a <i>task</i> in your application that you want to profile.
  </p>

  <ul>
    <li>Start <a href="#allocations">object allocation recording</a> with default settings right before the <i>task</i> is started.</li>
    <li>Wait until the <i>task</i> finishes or performs long enough.</li>
    <li>Capture memory snapshot and stop object allocation recording.</li>
    <li>Open snapshot and use <a href="#garbage_collection">Garbage Collection</a> view.</li>
  </ul>

  <p>
    Optionally, the profiled application can be launched with <a href="#allocations">object allocation recording</a> started
    with the help of corresponding <a href="#startup_options">startup options</a>.
    Memory snapshot with recorded allocation information can be captured automatically on profiled application exit
    and/or <a href="#snapshot_on_high_memory_usage">on high memory usage</a>.
    Read more in the <a href="#startup_options">Startup options</a> section.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='out_of_memory'>4.5&nbsp;Out of memory error (OutOfMemoryError and -XX:+HeapDumpOnOutOfMemoryError)</h1>

  <p>
    A memory snapshot is captured automatically on first OutOfMemoryError,
    if the profiled application runs on Sun Java 6 or newer,
    or on JRockit R28.0.0 or newer.
  </p>

  <p>
    On OutOfMemoryError snapshots are captured via JVM's built-in dumper, which for some reason is disabled by default.
    JVM option -XX:+HeapDumpOnOutOfMemoryError enables it.
  </p>
  <p>
    However, you do not need to specify this option when profiling applications because
    the profiler agent programmatically enables the dumper upon profiled application startup
    or when the agent is attached to a running application.
  </p>
  <p>
    Enabling the dumper adds absolutely no overhead.
    Technically, enabling is simply setting the state of a boolean flag. When the first OutOfMemoryError occurs, the JVM
    dumps the heap to file if the flag is "true".
  </p>
  <p>
    Anyway, if for some reason you want not to enable the dumper,
    specify <a href="#startup_options">startup option</a> <code class="nobr">disableoomedumper</code>.
  </p>

  <p>
    To check the status, <a href="#connect">connect</a> to the profiled application
    and hover over corresponding button as shown on the picture below:
  </p>

  <figure>
    <img alt="" src="resources/triggers_control_panel.png"/>
  </figure>
  <figure>
    <img alt="" src="resources/oome_status.png"/>
  </figure>
  <p>
    The profiler shows the following notification when a snapshot is captured on OutOfMemoryError.
  </p>

  <figure>
    <img alt="" src="resources/snapshot_event1.png"/>
  </figure>

  <p>
    Please note that this approach has several benefits over the <a href="#snapshot_on_high_memory_usage">capturing snapshot on high memory usage</a>
    feature, because it uses the JVM's internal lightweight dumping algorithm. This algorithm is specially designed to work
    in low memory conditions, where the JVM general purpose profiling interface JVMTI used by profilers may fail
    due to low resources.
  </p>

  <p>
    See also <a href="#hprof_snapshots">Support of HPROF format snapshots</a>.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='cpu_profiling'>5&nbsp;CPU profiling</h1>

  <p>
    Get CPU usage overview with the help of the <a href="#cpu_telemetry">CPU telemetry</a>.
  </p>

  <p>
    For comprehensive analysis, record CPU information with the help of <a href="#cpu_intro">sampling or tracing</a>.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='cpu_telemetry'>5.1&nbsp;CPU usage telemetry</h1>

  <p>
    <span class="ui_text">CPU</span> tab shows live CPU consumption statistics under
    <span class="ui_text">CPU usage telemetry</span>.
  </p>
  <p>
    It is available when you are <a href="#connect">connected</a> to the profiled application,
    as well as in snapshots.
  </p>

  
  <p>
    The telemetry information is remembered in a circular buffer in the profiler agent memory.
    This allows you to connect to a profiled application on demand and discover how the application behaved in the past.
  </p>
  <p>
    The buffer capacity is 1 hour by default,
    and can be changed with the startup option <a href="#telemetrylimit">telemetrylimit</a>.
  </p>

  <figure>
    <img alt="" src="resources/cpu_tele_in_snapshot.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='cpu_intro'>5.2&nbsp;Start CPU profiling. Sampling, tracing, call counting.</h1>

  <p>
    When the profiler is <a href="#connect">connected</a> to the profiled application,
    the toolbar contains the following CPU profiling controls:
  </p>

  <figure>
    <img alt="" src="resources/cpu_toolbar.gif"/>
  </figure>

  <ul>
    <li>Start/Stop CPU profiling (1)</li>
    <li>Clear CPU profiling results and continue profiling (2)</li>
  </ul>

  <br/>

  <h2>Start CPU profiling</h2>

  <p>
    To begin obtaining profiling results, start CPU measuring when your application requires it.
  </p>

  <ul>
    <li>choose the profiling mode from sampling, tracing and call counting (see detail below)</li>
    <li>click the button to start profiling</li>
  </ul>

  <figure>
    <img alt="" src="resources/cpu_start.png"/>
  </figure>

  <ul>
    <li>
      <h3>Sampling</h3>

      <p>
        When sampling is used, the profiler periodically queries stacks of running threads to estimate
        the slowest parts of the code.
        No method invocation counts are available, only CPU time.
      </p>

      <p>
        Sampling is typically the best option when your goal is to locate and discover
        performance bottlenecks. With sampling, the profiler adds virtually no
        overhead to the profiled application.
      </p>

      <p>
        However, the probes for the <a href="#cpu_high_level">high-level statistics</a>,
        if enabled, may impose additional overhead.
      </p>

      <p>
        You can configure some CPU sampling aspects with
        <a href="#sampling_settings">CPU sampling settings</a>.
      </p>
    </li>
    <li>
      <h3>Tracing</h3>
      <p>
        When tracing is used, the profiler instruments the bytecode of the profiled application
        for recording thread CPU time spent inside each profiled method.
        Both times and invocation counts are available.
      </p>

      <p>
        Although tracing provides more information, it has its drawbacks.
        First, it may noticeably slow down the profiled application, because the profiler
        executes special code on each enter to and exit from the methods being profiled.
        The greater the number of method invocations in the profiled application, the lower its speed when
        tracing is turned on.
      </p>
      <p>
        The second drawback is that, since this mode affects the execution speed of the profiled application,
        the CPU times recorded in this mode may be less adequate than times recorded with sampling.
        Please use this mode only if you really need method invocation counts.
      </p>
      <p>
        To control profiling overhead and accuracy of the results
        use <a href="#tracing_settings">CPU tracing settings</a>.
      </p>
      <p>
        Also, the probes for the <a href="#cpu_high_level">high-level statistics</a>,
        if enabled, may impose additional overhead.
      </p>
    </li>
    <li>
      <h3>Call counting</h3>

      <p>
        Call counting is the most lightweight CPU profiling mode.
      </p>

      <p>
        It's a simple tool for identifying potential performance problems caused
        by suboptimal algorithms.
        The approach is based on assumption that method(s) with a big number of invocations
        may indicate a performance problem.
      </p>

      <p>
        Call counting is specially designed to have minimal possible, almost zero overhead:
      </p>
      <ul>
        <li>
          It provides a plain method list with method invocation counts.
          Unlike other CPU profiling modes it does not provide stack traces nor method times.
        </li>
        <li>
          Method invocations from different threads are summed and cannot be distinguished.
        </li>
        <li>
          Counts are not guaranteed to be exact.
          To ensure minimal overhead invocation counts are updated without taking any locks or
          using test-and-set style atomic operations.
          If the same method is simultaneously called in different threads running
          in parallel on different CPU cores, some of its invocations may be missed by a non-atomic counter.
          Fortunately, the probability of such events is low,
          and missed invocations, if any, will normally constitute only a small fraction of all invocations.
        </li>
        <li>
          The probes in Auto <a href="#register_probes">activity mode</a> are not activated
          in call counting, thus <a href="#cpu_high_level">high-level statistics</a> is not collected.
        </li>
      </ul>

      <p>
        Use call counting to initially detect possible problems:
        thanks to its low overhead you may do this even in production.
      </p>
      <p>
        Further investigation may involve using CPU tracing or sampling
        to get comprehensive profiling results including times and stack traces (call tree).
      </p>
    </li>
  </ul>

  <p>
    Please note that CPU tracing and call counting are based on bytecode instrumentation.
    If the startup options <code class="nobr">disabletracing</code> or <code class="nobr">disableall</code> are specified,
    it will be disabled, making CPU sampling the only available mode.
  </p>

  <h2>Live results</h2>

  <p>
    When CPU profiling is started, the results are immediately available
    in "Call tree" (with threads merged) and "Method list" tabs.
  </p>

  <p>
    In case of CPU tracing, both method times and invocation counts are shown.
    In case of CPU sampling, only times are shown.
  </p>

  <figure>
    <img alt="" src="resources/cpu_live_tree_and_list.png"/>
  </figure>

  <p class="hint">
    The live view provides only basic information.
    To perform comprehensive analysis, capture performance snapshot,
    open it and use the full featured <a href="#cpu_stat">CPU view</a>.
  </p>

  <h2>Finish measuring and get the results</h2>

  <p>
    When the task you intended to profile has finished (or has performed for a sufficient amount of time),
    capture a CPU snapshot with all the recorded information.
  </p>

  <figure>
    <img alt="" src="resources/cpu_capture.png"/>
  </figure>

  <p>
    When this is done from the profiler UI, you can open the results for immediate analysis.
  </p>

  <p>
    Further topics in this section describe the profiler's UI for analyzing CPU profiling results.
  </p>

  <h2>Notes</h2>

  <ul>
    <li>
      You can start and stop CPU profiling during the execution of your application as many times as you want.
      When CPU profiling is not running, the profiler adds no performance overhead to application being profiled.
    </li>
    <li>
      In some cases, it also may be useful to launch the application with CPU profiling already started and/or
      automatically capture CPU snapshot on exit of the profiled application
      (see <a href="#startup_options">Startup options</a>).
    </li>
    <li>
      CPU profiling can be performed programmatically with the help of the <a href="#api">Profiler API</a>.
    </li>
  </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='sampling_settings'>5.3&nbsp;CPU sampling settings</h1>

  <p>
    CPU sampling settings allow to customize some aspects of <a href="#cpu_intro">CPU sampling</a>.
  </p>
  <p class="hint">
    CPU tracing settings are specified separately, as described <a href="#tracing_settings">here</a>.
  </p>

  <h2>When the settings are applied</h2>

  <p>
    The settings are applied each time you start CPU sampling.
    This means you can change the settings without restarting the profiled application.
  </p>

  <h2>Configuring the settings</h2>

  <p>
    To configure CPU sampling settings
    use <span class="ui_action">Settings | CPU Sampling...</span> in the main menu.
  </p>

  <p>
    The settings are also accessible via a link in the CPU profiling toolbar popup:
  </p>

  <figure>
    <img alt="" src="resources/sampling_settings_link_in_popup.png"/>
  </figure>

  <p>
    The following dialog appears:
  </p>
  <figure>
    <img alt="" src="resources/sampling_settings_dialog.png"/>
  </figure>

  <p>
    Configurable properties:
  </p>
  <ul>
    <li>
      <h3>Time measurement</h3>
      <p>
        Specify whether <a href="#times">CPU or wall time</a> will be measured for profiled methods.
      </p>
      <p>
        There can be any number of lines in the this format:
      </p>
      <p>
        <code class="nobr">walltime=<i>&lt;fully qualified class name&gt;</i> : <i>&lt;method name&gt;</i> ( <i>&lt;comma-separated parameter types&gt;</i> )</code>
        <br/>or
        <br/>
        <code class="nobr">walltime=<i>&lt;fully qualified class name&gt;</i></code>
      </p>
      <p>
        Matching methods will be measured with wall time, all other methods - with CPU time.
      </p>
      <p>
        If there are no lines with <code class="nobr">walltime</code> specified, all methods will be measured with CPU time.
      </p>
      <p>
        Wildcards ('*') are accepted.
        E.g. the following specifies all methods of class com.Foo.Bar, which names start with 'print':
      </p>
      <p>
        <code class="nobr">walltime=com.Foo.Bar : print*(*)</code>
      </p>

      <p>
        The default configuration for CPU sampling is to measure wall time for I/O methods
        and CPU time for all other methods.
      </p>

      <p>
        "Use Preconfigured Settings..." allows you to choose one of recommended presets.
      </p>
    </li>
    <li>
      <h3>Sampling period</h3>
      <p>
        Specify how often samples are taken with <code class="nobr">sampling_period_ms=<i>&lt;time in milliseconds&gt;</i></code>.
        By default samples are taken each 20 milliseconds (<code class="nobr">sampling_period_ms=20</code>).
      </p>
    </li>
  </ul>

  <h2>Configuration file</h2>

  <p>
    The settings are stored in the file
  </p>
  <p>
    <code class="nobr"><i>&lt;user home&gt;</i>/.yjp/sampling.txt</code>
  </p>

  <p>
    where <i>user home</i> corresponds to the account under which a profiled application is launched.
  </p>

  <p>
    This file is automatically updated in your user home directory when you apply changes in the UI (see above).
  </p>

  <p>
    You can edit this file manually,
    but note that it may be fully overwritten with "Use Predefined Settings..." in UI.
  </p>

  <p>
    The settings file is read and applied when CPU sampling is started with:
  </p>
  <ul>
    <li>
      <a href="#api">API</a> method <code class="nobr">Controller.startCPUSampling(null)</code>
    </li>
    <li>
      <a href="#triggers">trigger</a> action <code class="nobr">StartCPUSampling</code>
    </li>
    <li>
      <a href="#command_line_tool">the command line tool</a>
    </li>
  </ul>

  <p>
    You can specify a custom settings file for a particular application
    by using the startup option <a href="#sampling_settings_path">sampling_settings_path</a>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='tracing_settings'>5.4&nbsp;CPU tracing settings</h1>

  <p>
    CPU tracing settings allow to customize some aspects of <a href="#cpu_intro">CPU tracing</a>.
  </p>
  <p class="hint">
    CPU sampling settings are specified separately, as described <a href="#sampling_settings">here</a>.
  </p>

  <h2>When the settings are applied</h2>

  <p>
    The settings are applied each time you start CPU tracing.
    This means you can change the settings without restarting the profiled application.
  </p>

  <h2>Configuring the settings</h2>

  <p>
    To configure CPU tracing settings
    use <span class="ui_action">Settings | CPU Tracing...</span> in the main menu.
  </p>

  <p>
    The settings are also accessible via a link in the CPU profiling toolbar popup:
  </p>

  <figure>
    <img alt="" src="resources/tracing_settings_link_in_popup.png"/>
  </figure>

  <p>
    The following dialog appears:
  </p>
  <figure>
    <img alt="" src="resources/tracing_settings_dialog.png"/>
  </figure>

  <p>
    Configurable properties:
  </p>
  <ul>
    <li>
      <h3>Time measurement</h3>
      <p>
        Specify whether <a href="#times">CPU or wall time</a> will be measured for profiled methods.
      </p>
      <p>
        There can be any number of lines in the this format:
      </p>
      <p>
        <code class="nobr">walltime=<i>&lt;fully qualified class name&gt;</i> : <i>&lt;method name&gt;</i> ( <i>&lt;comma-separated parameter types&gt;</i> )</code>
        <br/>or
        <br/>
        <code class="nobr">walltime=<i>&lt;fully qualified class name&gt;</i></code>
      </p>
      <p>
        Matching methods will be measured with wall time, all other methods - with CPU time.
      </p>
      <p>
        If there are no lines with <code class="nobr">walltime</code> specified, all methods will be measured with CPU time.
      </p>
      <p>
        Wildcards ('*') are accepted.
        E.g. the following specifies all methods of class com.Foo.Bar, which names start with 'print':
      </p>
      <p>
        <code class="nobr">walltime=com.Foo.Bar : print*(*)</code>
      </p>

      <p>
        The default configuration for CPU tracing is to measure wall time for all methods,
        because the wall time timers are faster and more accurate than CPU time timers.
        This reduces CPU tracing overhead and increases accuracy of the results.
      </p>

      <p>
        "Use Preconfigured Settings..." allows you to choose one of recommended presets.
      </p>
    </li>
    <li>
      <h3>Adaptive tracing mode</h3>
      <p>
        Adaptive tracing mode automatically reduces profiling overhead
        by skipping short running methods with big number of invocations.
        Such methods usually cause the most significant profiling overhead,
        and their exclusion results in both faster tracing and more realistic results.
        The decision to exclude particular method is made basing on the statistics
        collected during the current tracing session.
      </p>
      <p>
        Excluding a method means that there will be no exact results for it (time, invocation count),
        but for its callers only. Due to reduced overhead, its caller method time will be more adequate.
      </p>
      <p>
        The benefit of adaptive tracing is that it does not require human interaction
        and works with any application,
        eliminating the need to explicitly specify filters for particular application if
        default filters do not fit well.
        However, please note that the adaptive tracing needs some time to warm up,
        i.e. to collect statistics on which methods deserve to be excluded.
      </p>
      <p>
        To enable adaptive tracing specify <code class="nobr">adaptive=true</code> (default).
      </p>
      <p>
        To disable adaptive tracing specify <code class="nobr">adaptive=false</code>.
      </p>
      <p>
        Methods excluded by adaptive tracing are specially presented in UI:
      </p>
      <ul>
        <li>
          the methods are indicated with the no-entry sign
        </li>
        <li>
          because the actual time and invocation count for the methods is
          most likely bigger than the amount measured by the moment when the methods have been excluded from tracing,
          the time and invocation count values are prepended with the greater-or-equal sign,
          the average and own time values - with the approximately-equal sign
        </li>
      </ul>
      <figure>
        <img alt="" src="resources/adaptive_tracing_ui.png"/>
      </figure>
    </li>
  </ul>

  <h2>The configuration file</h2>

  <p>
    The settings are stored in the file
  </p>
  <p>
    <code class="nobr"><i>&lt;user home&gt;</i>/.yjp/tracing.txt</code>
  </p>

  <p>
    where <i>user home</i> corresponds to the account under which a profiled application is launched.
  </p>

  <p>
    This file is automatically updated in your user home directory when you apply changes in the UI (see above).
    You can also edit it manually.
  </p>

  <p>
    The settings file is read and applied when CPU tracing is started with:
  </p>
  <ul>
    <li>
      <a href="#api">API</a> method <code class="nobr">Controller.startCPUTracing(null)</code>
    </li>
    <li>
      <a href="#triggers">trigger</a> action <code class="nobr">StartCPUTracing</code>
    </li>
    <li>
      <a href="#command_line_tool">the command line tool</a>
    </li>
  </ul>

  <p>
    You can specify a custom settings file for a particular application
    by using the startup option <a href="#tracing_settings_path">tracing_settings_path</a>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='cpu_stat'>5.5&nbsp;CPU view</h1>

  <p>
    CPU view (<span class="ui_action">View | CPU</span>) shows CPU consumption details.
  </p>
  <p>
    The view consists of the following sections:
  </p>

  <h2>Call tree</h2>
  <p>
    Shows a top-down call tree for each thread ("by thread")
  </p>
  <figure>
    <img alt="" src="resources/cpu_call_tree_by_thread.png"/>
  </figure>
  <p>
    or with calls from all threads merged ("all threads together").
  </p>
  <figure>
    <img alt="" src="resources/cpu_call_tree_all_threads.png"/>
  </figure>
  <p>
    The tree is shown based on current <a href="#filters">filters</a>.
  </p>

  <h2>Hot spots</h2>
  <p>
    Shows methods that consumed the most <a href="#times">time</a>.
  </p>
  <figure>
    <img alt="" src="resources/cpu_hot_spots.png"/>
  </figure>
  <p>
    Methods are shown based on current <a href="#filters">filters</a>:
    <ul>
      <li>
        non-filtered methods (typically, methods from the source code of profiled application)
      </li>
      <li>
        filtered methods (typically, methods from core classes and used libraries) that were
        directly called from non-filtered methods or are at the top of thread stack trace (<code class="nobr">Thread.run()</code>).
      </li>
    </ul>
  </p>

  <h2>Method list</h2>
  <p>
    Methods are shown based on current <a href="#filters">filters</a>:
    <ul>
      <li>
        non-filtered methods (typically, methods from the source code of profiled application)
      </li>
      <li>
        filtered methods (typically, methods from core classes and used libraries) that were
        directly called from non-filtered methods or are at the top of thread stack trace (<code class="nobr">Thread.run()</code>).
      </li>
    </ul>
  </p>
  <p>
    For each method, the list shows its <a href="#times">time</a>, its own <a href="#times">time</a> and, with <a href="#cpu_intro">CPU tracing</a>, its invocation count.
  </p>
  <p>
    You can narrow down the list by typing a method name inside the text field.
  </p>
  <figure>
    <img alt="" src="resources/cpu_method_list.png"/>
  </figure>

  <p>
    Method invocation counts are available with <a href="#cpu_intro">CPU tracing</a>.
    Invocation counts are not cumulative.
  </p>

  <p>
    You can apply the following actions to the selected method (available from the popup menu as well):
  </p>
  <ul>
      <li>
        <span class="ui_action">CPU | Method Merged Callees (Ctrl+M)</span> - <a href="#cpu_method_merged_callees">shows the method's merged callees</a>.
      </li>
      <li>
        <span class="ui_action">CPU | Method Back Traces (Ctrl+Shift+M)</span> - <a href="#cpu_method_back_traces">shows the method's back traces</a>.
      </li>
      <li>
        <span class="ui_action">Tools | Open in IDE (F7)</span> - opens method declaration
        in IDE editor (see <a href="#ide_integration">IDE integration</a>).
      </li>
    </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='cpu_callees_list_view'>5.6&nbsp;Callees list view</h1>


  <p>
    "Callees list" view shows which methods were called from certain methods.
    It is available as a slave view in call tree, hot spots and method list:
  </p>

  <figure>
    <img alt="" src="resources/cpu_callees_list.png"/>
  </figure>

  <p>
    Callees list for "Call tree" shows methods invoked inside a selected subtree.
    When you view "Call tree (by thread)", callees list will show methods invoked in the subtree
    in particular thread only. To see all methods invoked in a thread, select the thread node.
  </p>

  <p>
    Callees list for "Hot spots" and "Method list" shows methods invoked inside a selected method.
  </p>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='cpu_method_merged_callees'>5.7&nbsp;Method merged callees view</h1>

  <p>
    This view shows merged callees for a particular method, i.e. all call traces started from this method.
    This gives a summary of method execution and its "overall" behavior.
  </p>
  <figure>
    <img alt="" src="resources/cpu_method_merged_callees.png"/>
  </figure>
  <ul>
    <li>
      <span class="ui_action">CPU | Method Merged Callees (Ctrl+M)</span> opens this view for the selected method.
    </li>
  </ul>
  <br/>
  <p>
    If method invocation counts were <a href="#cpu_intro">recorded</a>, they are shown in call trees as well.
    Invocation counts are not cumulative.
  </p>

  <p>
    You can apply the following actions to the selected method (available from the popup menu as well):
  </p>
  <ul>
      <li>
        <span class="ui_action">CPU | Method Merged Callees (Ctrl+M)</span> - shows the method's merged callees.
      </li>
      <li>
        <span class="ui_action">CPU | Method Back Traces (Ctrl+Shift+M)</span> - <a href="#cpu_method_back_traces">shows the method's back traces</a>.
      </li>
      <li>
        <span class="ui_action">Tools | Open in IDE (F7)</span> - opens method declaration
        in IDE editor (see <a href="#ide_integration">IDE integration</a>).
      </li>
    </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='cpu_method_back_traces'>5.8&nbsp;Method back traces view</h1>

  <p>
    This view shows where a particular method was called.
  </p>
  <figure>
    <img alt="" src="resources/cpu_method_back_traces.png"/>
  </figure>
  <ul>
    <li>
      <span class="ui_action">CPU | Method Back Traces (Ctrl+Shift+M)</span> opens this view for the selected method.
    </li>
  </ul>
  <br/>
  <p>
    If method invocation counts were <a href="#cpu_intro">recorded</a>, they are shown in call trees as well.
    Invocation counts are not cumulative.
  </p>

  <p>
    You can apply the following actions to the selected method (also available from the popup menu):
  </p>
    <ul>
      <li>
        <span class="ui_action">CPU | Method Merged Callees (Ctrl+M)</span> - <a href="#cpu_method_merged_callees">shows the method's merged callees</a>.
      </li>
      <li>
        <span class="ui_action">CPU | Method Back Traces (Ctrl+Shift+M)</span> - shows the method's back traces.
      </li>
      <li>
        <span class="ui_action">Tools | Open in IDE (F7)</span> - opens method declaration
        in IDE editor (see <a href="#ide_integration">IDE integration</a>).
      </li>
    </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='cpu_high_level'>5.9&nbsp;Java EE high-level statistics</h1>

  <p>You can profile applications in high-level terms like SQL statements and URLs.</p>

  <p>
    High-level statistics depends on corresponding <a href="#builtin_probes">built-in probes</a>
    whose <a href="#register_probes">activity mode</a> is Auto by default,
    which means they are active only while <a href="#cpu_intro">CPU profiling is running</a>,
    in either CPU sampling or CPU tracing mode.
    If neither CPU tracing nor CPU sampling was running,
    high-level profiling results are not available.
  </p>

  <p>
    This statistics is not available in live views.
    To access it, capture and open a snapshot, then switch to the "Java EE statistics" view:
  </p>

  <figure>
    <img alt="" src="resources/j2ee_statistics.png"/>
  </figure>

  <p>
    The view consists of the following sections:
  </p>

  <ul>
    <li>
      <h3>Database</h3>
      <p>
        Shows database requests and their invocation method back traces.
      </p>
      <p>
        You can see the requests as a plain list or group them by type.
      </p>
      <p>
        Supported databases:
      </p>
      <ul>
        <li>JDBC (SQL)</li>
        <li>MongoDB (Java driver version 3.0 and newer are supported)</li>
        <li>Cassandra</li>
        <li>HBase</li>
        <li>Java persistence (JPA): Hibernate, EclipseLink, OpenJPA, DataNucleus</li>
      </ul>
    </li>
    <li>
      <h3>JSPs and Servlets</h3>
      <p>
        Shows list a of URLs that correspond to JSP and Servlet calls, and merged
        callees for all methods invoked with these URLs
      </p>
    </li>
    <li>
      <h3>JNDI</h3>
      <p>
        Shows list of URLs that correspond to JNDI calls, and back traces
        for all methods invoked with these URLs
      </p>
    </li>
  </ul>

  <p>
    For each Java EE call CPU time and invocation count are reported.
  </p>

  <p>
    Java EE profiling requires bytecode instrumentation and adds some additional overhead to the profiled application.
    For detailed information, see <a href="#overhead">Profiling overhead: how to reduce or avoid</a>
  </p>

  <p>
    Lines can be copied to clipboard by using <span class="ui_action">File | Copy to Clipboard (Ctrl + C)</span>:
  </p>

  <figure>
    <img alt="" src="resources/j2ee_copy.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='cpu_what_if'>5.10&nbsp;What-if: an ability to ignore particular methods or focus on particular methods only</h1>

  <p>
    "What-if" feature helps you to analyze <a href="#cpu_intro">CPU profiling results</a>
    by ignoring particular methods or focusing on particular methods only.
  </p>

  <p class="hint">
    This feature requires capturing a snapshot. It is not available in live views.
  </p>

  <p>
    In views with <a href="#cpu_stat">CPU profiling results</a> (call tree, method list, hot spots),
    use menu actions (available as popup menu and in main menu):
  </p>

  <ul>
    <li>
      <span class="ui_action">CPU | Exclude Method</span> -
      opens a new tab with CPU results modified such that
      all calls to the selected method are ignored.
    </li>
    <li>
      <span class="ui_action">CPU | Exclude Subtree</span> -
      opens a new tab with CPU results modified such that
      the selected method call is ignored.
    </li>
    <li>
      <span class="ui_action">CPU | Focus On Method</span> -
      opens a new tab with CPU results modified such that
      all methods except for the selected method are ignored.
      Methods, which called the selected method are shown too, but their
      times only include time spent in the selected method.
    </li>
    <li>
      <span class="ui_action">CPU | Focus On Subtree</span> -
      opens a new tab with CPU results modified such that
      they include only selected method call.
      Parent method times only include time spent in the selected subtree.
    </li>
  </ul>

  <figure>
    <img alt="" src="resources/cpu_what_if_menu.png"/>
  </figure>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='cpu_compare_snapshots'>5.11&nbsp;Comparing performance snapshots</h1>

  <p>
    You can compare two arbitrary snapshots that contain recorded CPU information,
    obtained with <a href="#cpu_intro">CPU sampling or CPU tracing</a>.
  </p>

  <p>
    To compare snapshots, do the following:
  </p>

  <ul>
    <li>Open the snapshots you want to compare.</li>
    <li>Select one of them.</li>
    <li>
      Use <span class="ui_action">File | Compare Snapshot with...</span> (the action is also available from the popup menu)
      and select a snapshot to compare with.
    </li>
  </ul>

  <p>
    A new tab with the comparison opens. It contains "Call tree" and "Method list" views
    displaying the differences in method execution times and invocation counts.
  </p>
  <p>
    The invocation count columns are shown only if both compared snapshots contain CPU tracing results.
  </p>
  <p>
    If at least one of the compared snapshots contains CPU sampling results, only time differences will be shown.
  </p>
  <figure>
    <img alt="" src="resources/cpu_comparison.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='cpu_usage_estimation'>5.12&nbsp;CPU usage estimation</h1>

  <p>
    You can estimate CPU usage in given time range, basing on available stack trace telemetry.
  </p>

  <h2>How to invoke</h2>

  <ul>
    <li>
      Select arbitrary time range in telemetry graph:
      <figure>
        <img alt="" src="resources/cpu_usage_estimation_in_graph.png"/>
      </figure>
    </li>
    <li>
      Select event(s) in <a href="#probes_ui">probes UI</a>, and use popup menu action:
      <figure>
        <img alt="" src="resources/cpu_usage_estimation_in_probes.png"/>
      </figure>
    </li>
  </ul>

  <h2>Comparison with CPU sampling</h2>

  <p>
    This feature is similar to <a href="#cpu_intro">CPU sampling</a>,
    as it also uses sampling approach, but there are sufficient differences:
  </p>

  <table class="tbl-with-border tbl-with-strong-thead">
    <thead>
      <tr>
        <td>Comparison criteria</td>
        <td>CPU usage estimation</td>
        <td>"Real" CPU sampling</td>
        <td>Comments</td>
      </tr>
    </thead>

    <tbody>
    <tr>
      <td>Results availability</td>
      <td>
         Always, as long as <a href="#threads">stack telemetry</a> is enabled
      </td>
      <td>
        Should be explicitly started
      </td>
      <td>
        CPU usage estimation is ideal for analysis of anomalies such as
        CPU spikes, especially those which has already happened,
        so you do not need to turn CPU sampling or tracing on and try reproduce the spike.
      </td>
    </tr>

    <tr>
      <td>Accuracy</td>
      <td>
        Lower
      </td>
      <td>
        Higher
      </td>
      <td>
        <p>
          CPU usage estimation is based on thread telemetry,
          whose frequency is normally as low as 1 sample per second
          (can be changed using the startup option
          <a href="#telemetryperiod">telemetryperiod</a>).
        </p>
        <p>
          CPU usage estimation can adequately measure events not shorter than
          the thread telemetry period.
        </p>
        <p>
          So, it suits for measuring events or method calls that last at least several seconds.
          If the measured event or method call is long enough,
          the estimation will do its job -
          locate problematic code responsible for the CPU spike.
        </p>
        <p>
          For measuring shorter events or methods, use normal CPU profiling,
          or decrease the telemetry period using the startup option
          <a href="#telemetryperiod">telemetryperiod</a>.
        </p>
      </td>
    </tr>

    <tr>
      <td>Granularity</td>
      <td>
        Results are available for each particular event, as well as for entire time range
      </td>
      <td>
        Results are aggregated for entire period of CPU profiling
      </td>
      <td>
        <p>
          CPU usage estimation enables analysis of particular events or time ranges
          within single snapshot.
        </p>
        <p>
          CPU profiling results are aggregated since CPU profiling has been started.
          It is not possible to "extract" CPU profiling results for a smaller time range within one snapshot.
          However, you can <a href="#cpu_what_if">choose which method calls to analyze</a>.
        </p>
      </td>
    </tr>
  </tbody>
</table>


<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='threads'>6&nbsp;Threads</h1>

  <p>
    When you are <a href="#connect">connected</a> to the profiled application, use the "Threads" tab
    to track the live threads.
  </p>

  <figure>
    <img alt="" src="resources/telemetry_threads.png"/>
  </figure>

  
  <p>
    The telemetry information is remembered in a circular buffer in the profiler agent memory.
    This allows you to connect to a profiled application on demand and discover how the application behaved in the past.
  </p>
  <p>
    The buffer capacity is 1 hour by default,
    and can be changed with the startup option <a href="#telemetrylimit">telemetrylimit</a>.
  </p>

  <p class="hint">
    Please also consider <a href="#deadlocks">the automatic deadlock detector</a>
  </p>

  <h2>Disabling/enabling stack telemetry</h2>

  <p>
    The thread stack and state telemetry information can be very useful because it allows you to connect
    to the profiled application on demand and discover how the application behaved in
    the past. In most cases, there is no significant overhead of collecting this
    information, and thus you do not need to disable it.
  </p>

  <p>
    However, it makes sense to disable it in production Java EE servers
    in order to ensure minimum profiling overhead.
  </p>


  <p>
    The telemetry is enabled by default, unless
    "disablestacktelemetry" <a href="#startup_options">startup option</a>
    was specified.
  </p>

  <p>
    When you are <a href="#connect">connected</a> to the profiled application, use
    corresponding toolbar button to enable/disable the telemetry:
  </p>

  <figure>
    <img alt="" src="resources/threads_disable.png"/>
  </figure>

  <h2>Threads in HPROF snapshots</h2>

  <p>
    For <a href="#hprof_snapshots">HPROF snapshot</a>,
    "Threads" tab shows thread stacks at the moment of the snapshot capture (if available).
  </p>

  <figure>
    <img alt="" src="resources/threads_HPROF.png"/>
  </figure>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='deadlocks'>7&nbsp;Deadlock detector</h1>

  <p>
    If a Java-level deadlock happens in the profiled application, it will be automatically detected.
  </p>

  <p>
    When you are <a href="#connect">connected</a> to the profiled application,
    switch to the "Deadlocks" tab.
  </p>

  <figure>
    <img alt="" src="resources/deadlock_not_detected.png"/>
  </figure>

  <p>
    If the deadlock is found, a notification will be shown.
    Find the deadlock detail in the "Deadlocks" tab.
  </p>

  <figure>
    <img alt="" src="resources/deadlock_detected.png"/>
  </figure>

  <h2 id="potential">Potential deadlocks</h2>
  <p>
    The profile can detect deadlocks
    which are not otherwise reported by standard Java mechanism which detects only Java-level deadlocks,
    but does not detect deadlocks of Java threads caused by JVM internal locks (e.g. class loader)
    or native methods which explicitly use low-level synchronization primitives.
  </p>
  <p>
    An heuristics detects threads whose stack does not changed for some period of time,
    which is a sign of potential deadlock or hung thread.
  </p>
  <p>
    Well-known cases when thread can legally stay in same state for a long time are excluded.
    In particular, it can be threads which are waiting for incoming connection in ServerSocket.accept(),
    some JVM internal threads etc.
  </p>
  <p>
    Important:
    the potential deadlock detection depends on <a href="#threads">thread stack telemetry</a>.
    If thread state telemetry is disabled, the detection is not possible.
  </p>
  <p>
    Note: potential deadlocks are not necessarily actual deadlocks.
    It is possible that the reported threads are performing the same operation for a long time,
    and will eventually finish.
    Use "Refresh" button to check if detected threads are still considered frozen.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='memory_profiling'>8&nbsp;Memory profiling</h1>
&nbsp;<br><h1 id='memory_telemetry'>8.1&nbsp;Memory telemetry</h1>

  <p>
    After you are <a href="#connect">connected</a> to the profiled application,
    find the <span class="ui_text">Memory</span> tab on the session panel.
  </p>

  <h2>Memory profiling controls in the toolbar</h2>

  <figure>
    <img alt="" src="resources/memory_toolbar.png"/>
  </figure>

  <p>
    <ul>
      <li>Capture <a href="#memory_snapshots">memory snapshot</a> (1)</li>
      <li>Start/stop <a href="#allocations">object allocation recording</a> (2)</li>
      <li>Advance <a href="#generations">object generation number</a> (3)</li>
      <li>Edit <a href="#triggers">triggers</a> (4)</li>
    </ul>
  </p>

  <h2>Memory usage graphs</h2>

  <p>
    <span class="ui_text">Memory</span> tab's section
    <span class="ui_text">Memory &amp; GC Telemetry</span> shows the following graphs:
    <ul>
      <li>
        <span class="ui_text">Heap Memory</span> shows Java heap statistics.
        Java uses the heap as the storage for Java objects.
        You can see individual pools or all pools together.
      </li>
      <li>
        <span class="ui_text">Non-Heap Memory</span> shows the non-heap memory statistics.
        Java uses the non-heap memory to store loaded classes and other meta-data.
        You can see individual pools or all pools together.
      </li>
      <li>
        <span class="ui_text">Classes</span> shows how the number of loaded classes changed in time,
        and the total number of unloaded classes.
      </li>
      <li>
        <span class="ui_text">Garbage Collection</span> and
        <span class="ui_text">Time Spent in GC</span>
        show the garbage collection statistics (<a href="#garbage_collection">read more</a>)
      </li>
      <li>
        <span class="ui_text">Object Allocation Recording</span>
        graph shows the number of objects created per second.
        Please note that this graph is populated only when
        <a href="#allocations">object allocation recording</a> is running.
        To get the results with minimum overhead please use the object counting mode.
      </li>
    </ul>
  </p>
  <br/>
  <figure>
    <img alt="" src="resources/memory_telemetry.png"/>
  </figure>

  
  <p>
    The telemetry information is remembered in a circular buffer in the profiler agent memory.
    This allows you to connect to a profiled application on demand and discover how the application behaved in the past.
  </p>
  <p>
    The buffer capacity is 1 hour by default,
    and can be changed with the startup option <a href="#telemetrylimit">telemetrylimit</a>.
  </p>

  <h2>Class instance count telemetry</h2>

  <p>
    <span class="ui_text">Classes</span> view shows object counts by class.
    It is located in the <span class="ui_text">Memory &amp; GC Telemetry</span> section of
    the <span class="ui_text">Memory</span> tab.
  </p>

  <p>
    This view is available when the profiler is <a href="#connect">connected</a> to a running application,
    allowing to instantly learn object counts without capturing and opening a memory snapshot.
  </p>
  <p>
    This view is also available in performance snapshots, but is not available
    in memory snapshots being superseded with <a href="#objects_view">objects view</a>.
  </p>

  <p>
    The presented information can be useful as an overview of memory consumed by the profiled application
    and also as a clue to detecting memory leaks.
    For details, see <a href="#high_memory_usage">How to find out why application eats that much memory?</a>
    and <a href="#memory_leaks">How to find memory leaks?</a>
  </p>

  <figure>
    <img alt="" src="resources/telemetry_classes.png"/>
  </figure>

  <p>
    This view, unlike other telemetry views, does not automatically periodically update.
    This is for performance considerations:
    gathering the statistics may take significant time in case of huge heaps with many objects,
    thus should run on demand.
  </p>
  <p>
    Instead, it updates when:
  </p>
  <ul>
    <li>
      <span class="ui_text">Refresh</span> button is pressed when the tab is visible (an explicit update)
    </li>
    <li>
      <span class="ui_text">Force Garbage Collector</span> button is pressed when the tab is visible
      (it makes sense to immediately see the changes in object counts and sizes after forcing garbage collection)
    </li>
    <li>
      a snapshot is captured
      (gathering the statistics is a part of the capture)
    </li>
  </ul>

  <h2 id="telemetry">Allocation telemetry</h2>

  <p>
    You can profile <a href="#allocations">object allocation</a> without <a href="#memory_snapshots">capturing a memory snapshot</a>.
  </p>

  <p>
    <span class="ui_text">Memory</span> tab's section <span class="ui_text">Allocations</span>
    shows counts and sizes for objects whose allocations have been recorded,
    including objects which are still alive as well as objects that have been collected by the moment.
  </p>

  <figure>
    <img alt="" src="resources/allocation_telemetry.png"/>
  </figure>

  <p class="hint">
    This live view provides only basic information, and you still need to <a href="#memory_snapshots">capture memory snapshot</a>
    to perform comprehensive analysis: to separate live objects from dead objects,
    to see where live objects are retained, etc.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='memory_snapshots'>8.2&nbsp;Memory snapshot</h1>

  <p>
    A memory snapshot represents the memory state of the profiled application at the moment it was captured.
    It contains information about all loaded classes, about all existing objects, and about
    references between objects.
  </p>

  <p>
    Snapshots can contain values of fields and arrays of primitive types (<code class="nobr">int</code>, <code class="nobr">long</code>, <code class="nobr">char</code> etc.).
    <a href="#primitive_values">Read more</a>.
  </p>

  <p>
    Optionally, snapshot can contain information about object <a href="#allocations">allocations</a>.
  </p>

  <h2>Snapshot formats</h2>

  <p>
    You have an option to capture snapshot in YourKit Java Profiler format or via JVM built-in dumper:
  </p>
  <figure>
    <img alt="" src="resources/capture_memory_snapshot.png"/>
  </figure>
  <p>
    Read more about <a href="#hprof_snapshots">HPROF snapshots</a>.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='allocations'>8.3&nbsp;Object allocation recording</h1>

  <p>
    YourKit Java Profiler can optionally record object allocations, that is, track method calls where objects are created.
  </p>

  <p>
    To start allocation recording, <a href="#connect">connect</a> to the profiled application
    and use corresponding toolbar button:
  </p>

  <figure>
    <img alt="" src="resources/allocation_start.png"/>
  </figure>

  <h2 id="modes">Object allocation recording modes</h2>

  <p>
    Recording of allocations adds performance overhead. This is the reason why allocations
    should not be recorded permanently. Instead, it is recommended to record allocations only when you really need them.
  </p>

  <p>
    Also, you may choose from two available recording modes
    to balance between result accuracy and fullness and profiling overhead.
  </p>

  <ul>
    <li id="traditional">
      <p>
        <span class="ui_text">Record thread and stack where objects are allocated</span> (traditional recording)
      </p>
      <p>
        This mode provides most detail: full stack and thread where particular object is created
        is obtained and remembered for each recorded object.
        Allocation information for particular objects in available in a memory snapshot.
        Also, this mode enables comprehensive analysis of excessive garbage allocation.
      </p>
      <p>
        Memory snapshots captured when allocations are being recorded, or after object allocation recording has been stopped,
        contain allocation information.
      </p>
      <p>
        If an object is created when allocations are not being recorded,
        or recording is restarted after the object has been created,
        or allocation results are explicitly cleared after the object has been created,
        snapshot will contain no allocation information for that object.
      </p>
      <p>
        In order to keep moderate overhead, it is reasonable to skip allocation events for some percent of objects.
        This approach is useful to find the <a href="#excessive_gc">excessive garbage collection</a>.
      </p>
      <p>
        Also, you can record allocations for each object with size bigger than certain threshold.
        It is valuable to know where the biggest objects are allocated.
        Normally there are not so many such big objects, thus recording their allocation should not add any significant overhead.
      </p>
      <p>
        In some rare cases you can record each created object e.g. when allocation information for some
        particular object must be obtained. To achieve this, set "Record each" to 1.
      </p>

    </li>
    <li id="count">
      <p>
        <span class="ui_text">Count allocated objects</span> (quick recording)
      </p>

      <p>
        This is the most lightweight allocation recording mode.
      </p>

      <p>
        Use this mode to quickly get insight on how many objects are created and of which classes.
        In particular, this identifies excessive garbage allocation problems
        (lots of temporary objects).
      </p>

      <p>
        Object counting is specially designed to have minimal possible, almost zero overhead:
      </p>

      <ul>
        <li>
          Object counting provides allocated object counts by class then
          by immediate allocator method with the exact line number, if available.
          Unlike the traditional recording mode,
          it does not provide stack traces and
          does not track particular instances,
          i.e. no allocation information for particular live object(s)
          is available in a memory snapshot.
        </li>
        <li>
          Objects allocated in different threads are summed and cannot be distinguished.
        </li>
        <li>
          Counts are not guaranteed to be exact.
          To ensure minimal overhead allocation counts are updated without taking any locks or
          using test-and-set style atomic operations.
          If the same method running in parallel in different threads running
          on different CPU cores simultaneously creates instances of the same class,
          some of them may be missed by a non-atomic counter.
          Fortunately, the probability of such events is low,
          and missed invocations, if any, will normally constitute only a small fraction of all invocations.
        </li>
      </ul>

      <p>
        Use object counting to initially detect possible problems:
        thanks to its low overhead you may do this even in production.
      </p>
      <p>
        Further investigation may involve using traditional allocation recording
        to get comprehensive profiling results with stack traces (call tree).
      </p>
    </li>
  </ul>

  <h2 id="start">Start and stop recording</h2>

  <p>
    You can start and stop recording of allocations during execution of your application as many times as you wish.
    When allocations are not recorded, memory profiling adds no performance overhead to the application being profiled.
  </p>

  <p>
    You can control recording of allocations from the profiler UI as described above,
    or via <a href="#api">Profiler API</a>.
    You can also record allocations from the start of application execution
    (see <a href="#running_with_profiler">Running applications with the profiler</a>).
  </p>

  <h2>Object allocation recording results in the user interface</h2>

  <p>
    Recorded allocations are shown in <a href="#objects_view_alloc">Allocations view</a>,
    <a href="#garbage_collection">Garbage collection view</a> and <a href="#quick_info">Quick info</a>
  </p>

  <h2 id="availability">Availability</h2>

  <p>
    Allocation recording is based on bytecode instrumentation,
    which is on by default and imposes almost no overhead while allocation recording is not running.
  </p>
  <p>
    However, if you apply the startup options <code class="nobr">disablealloc</code> or <code class="nobr">disableall</code>
    to totally eliminate the overhead, allocation recording will not be possible.
  </p>

  <h2 id="sampled">Sampled object allocation recording option (advanced topic)</h2>

  <p>
    The greatest contribution to object allocation recording overhead
    in the traditional mode
    is made by obtaining exact stack trace for each recorded new object.
  </p>
  <p>
    The idea is to estimate stack trace instead in order to reduce the overhead.
    It is similar to how <a href="#cpu_intro">CPU sampling</a> works.
    The sampling thread periodically obtains stacks of running threads.
    When a thread creates a new object, the stack recently remembered for that thread
    is used as the object allocation stack estimation.
  </p>
  <p>
    And just like in case of CPU sampling, the sampled object allocation recording results
    are relevant only for methods longer than the sampling period.
  </p>

  <h2>When should be used</h2>

  <p>
    Use this mode to get allocation hot spots, to find top methods responsible for most allocations.
    Don't use it if you need precise results for all recorded objects.
  </p>

  <h2>How to enable</h2>

  <p>
    Exact stack traces are gathered by default when you start object allocation recording.
    To use sampled stacks instead:
  </p>
  <ul>
    <li>
      <p>
        in the profiler UI: choose "Estimated (sampled) stacks instead of exact stacks" in
        the "Start Object Allocation Recording"
        toolbar popup window
      </p>
      <figure>
        <img alt="" src="resources/sampled_allocation_recording.png"/>
      </figure>
    </li>
    <li>
      if object allocation recording is started with
      <a href="#alloceach">alloceach</a> or
      <a href="#allocsizelimit">allocsizelimit</a>
      startup options,
      specify startup option <a href="#allocsampled">allocsampled</a>
    </li>
    <li>
      use <a href="#api">API</a> method
      <code class="nobr">Controller.startAllocationRecording(...)</code>
      parameter <code class="nobr">boolean sampledAllocationRecording</code>.
      The old version of the method without that parameter records exact stacks.
    </li>
  </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='sizes'>8.4&nbsp;Shallow and retained sizes</h1>

  <p>
    YourKit Java Profiler is capable of measuring <i>shallow</i> and <i>retained</i> sizes of objects.
  </p>

  <p>
    <strong>Shallow size</strong> of an object is the amount of memory allocated to store the object itself, not taking into account the referenced
    objects. Shallow size of a regular (non-array) object depends on the number and types of
    its fields. Shallow size of an array depends on the array length and the type of its elements (objects, primitive types).
    Shallow size of a set of objects represents the sum of shallow sizes of all objects in the set.
  </p>

  <p>
    <strong>Retained size</strong> of an object is its shallow size plus the shallow sizes of the objects that are accessible,
    directly or indirectly, <strong>only</strong> from this object. In other words, the retained size represents the
    amount of memory that will be freed by the garbage collector when this object is collected.
  </p>

  <p>
    To better understand the notion of the <strong>retained size</strong>, let us look at the following examples:
  </p>

  <p>
    In order to measure the retained sizes, all objects in memory are treated as nodes of a graph where its edges represent references from objects to objects.
    There are also special nodes - <i>GC root</i> objects, which will not be collected by <i>Garbage Collector</i> at the time of measuring
    (read more about <a href="#gc_roots">GC roots</a>).
  </p>

  <p>
  The pictures below show the same set of objects, but with varying internal references.
  </p>
  <table width="100%">
    <tr valign="top">
      <td align="left"><div><strong>Figure 1:</strong></div></td>
      <td align="left"><div><strong>Figure 2:</strong></div></td>
    </tr>
    <tr valign="bottom">
      <td>
        <figure>
          <img alt="" src="resources/retained_objects.gif"/>
        </figure>
      </td>
      <td>
        <figure>
          <img alt="" src="resources/retained_objects_2.gif"/>
        </figure>
      </td>
    </tr>
  </table>
  <p>
  Let us consider <i>obj1</i>.<br/>
  As you can see, in both pictures we have highlighted all of the objects that are directly or indirectly accessed <strong>only</strong> by <i>obj1</i>.
  If you look at Figure 1, you will see that <i>obj3</i> is not highlighted,
  because it is also referenced by a <i>GC root</i> object. On Figure 2, however, it is already included into
  the retained set, unlike <i>obj5</i>, which is still referenced by <i>GC root</i>.
  </p>
  <p>
  Thus, the retained size of <i>obj1</i> will represent the following respective values:
  </p>
  <ul>
    <li>For Figure 1: the sum of shallow sizes of <i>obj1</i>, <i>obj2</i> and <i>obj4</i></li>
    <li>For Figure 2: the sum of shallow sizes of <i>obj1</i>, <i>obj2</i>, <i>obj3</i> and <i>obj4</i></li>
  </ul>
  <p>
    Looking at <i>obj2</i>, however, we see that its retained size in the above cases will be:
  </p>
  <ul>
    <li>For Figure 1: the sum of shallow sizes of <i>obj2</i> and <i>obj4</i></li>
    <li>For Figure 2: the sum of shallow sizes of <i>obj2</i>, <i>obj3</i> and <i>obj4</i></li>
  </ul>
  <p>
    In general, retained size is an integral measure, which helps to understand the structure (clustering) of memory
    and the dependencies between object subgraphs, as well as find potential roots of those subgraphs.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='memory_views'>8.5&nbsp;Memory views</h1>
&nbsp;<br><h1 id='objects_view'>8.5.1&nbsp;Objects view</h1>

  <p>
    The objects view allows you to comprehensively examine objects in a memory snapshot.
  </p>

  <p>
    When a memory snapshot opens,
    the <span class="ui_text">Memory</span> tab is shown automatically and represents all objects.
  </p>

  <p>You can also open it for a subset of objects:</p>
  <ul>
    <li><span class="ui_action">Memory | Selected Objects (F4)</span> works in any memory view if selection represents live objects.</li>
    <li><span class="ui_action">Memory | Instances by Class... (Ctrl+N)</span> opens all instances of a class by its name.</li>
    <li><span class="ui_action">Memory | Strings by Pattern... (Ctrl+F)</span> opens instances of strings, char arrays or byte arrays that match given text pattern.</li>
    <li><span class="ui_action">Memory | Predefined Set...</span> opens objects that belong to one of sets specified
      in <span class="ui_action">Settings | Sets of Objects...</span>.
    </li>
  </ul>

  <p>There are different views:</p>

  <ul>
    <li>
      <p>
        Objects by category:
      </p>

      <p>
        <a href="#class_list">Class list</a> - examine how memory is distributed among instances of different classes
      </p>
      <p>
        <a href="#class_tree">Class and package</a> - similar to the Class list, but classes are grouped by package
      </p>
      <p>
        <a href="#class_loaders">Class loaders</a> - distribute objects by class loader
      </p>
      <p>
        <a href="#web_applications">Web applications</a> - distribute objects by web application
      </p>
      <p>
        <a href="#generations">Generations</a> - distribute objects by time of their creation
      </p>
      <p>
        <a href="#reachability">Reachability</a> - shows objects distributed according to
        how/whether they are reachable from GC roots
      </p>
      <p>
        <a href="#shallow_size_view">Shallow size</a> - shows objects distributed according to
        their shallow size range
      </p>
    </li>
    <li>
      <p>
        Individual objects:
      </p>

      <p>
        <a href="#objects_view_explorer">Object explorer</a> - browse individual objects
      </p>
      <p>
        <a href="#biggest_objects">Biggest objects</a> - find individual objects that retain most of memory
      </p>
    </li>
    <li>
      <p>
        Allocation recording results:
      </p>

      <p>
        <a href="#objects_view_alloc">Allocations</a> - explore methods where objects were created
      </p>
      <p>
        <a href="#ages">Object ages</a> - distribute objects by how long they exist
      </p>
    </li>
    <li>
      <p>
        Other views (available as slave views only):
      </p>

      <p>
        <a href="#merged_paths">Merged paths</a> - examine how objects are retained
      </p>
      <p>
        <a href="#class_hierarchy">Class hierarchy</a> - shows super and derived classes
      </p>
    </li>
  </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='class_list'>8.5.1.1&nbsp;Class list</h1>

  <p>
    This view is a powerful tool for examining how memory is distributed among instances of different classes.
  </p>

  <p>
    Classes are shown as a plain list.
    To see them grouped by package, use <a href="#class_tree">Class and package</a>.
  </p>

  <p>
    Information for a class is shown in four columns: "Class", "Objects" (number of objects), "Shallow Size" and "Retained Size"
    (for details please see <a href="#sizes">Shallow and retained sizes</a>).
  </p>

  <p>
    Classes whose objects retain most memory are shown at the top, as the list is sorted by retained size.
  </p>

  <p>
    On opening the view, estimated retained sizes are shown instead of exact sizes, which cannot be immediately calculated.
    The exact sizes may be obtained by using "Calculate exact retained sizes" balloon above the "Retained Size" column.
    However, for most classes the estimation is very close to the exact value, so there is almost no need to run exact
    size calculation.
  </p>

  <figure>
    <img alt="" src="resources/class_list_balloon.png"/>
  </figure>
  <p>
    You can narrow down the list by typing a class name in the text field.
  </p>

  <p class="hint">
    Please also consider <span class="ui_action">Memory | Instances by Class... (Ctrl+N)</span>,
    which opens all instances of a class by its name.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='class_tree'>8.5.1.2&nbsp;Class and package</h1>

  <p>
    This view is similar to <a href="#class_list">class list</a>, but shows classes grouped by package
    instead of a plain list.
  </p>

  <figure>
    <img alt="" src="resources/class_tree.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='class_loaders'>8.5.1.3&nbsp;Class loaders</h1>

  <p>
    "Class loaders" view shows objects grouped by class loader
  </p>

  <figure>
    <img alt="" src="resources/class_loaders.png"/>
  </figure>

  <p>
    For each loader, the number of loaded classes is shown, as well as the number of classes without
    instances; this information can help in finding leaked loaders.
  </p>
  <p>
    Paths from GC roots to the loader object are explicitly available as a slave view "Paths to Loader".
    This allows you to learn why particular loader is retained in memory.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='web_applications'>8.5.1.4&nbsp;Web applications</h1>

  <p>
    "Web applications" view shows objects grouped by web application.
  </p>

  <figure>
    <img alt="" src="resources/web_applications.png"/>
  </figure>

  <p>
    Web applications are detected for a number of popular servers:
  </p>
  <ul>
    <li>Tomcat</li>
    <li>JBoss</li>
    <li>Jetty</li>
    <li>GlassFish</li>
    <li>WebLogic</li>
    <li>WebSphere</li>
  </ul>
  <p>
    Objects that do not belong to a particular web application will be indicated as such;
    it will be all objects if it is not a snapshot of a supported server,
    or not of a server at all.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='generations'>8.5.1.5&nbsp;Object generations</h1>

  <p>
    Generations distribute objects by time of their creation, and
    are thus very helpful in finding memory leaks and performing other
    analysis of how heap content evolves over time.
  </p>

  <p>
    When an object is created, it is associated with the current generation number.
    The generations are sequentially numbered starting from 1.
    The current generation number is automatically advanced on capturing memory snapshot.
    It can also be explicitly advanced with the help of "Advance Object Generation Number" toolbar button, as well as via <a href="#api">API</a>.
  </p>

  <figure>
    <img alt="" src="resources/generations_mark.png"/>
  </figure>

  <p>
    The generation represents an object's age: the smaller the generation number, the older the object.
  </p>

  <p>
    All tabs representing live objects have a "Generations" view.
    In this view, you can see objects separated by time of their creation:
  </p>

  <figure>
    <img alt="" src="resources/generations_view.png"/>
  </figure>

  <p>
    To see the generation of a single object, use <a href="#quick_info">Quick Info</a>:
  </p>

  <figure>
    <img alt="" src="resources/generations_quick_info.png"/>
  </figure>

  <p>
    See also the <a href="#memory_leaks">typical memory leak detection scenario</a>.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='reachability'>8.5.1.6&nbsp;Reachability scopes</h1>

  <p>
    Reachability scopes distribute objects according to
    how/whether they are reachable from GC roots.
  </p>
  <p>
    This information is helpful when analysing the profiled application's memory consumption and
    searching for memory leaks. Also it helps examining excessive garbage allocation,
    especially if the snapshot doesn't contain recorded object allocation information.
  </p>
  <ul>
    <li>
      Strong reachable: objects reachable from GC roots via at least one strong reference,
      or being GC roots themselves.
      Such objects will not be garbage collected until all strong references to them are nulled
      and/or they remain GC roots.
      Thus, memory leaks should be searched among them.
    </li>
    <li>
      Weak/soft reachable: objects reachable from GC roots via weak and/or soft references only.
      Such objects can be deleted by garbage collector when it decides to free some memory.
      Such objects are not memory leaks, but they may deserve attention when you analyze memory consumption.
    </li>
    <li>
      Dead objects: unreachable from GC roots, but not yet collected.
      Once garbage collector decides to delete them, they will be deleted.
      Objects of classes overriding <code class="nobr">Object.finalize()</code>
      will be placed to the finalizer queue before actual deletion.
    </li>
    <li>
      Objects pending finalization: objects in the finalizer queue.
    </li>
  </ul>
  <figure>
    <img alt="" src="resources/reachability.png"/>
  </figure>
  <p>
    In addition to the "Reachability scopes" view,
    <a href="#objects_view">objects view</a> header shows brief summary
    on the number of strong reachable objects, and if there are any, provides an easy way
    to open them in new tab, by clicking corresponding link (useful when analysing memory leaks):
  </p>
  <figure>
    <img alt="" src="resources/reachability_brief_summary.png"/>
  </figure>
  <p>
    Action <span class="ui_action">Memory | Instances by Class... (Ctrl+N)</span>
    allows you to choose the reachability scope of objects to open:
  </p>
  <figure>
    <img alt="" src="resources/reachability_in_instances_by_class.png"/>
  </figure>
  <p>
    The reachability scope for individual objects is shown in reference explorers and paths views:
  </p>
  <figure>
    <img alt="" src="resources/reachability_in_obj_explorer.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='shallow_size_view'>8.5.1.7&nbsp;Shallow size</h1>

  <p>
    Shallow size view distributes objects by their <a href="#sizes">shallow size</a> range.
    It allows you to evaluate how many small, medium and large objects are in the heap, and how much memory they use.
  </p>

  <p>
    This information can be useful when tuning GC options.
  </p>

  <figure>
    <img alt="" src="resources/shallow_size_view.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='objects_view_explorer'>8.5.1.8&nbsp;Object explorer</h1>

  <h2>Outgoing references</h2>

  <p>
    Shows all objects of the set and allows you to browse their outgoing references.
    Outgoing references of an object are fields or array elements of that object that point to other objects.
  </p>

  <figure>
    <img alt="" src="resources/outgoing_ref_explorer.png"/>
  </figure>

  <h2>Incoming references</h2>

  <p>
    Shows all objects of the set and allows you to browse their incoming references.
    Incoming references of an object are references to that object.
  </p>

  <p class="hint">
    DO NOT use "Incoming references" to find out why an object is retained in memory. Use <a href="#paths">paths</a> instead.
  </p>

  <figure>
    <img alt="" src="resources/incoming_ref_explorer.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='biggest_objects'>8.5.1.9&nbsp;Biggest objects (dominators)</h1>

  <p>
    This view shows individual objects that <a href="#sizes">retain</a> most of memory.
    The objects are shown as a dominator tree.
    That is, if object A retains object B, then object B will be nested in object A's node.
    <a href="#sizes">Read more about retention</a>.
  </p>
  <figure>
    <img alt="" src="resources/biggest_object.png"/>
  </figure>
  <p>
    This information can be useful to explore and reduce memory usage.
    In particular, it helps finding memory leaks caused by individual objects.
    Sometimes you can learn a lot by looking at memory distribution in terms of individual objects.
  </p>
  <p>
    Also consider <a href="#class_list">"Class list"</a> which shows similar information for objects grouped by classes.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='objects_view_alloc'>8.5.1.10&nbsp;Allocations</h1>

  <p>
    This section is available only for snapshots that contain any recorded <a href="#allocations">object allocations</a>.
  </p>

  <p>
    Allocations let you discover methods where objects were created.
  </p>

  <figure>
    <img alt="" src="resources/alloc_overview.png"/>
  </figure>

  <h2>Call tree</h2>
  <p>
    Shows a top-down call tree with the methods in which objects from the set were created,
    either for each particular thread ("by thread")
  </p>
  <figure>
    <img alt="" src="resources/alloc_call_tree_by_thread.png"/>
  </figure>
  <p>
    or with calls from all threads merged ("all threads together").
  </p>
  <figure>
    <img alt="" src="resources/alloc_call_tree_all_threads.png"/>
  </figure>
  <p>
    The tree is shown according to current <a href="#filters">filters</a>.
  </p>

  <h2>Hot spots</h2>
  <p>
    Shows methods where the greatest number of objects from the set ("Hot spots by object count")
  </p>
  <figure>
    <img alt="" src="resources/alloc_hot_spots_by_count.png"/>
  </figure>
  <p>
    or objects with the greatest total shallow size ("Hot spots by object size") were created.
  </p>
  <figure>
    <img alt="" src="resources/alloc_hot_spots_by_size.png"/>
  </figure>
  <p>
    Methods are shown according to current <a href="#filters">filters</a>:
  </p>
  <ul>
    <li>
      non-filtered methods (typically, methods from the source code of profiled application)
    </li>
    <li>
      filtered methods (typically, methods from core classes and used libraries) that were
      directly called from non-filtered methods or are at the top of thread stack trace (<code class="nobr">Thread.run()</code>).
    </li>
  </ul>

  <h2>Method list</h2>
  <p>
    Methods are shown according to current <a href="#filters">filters</a>:
    <ul>
      <li>
        non-filtered methods (typically, methods from the source code of profiled application)
      </li>
      <li>
        filtered methods (typically, methods from core classes and used libraries) that were
        directly called from non-filtered methods or are at the top of thread stack trace (<code class="nobr">Thread.run()</code>).
      </li>
    </ul>
  </p>
  <p>
    For each method, the list shows the number and shallow size of objects it had created.
  </p>

  <p>
    You can narrow down the list by typing a method's name in the text field.
  </p>
  <figure>
    <img alt="" src="resources/alloc_method_list.png"/>
  </figure>

  <h2>Ages</h2>
  <p>
    Shows objects distributed by their <a href="#ages">ages</a>.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='ages'>8.5.1.11&nbsp;Object ages</h1>

  <p>
    This section is available only for snapshots that contain any recorded <a href="#allocations">object allocations</a>.
  </p>

  <p>
    Recorded objects are shown distributed by how long they exist.
    This information is helpful in tuning garbage collector parameters.
  </p>

  <figure>
    <img alt="" src="resources/object_ages_live.png"/>
  </figure>

  <p>
    Object ages are also shown as:
  </p>

  <ul>
    <li>
      <p>
        "Object Ages" view in <a href="#garbage_collection">Garbage Collection</a> view for collected objects
      </p>
      <figure>
        <img alt="" src="resources/object_ages_garbage.png"/>
      </figure>
    </li>
    <li>
      <p>
        <a href="#quick_info">Quick info</a> view for particular object
      </p>
    </li>
  </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='merged_paths'>8.5.1.12&nbsp;Merged paths</h1>

  <p>
    <span class="ui_text">Merged paths</span> view is a tool for examining how objects are retained.
    It is especially useful for analyzing objects of classes with a great number of instances, such as
    <code class="nobr">int[]</code>, <code class="nobr">java.lang.String</code> etc.
  </p>

  <p>
    <span class="ui_text">Merged paths</span> is similar to <a href="#paths">Paths from GC roots</a>;
    however, it does not show paths through individual objects, but paths from multiple objects grouped by class.
  </p>

  <p>
    For example, see the picture below.
    It shows that the memory held by <code class="nobr">int[]</code> instances is mostly retained by
    <code class="nobr">IntegerInterleavedRaster</code> instances, which are in turn retained by
    <code class="nobr">BufferedImage</code> and <code class="nobr">OffScreenImage</code>.
  </p>

  <figure>
    <img alt="" src="resources/merged_paths.png"/>
  </figure>

  <p>
    Another difference between <span class="ui_text">Merged paths</span> and <span class="ui_text">Paths from GC roots</span>
    is that the merged paths are build on the <a href="#biggest_objects">dominator tree</a>
    while the paths use the full object reference graph as is.
    This means that some intermediate nodes seen in <span class="ui_text">Paths from GC roots</span> may be missing
    in <span class="ui_text">Merged paths</span> for objects which are retained indirectly.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='class_hierarchy'>8.5.1.13&nbsp;Class hierarchy</h1>

  <p>
    'Class hierarchy' view shows super classes and derived classes of given class.
  </p>
  <p>
    'Class hierarchy' is available as a slave view.
    It is shown for the class selected in the master table
    (e.g. in <a href="#class_list">Class list</a>)
    or for the class of the object selected in the master table
    (e.g. in <a href="#objects_view_explorer">Objects explorer</a>).
  </p>

  <figure>
    <img alt="" src="resources/class_hierarchy.png"/>
  </figure>

  <p class="hint">
    You may want to <a href="#ide_integration">open the class in your IDE</a>
    to use more powerful hierarchy analysis capabilities it provides.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='mem_method_merged_callees'>8.5.2&nbsp;Method merged callees view</h1>

  <p>
    This view is available only for snapshots that contain any recorded <a href="#allocations">object allocations</a>.
  </p>
  <p>
    This view shows merged callees for a particular method that allocated objects.
    In other words, it shows all call traces started from that method.
    This gives a summary of method execution, and its "overall" behavior.
  </p>
  <figure>
    <img alt="" src="resources/mem_merged_callees.png"/>
  </figure>
  <p>
    To open this view for the selected method, use <span class="ui_action">Memory | Method Merged Callees (Ctrl+M)</span>.
  </p>

  <p>
    See also:
    <ul>
      <li><a href="#mem_method_back_traces">Method back traces view</a></li>
    </ul>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='mem_method_back_traces'>8.5.3&nbsp;Method back traces view</h1>

  <p>
    This view is available only for snapshots that contain any recorded <a href="#allocations">object allocations</a>.
  </p>
  <p>
    This view shows where a particular method, that allocated objects, was called.
  </p>
  <figure>
    <img alt="" src="resources/mem_back_traces.png"/>
  </figure>
  <p>
    To open this view for the selected method, use <span class="ui_action">Memory | Method Back Traces (Ctrl+Shift+M)</span>.
  </p>

  <p>
    See also:
    <ul>
      <li><a href="#mem_method_merged_callees">Method merged callees view</a></li>
    </ul>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='quick_info'>8.5.4&nbsp;Quick info view</h1>

  <p>
    "Quick Info" view shows useful information about selected object(s) and is available:
  </p>

  <ul>
    <li>
      as a slave view
      <figure>
        <img alt="" src="resources/quick_info_slave_view.png"/>
      </figure>
    </li>
    <li>
      as a popup window invoked with <span class="ui_action">Memory | Quick Info (Ctrl+Q)</span> action.
    </li>
  </ul>
  <br/>

  <p>
    The view shows <a href="#sizes">retained and shallow size</a> and object count for the current selection:
  </p>
  <figure>
    <img alt="" src="resources/quick_info_objects.png"/>
  </figure>

  <p>
    If a single object is selected, its <a href="#generations">generation</a> is shown.
    If <a href="#allocations">allocation</a> has been recorded for the object,
    the allocation thread, stack trace and object ages are shown as well.
  </p>
  <figure>
    <img alt="" src="resources/quick_info_alloc.png"/>
  </figure>

  <p>
    For a byte array "Quick info" shows its text representation in specified encoding
    (the snapshot must contain <a href="#primitive_values">primitive values</a>):
  </p>

  <figure>
    <img alt="" src="resources/quick_info_byte_array.png"/>
  </figure>

  <p>
    If object is a <a href="#gc_roots">GC root</a> of type "Stack Local" or "JNI Local", corresponding stack trace is shown,
    as well as local variable name if available:
  </p>
  <figure>
    <img alt="" src="resources/quick_info_stack.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='gc_roots_view'>8.5.5&nbsp;GC roots view</h1>

  <p>
    The so-called <a href="#gc_roots">GC (Garbage Collector) roots</a> are special objects for garbage collector.
    The objects it collects are those that 1) are not GC roots and a) are not accessible by references from GC roots.
  </p>

  <p>
    "GC Roots" view shows garbage collector roots sorted by types.
  </p>

  <p>
    "GC Roots" view is NOT the best place to start <a href="#memory_leaks">memory leak</a> detection - see <a href="#paths">Working with paths</a> for
    a better approach.<br/>
    Instead, "GC Roots" view acts as an overview of all objects that could not be collected at the moment
    the snapshot was created.
    The view is provided for information purposes only.
  </p>

  <p>
    For memory leak analysis please use the <a href="#paths">Find paths</a> feature.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='paths'>8.5.6&nbsp;Leak detection: working with paths</h1>

  <p>
    The profiler provides a very powerful way to detect memory leak -
    calculation of <i>paths</i> between objects in memory.<br/>
    A path is a very simple and intuitive concept. A path between Object 1 and Object <i>n</i>
    is a sequence of objects where:
  </p>

  <ul>
    <li>First element is Object 1</li>
    <li>Each element in the sequence, starting with the second one, is referenced from its predecessor</li>
    <li>Last element is Object <i>n</i></li>
  </ul>

  <h2>Navigation between the views</h2>

  <p>
    When you have found a leaked object and want to fix the memory leak,
    use paths from GC roots to find out why that object is retained in memory.
  </p>

  <p>
    To see the paths, select an object and switch to <span class="ui_text">Paths from GC Roots</span>:
  </p>

  <figure>
    <img alt="" src="resources/paths.png"/>
  </figure>

  <p>
    You can limit the number of paths to show. It is guaranteed that the shortest paths are shown first,
    i.e. there are no paths shorter than the ones displayed.
  </p>

  <p>
    Also, you can explicitly invoke <span class="ui_action">Memory | Paths from GC Roots... (Ctrl+P)</span>
    to open the paths in a new tab.
  </p>

  <h2>Ignoring particular references</h2>

  <p>
    You can ignore particular references in paths.
    This feature is a great aid when investigating memory leaks,
    because it immediately shows whether nulling particular reference eliminates the leak,
    and if not, which remaining references you should also consider.
  </p>
  <figure>
    <img alt="" src="resources/paths_ignore_ref.png"/>
  </figure>

  <h2>Paths between predefined sets</h2>

  <p>
    <span class="ui_action">Memory | Paths between Predefined Sets...</span> is the most common way to find out how an object of the source set
    references objects of the target set.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='inspections_mem'>8.6&nbsp;Memory inspections</h1>

  <p class="hint">
    See also <a href="#event_inspections">Event inspections</a>
  </p>

  <p>
    Typical memory-related problems can be recognized with the help of the "Inspections" feature.
    Inspections enable automatic high-level analysis of application memory.
    Each inspection automatically detects a specific memory issue.
    Performing this type of analysis by hand would be a very complicated (if at all possible) task.
  </p>

  <p>
    With the help of inspections you can easily find the causes and possible solutions of usual
    memory-related problems.
  </p>

  <p>
    The "Inspections" view is added to any <a href="#objects_view">objects view</a>,
    such as "Memory" or a tab representing a subset of objects.
    Inspections for all live objects (i.e. for the entire snapshot) are also available via top-level tab "Inspections'.
  </p>

  <figure>
    <img alt="" src="resources/inspections_view.png"/>
  </figure>

  <p>
    (1) To run all inspections as a batch use "Run All Inspections" button.<br/>
    (2) To run a single inspection, select it in the tree and use "Run This Inspection Only" button
    (this is especially useful if you want to apply the changes made to an inspection's options).
  </p>

  <p>
    All inspections are grouped by category:
  </p>
  <ul>
    <li>Memory waste: duplicate objects as a whole
      <ul>
        <li><a href="#duplicate_strings">Duplicate Strings</a></li>
        <li><a href="#duplicate_objects">Duplicate Objects</a></li>
        <li><a href="#zero_length_arrays">Zero Length Arrays</a></li>
      </ul>
    </li>
    <li>Memory waste: data duplication inside objects
      <ul>
        <li><a href="#null_fields">Null Fields</a></li>
        <li><a href="#sparse_arrays">Sparse Arrays</a></li>
        <li><a href="#sparse_primitive_arrays">Sparse Primitive Arrays</a></li>
        <li><a href="#arrays_with_all_same_elements">Arrays with all the same elements</a></li>
      </ul>
    </li>
    <li>Possible leaks
      <ul>
        <li><a href="#inner">Objects Retained by Inner Class Back References</a></li>
        <li><a href="#swt">Lost SWT Controls</a></li>
      </ul>
    </li>
    <li>Other memory oddities
      <ul>
        <li><a href="#hashcodes">HashMap Hash Code Distribution</a></li>
        <li><a href="#hro">Highly Referenced Objects</a></li>
        <li><a href="#sro">Self Referencing Objects</a></li>
        <li><a href="#nso">Non-Serializable Objects Referenced from Serializable Objects</a></li>
        <li><a href="#deepest_objects">Objects With Biggest Distance To Nearest GC Root</a></li>
      </ul>
    </li>
  </ul>

  <h2 id="duplicate_strings">Duplicate Strings</h2>
  <p>
    Find all <code class="nobr">java.lang.String</code>'s with identical text values.<br/>
    Problem: Duplicate strings waste memory.<br/>
    Possible solution: Share string instance via pooling or using intern().
  </p>

  <figure>
    <img alt="" src="resources/inspections_dup_strings.png"/>
  </figure>

  <h2 id="duplicate_objects">Duplicate Objects</h2>
  <p>
    Find objects of the same class equal field by field, and arrays equal element by element.<br/>
    Problem: duplicate instances waste memory.<br/>
    Possible solution: reduce the number of instances by sharing, lazily creating, not storing permanently.
  </p>

  <figure>
    <img alt="" src="resources/inspections_dup_objects.png"/>
  </figure>

  <h2 id="zero_length_arrays">Zero Length Arrays</h2>
  <p>
    Find multiple instances of zero-length arrays of particular type.<br/>
    Problem: Memory waste and additional load for garbage collector.<br/>
    Possible solution: Use empty array per-class singleton e.g. via a static field in class.<br/>
  </p>

  <figure>
    <img alt="" src="resources/inspections_zero_length.png"/>
  </figure>

  <h2 id="null_fields">Null Fields</h2>
  <p>
    Find instance fields with high percentage of 'null' values.<br/>
    Problem: Possible memory waste.<br/>
    Possible solutions: If some of the fields are not used, get rid of them rarely assigned fields can be moved to subclasses in the class hierarchy.<br/>
  </p>

  <figure>
    <img alt="" src="resources/inspections_null_fields.png"/>
  </figure>

  <h2 id="sparse_arrays">Sparse Arrays</h2>
  <p>
    Find arrays with big number of 'null' elements.<br/>
    Problem: Possible memory waste.<br/>
    Possible solution: Use alternate data structures e.g. maps or rework algorithms.<br/>
  </p>

  <figure>
    <img alt="" src="resources/inspections_sparse_arrays.png"/>
  </figure>

  <h2 id="sparse_primitive_arrays">Sparse Primitive Arrays</h2>
  <p>
    Find arrays of primitive types with big number of 0 elements.<br/>
    Problem: Possible memory waste.<br/>
    Possible solution: Use alternate data structures e.g. maps or rework algorithms.<br/>
  </p>



  <h2 id="arrays_with_all_same_elements">Arrays with all the same elements</h2>
  <p>
    Find arrays such that all their elements are the same.<br/>
    Problem: possible memory waste.<br/>
    Possible solution: use alternate data structures e.g. maps or rework algorithms.<br/>
  </p>





  <h2 id="inner">Objects Retained by Inner Class Back References</h2>
  <p>
    Find objects retained via synthetic back reference of its inner classes.<br/>
    Problem: Such objects are potential memory leaks.<br/>
  </p>

  <figure>
    <img alt="" src="resources/inspections_inner.png"/>
  </figure>

  <h2 id="swt">Lost SWT Controls</h2>
  <p>
    Find SWT control instances not accessible from shown UI.<br/>
    Technically, it finds instances of org.eclipse.swt.widgets.Control which are not accessible from org.eclipse.swt.widgets.Display's field 'controlTable'<br/>
    Problem: Possible memory leaks.<br/>
    Possible solutions: Examine paths to lost objects to see if they really leaked<br/>
  </p>

  <figure>
    <img alt="" src="resources/inspections_swt.png"/>
  </figure>



  <h2 id="hashcodes">HashMap Hash Code Distribution</h2>
  <p>
    Find HashMaps with non-uniformly distributed hash codes.
  </p>
  <p>
    To achieve good HashMap performance, hash codes of objects used as keys should be uniformly distributed.
    Otherwise, map access performance degrades due to hash collisions.
    The inspection finds HashMaps with entries most unevenly distributed among chunks.
  </p>
  <p>
    Possible solution: consider better hashCode() implementation for objects used as keys,
    or use wrappers with properly implemented hashCode().
  </p>

  <figure>
    <img alt="" src="resources/inspections_hashcodes.png"/>
  </figure>

  <h2 id="hro">Highly Referenced Objects</h2>
  <p>
    Find objects referenced by a large number of other objects.<br/>
    Possible problems: Incorrect relations between objects in memory, logical errors and/or non-optimal data structures.<br/>
  </p>

  <figure>
    <img alt="" src="resources/inspections_hro.png"/>
  </figure>

  <h2 id="sro">Self Referencing Objects</h2>
  <p>
    Find objects with fields referencing 'this'.<br/>
    Problem: Possibly incorrect logic and/or memory waste.<br/>
    Possible solution: Remove redundant fields.<br/>
  </p>

  <figure>
    <img alt="" src="resources/inspections_sro.png"/>
  </figure>

  <h2 id="nso">Non-Serializable Objects Referenced from Serializable Objects</h2>

  <p>
    If a class implements interface <code class="nobr">java.io.Serializable</code> and one of its serialized fields
    refers to a non-serializable object (directly or through intermediate objects),
    <code class="nobr">java.io.NotSerializableException</code> will be thrown in runtime on attempt to serialize an instance of this class.
    This inspection automatically detects such situations.
  </p>

  <h2>Which objects are inspected</h2>

  <p>
    You can inspect all objects implementing <code class="nobr">Serializable</code>,
    selecting <span class="ui_text">Inspections</span> in the <span class="ui_text">Memory</span> tab,
    or only particular serializable objects.
  </p>

  <p>
    For example, test whether <code class="nobr">HTTPSessions</code> would have serialization problems
    (assume memory snapshot is open):
  </p>
  <ul>
    <li>
    Open all instances of HTTPSession in a new tab: <span class="ui_action">Memory | Instances by Class... (Ctrl+N)</span>,
    type "HTTPSession" and press Enter; "Include instances of subclasses" should be selected
    </li>
    <li>
    Click "Inspections" link in the tab
    </li>
    <li>
    Select "Non-Serializable Objects Referenced from Serializables" in the list and run it
    </li>
  </ul>

  <h2>Which objects are inspected</h2>

  <ul>
    <li>
    Class can explicitly specify the list of its serializable fields with the help of static field <code class="nobr">serialPersistentFields</code>
    </li>
    <li>
    Otherwise, instance fields without <code class="nobr">transient</code> modifier are serializable
    </li>
  </ul>

  <p>
    If a serializable class overrides <code class="nobr">writeObject(ObjectOutputStream)</code> and
    <code class="nobr">readObject(ObjectInputStream)</code> methods to change the default serialization behavior,
    it is impossible to automatically find out what fields will actually be serialized.
    Thus, the inspection can provide incorrect results for such classes.
    However, this should not be a big problem, because in most cases this
    only leads to "false alarms": the inspection would report a referenced non-serializable object
    which is not actually serialized by <code class="nobr">writeObject(ObjectOutputStream)</code>.
  </p>

  <p>
    Please learn more about serialization in this article:
    <a class="ext" href="http://java.sun.com/developer/technicalArticles/ALT/serialization/">http://java.sun.com/developer/technicalArticles/ALT/serialization/</a>
  </p>

  <h2>Limitation</h2>

  <p>
    This inspection is only available for the profiler's own format snapshots,
    and is not available for HPROF-format snapshots.
  </p>
  <p>
    The problem with HPROF snapshots is that they do not contain essential information needed for this inspection:
  </p>
  <ul>
    <li>
      It is unknown which classes are serializable,
      as there is no information about interfaces implemented by particular class
    </li>
    <li>
      It is unknown which fields are <code class="nobr">transient</code>
    </li>
  </ul>

  <p>
    The profiler cannot obtain missing data as the HPROF snapshots are produced by a JVM internal dumper
    which stores only fixed kinds of information.
  </p>

  <h2 id="deepest_objects">Objects With Biggest Distance To Nearest GC Root</h2>
  <p>
    Find objects with longest paths to GC root.<br/>
    Intention: helps finding longest chains of objects such as linked lists, queues, trees etc.<br/>
  </p>

  <figure>
    <img alt="" src="resources/inspections_deepest_objects.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='compare_snapshots'>8.7&nbsp;Comparing memory snapshots</h1>

  <p>
   This feature lets you compare any two memory snapshots.
  </p>

  <p class="hint">
    To locate memory leaks, consider using the <a href="#generations">object generations</a> feature.
  </p>

  <p>
    To compare snapshots:
    <ul>
      <li>Open both snapshots.</li>
      <li>Select one of them.</li>
      <li>
        Use <span class="ui_action">File | Compare Snapshot with...</span> (also available from the popup menu)
        and select the snapshot to compare with.
      </li>
    </ul>
  </p>

  <p>
    When comparing memory snapshots,
    there is an option to choose objects of which <a href="#reachability">reachability scopes</a>
    to be included to the comparison results:
  </p>
  <figure>
    <img alt="" src="resources/reachability_in_snapshot_comparison.png"/>
  </figure>

  <p>
    The <span class="ui_text">Comparison</span> tab with
    memory views <span class="ui_text">Classes</span> and
    <span class="ui_text">Classes and packages</span> will open.
    The views have 2 columns: <i>Objects (+/-)</i> and <i>Size (+/-)</i>.
    These display the differences in object counts and sizes. Positive values mean that
    Snapshot 2 (the later memory state) has more objects and/or its objects have the bigger total size.
  </p>

  <figure>
    <img alt="" src="resources/memory_comparison_list.png"/>
  </figure>

  <p>
    100% of size corresponds to the total size of all objects in the old snapshot.
    Likewise, 100% of count corresponds to the object count in the old snapshot.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='hprof_snapshots'>8.8&nbsp;Support of HPROF format snapshots</h1>

  <p>
    Java has a built-in feature for dumping heap snapshots to files in HPROF binary format.
    You can analyze these snapshots using all of the powerful features that YourKit Java Profiler
    provides for its own memory snapshots.
  </p>

  <p>
    HPROF snapshots can be created in the following ways:
  </p>

  <ul>
    <li>
      <h3>Automatically on OutOfMemoryError</h3>
      <p>
        <a href="#out_of_memory">Read more...</a>
      </p>
    </li>
    <li>
      <h3>Explicitly from within the profiler UI (Sun Java 6 and newer, JRockit R28.0.0 and newer)</h3>
      <figure>
        <img alt="" src="resources/hprof_capture.png"/>
      </figure>
    </li>
    <li>
      <h3>Explicitly via jmap utility (Sun/Oracle Java 6 and newer, JRockit R28.0.0 and newer)</h3>

      <p>
        Java's <code class="nobr">jmap</code> utility can connect to a running Java process and dump its Java heap:<br/>
        <code class="nobr">jmap -dump:format=b,file=file_name.hprof <i>&lt;PID&gt;</i></code>
      </p>
      <p>
        Hint: to learn the PID (process identifier) of running JVM, you can use <code class="nobr">jps</code> or <code class="nobr">jconsole</code> JDK utilities.
      </p>

      <p>
        The benefit is that memory can be analyzed on demand with no additional configuration of JVM or Java application.
        You can dump memory of any running instance of JVM that supports this feature.
      </p>
    </li>
    <li>
      <h3>Explicitly via jconsole utility (Sun Java 6 and newer, JRockit R28.0.0 and newer)</h3>

      <p>
        Sun Java has the <code class="nobr">jconsole</code> utility that lets you to connect to a running Java 6 process
        for monitoring and management.
      </p>

      <p>
        Using jconsole, you can dump Java heap via HotSpotDiagnostic MBean
      </p>

      <figure>
        <img alt="" src="resources/hprof_jconsole.png"/>
      </figure>
    </li>
    <li>
      <h3>Produced with Java's built-in basic level profiling capability HPROF</h3>
      <p>
        This approach has a lot of drawbacks and is not useful nowadays, but
        is mentioned here to show the complete picture.
      </p>
    </li>
  </ul>

  <h2>How it works</h2>

  <p>
    HPROF snapshots (*.hprof) can be opened the same way as YourKit Java Profiler format snapshots (*.snapshot)
  </p>

  <h2>Known issues</h2>
  <p>
    Some HPROF snapshots do not contain <a href="#primitive_values">values of primitive types</a>.
    When such snapshots are opened in the profiler, values of <code class="nobr">java.lang.String</code>'s will not be available.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='primitive_values'>8.9&nbsp;Values of primitive types</h1>

  <p>
    Values of primitive types (<code class="nobr">int</code>, <code class="nobr">boolean</code>, <code class="nobr">double</code> etc.)
    are available in a memory snapshot if it is:
  </p>

  <p>
    <ul>
      <li>
        <p>
          YourKit format snapshot (*.snapshot) of profiled application running on Java 6 or newer.
        </p>
        <p>
          Note: for Sun Java 6, update 4 or newer is required
          (because of <a class="ext" href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6540288">a JVM bug 6540288</a>)
        </p>
      </li>
      <li>
        <p>
          <a href="#hprof_snapshots">HPROF-format snapshot</a> of profiled application running on Java 6 or newer,
          or captured on <a href="#out_of_memory">OutOfMemoryError</a>
        </p>
      </li>
    </ul>
  </p>

  <p>
    Values of primitive fields and arrays of primitive types are shown in object explorers:
  </p>

  <figure>
    <img alt="" src="resources/primitive_values.png"/>
  </figure>

  <p>
    Also, a text representation in specified encoding can be seen for byte[] in <a href="#quick_info">Quick Info</a>.
  </p>

  <p class="hint">
    Values of strings help locating (identifying) a particular object among other objects of the same class.
    <span class="ui_action">Memory | Strings by Pattern... (Ctrl+F)</span> action
    searches for strings, char arrays or byte arrays, even with regular expressions.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='memory_actions'>8.10&nbsp;Useful actions</h1>

  <p class="hint">
    Use <i>popup menu</i> and <i>main menu</i> to see what actions are enabled in particular context.
  </p>

  <ul>
    <li>
      <p>
        <span class="ui_action">Memory | Quick Info (Ctrl+Q)</span> -
        <a href="#quick_info">Quick info</a> view shows detail on selected object(s).
      </p>
    </li>
    <li>
      <p>
        <span class="ui_action">Memory | Instances by Class... (Ctrl+N)</span> -
        <a href="#objects_view">shows</a> instances of a class after you specify its name.<br/>
        <strong>Hint:</strong> You can also use this action to get quick info on the number of instances of a particular class: just type in the class name, and the instance count will appear next to the class name in the lookup list.
        Then hit ESC to close the lookup window, or press Enter to open the new tab.
      </p>
    </li>
    <li>
      <p>
        <span class="ui_action">Memory | Selected Objects (F4)</span> -
        <a href="#objects_view">shows</a> selected live objects in a new tab.
        Works in any memory view if the selection represents live objects.
      </p>
    </li>
    <li>
      <p>
        <span class="ui_action">Memory | Paths from GC Roots... (Ctrl+P)</span> - finds <a href="#paths">paths</a>
        from GC roots to the objects represented within the current selection.
        Works in any memory view if the selection represents live objects.
      </p>
    </li>
    <li>
      <p>
         <span class="ui_action">Memory | Strings by Pattern... (Ctrl+F)</span> -
         <a href="#objects_view">shows</a> instances of <code class="nobr">java.lang.String</code>,
         <code class="nobr">char[]</code> and <code class="nobr">byte[]</code> (in specified encoding) matching the given text pattern.
         This can be useful to locate particular objects if their fields refer to a known string or a char sequence.
      </p>
    </li>
    <li>
      <p>
        <span class="ui_action">Tools | Open in IDE (F7)</span> - opens the currently selected class, field or method in the IDE editor.
        See <a href="#ide_integration">IDE integration</a>.
      </p>
    </li>
  </ul>

  The following actions are available if a snapshot contains any recorded <a href="#allocations">object allocations</a>:

  <ul>
    <li>
      <p>
        <span class="ui_action">Memory | Method Merged Callees (Ctrl+M)</span> -
        shows <a href="#mem_method_merged_callees">merged callees </a> of the selected method.
      </p>
    </li>
    <li>
      <p>
        <span class="ui_action">Memory | Method Back Traces (Ctrl+Shift+M)</span> -
        shows <a href="#mem_method_back_traces">back traces</a> of the selected method.
      </p>
    </li>
  </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='language'>8.11&nbsp;Set description language</h1>

  <p>
    This XML-based language provides the advanced ability to specify sets of objects
    in a declarative way. It can be used, for example, to examine memory distribution in automated memory tests.
  </p>

  <p>
    To see some samples and define your custom sets, please use <span class="ui_action">Settings | Sets of Objects...</span> in the main menu.
    The sets can be opened via <span class="ui_action">Memory | Predefined Set...</span>.
  </p>

  <ul>
    <li>
      <p>
        Tag <strong>objects</strong> specifies objects of a particular class, or multiple classes.
      </p>
      <p>
        Mandatory attribute <strong>class</strong> specifies the fully qualified class name. Wildcards (*) are also accepted.
      </p>

      <p>
        Optional attribute <strong>subclasses</strong> specifies whether subclasses should be  accepted (<i>subclasses="true"</i>),
        or the class should match exactly (<i>subclasses="false"</i>). Default value is <i>true</i>.
      </p>

      <h3>Example</h3>

      <p>
      &lt;objects class="com.company.MyClass"/&gt; - all instances of the class <code class="nobr">com.company.MyClass</code> and its subclasses
      </p>

      <p>
      &lt;objects class="com.company.MyClass" subclasses="false"/&gt; - all instances of
      <code class="nobr">com.company.MyClass</code> but excluding instances of classes derived from <code class="nobr">com.company.MyClass</code>.
      </p>

      <p>&lt;objects class="*[]"/&gt; - all arrays</p>
    </li>

    <li>
      <p>Tag <strong>roots</strong> specifies all objects that are GC roots.</p>

      <p>Example</p>

      <p> &lt;roots/&gt; </p>
    </li>

    <li>
      <p>
      Tag <strong>and</strong> intersects the specified sets and returns all objects that are present in every set.
      There should be at least 2 nested sets.
      </p>

      <h3>Example</h3>

      <p> The specification of all objects of classes that implement both <code class="nobr">com.company.MyInterfaceA</code> and
        <code class="nobr">com.company.MyInterfaceB</code> interfaces:
      </p>

      <pre><code>&lt;and&gt;
  &lt;objects class="com.company.MyInterfaceA"/&gt;
  &lt;objects class="com.company.MyInterfaceB"/&gt;
&lt;/and&gt;</code></pre>
    </li>

    <li>
      <p>
      Tag <strong>or</strong> joins the specified sets and returns all objects that are present at least in one of the sets.
      There should be at least 2 nested sets.
      </p>

      <h3>Example</h3>

      <p>
        The specification of all objects of the class <code class="nobr">com.company.A</code> and its subclasses, and
        all objects of the class <code class="nobr">com.company.B</code> and its subclasses:
      </p>

      <pre><code>&lt;or&gt;
  &lt;objects class="com.company.A"/&gt;
  &lt;objects class="com.company.B"/&gt;
&lt;/or&gt;</code></pre>
    </li>

    <li>
      <p>
      Tag <strong>not</strong> specifies all objects that are not present in the specified set.
      There should be one and only one set specified.
      </p>

      <h3>Example</h3>

      <p>The specification of all objects except for the objects of class <code class="nobr">com.company.A</code> and its subclasses:</p>

      <pre><code>&lt;not&gt;
  &lt;objects class="com.company.A"/&gt;
&lt;/not&gt;</code></pre>
  </li>

    <li>
      <p>
      Tag <strong>reachable-objects</strong> specifies objects accessible by references from the set specified
      via mandatory subtag <strong>from</strong>.
      </p>

      <p>
        The result will not include objects other than the ones specified via mandatory subtag <strong>object-filter</strong>.
        In terms of graphs, <strong>object-filter</strong> specifies allowed nodes.
      </p>

      <p>
      Mandatory subtag <strong>field-filter</strong> allows you to search for objects reachable only from particular fields of classes.

      Restrictions for any number of classes can be specified as <strong>class</strong> subtags of <strong>field-filter</strong>:
      </p>

      <pre><code>&lt;field-filter&gt;
  &lt;class name="com.company.ClassA"&gt;
    &lt;allowed field="field1"/&gt;
    ...
    &lt;forbidden field="field2"/&gt;
    ...
  &lt;/class&gt;
  &lt;class name="com.company.ClassB"&gt;
    ...
  &lt;/class&gt;
  ...
&lt;/field-filter&gt;</code></pre>

      <p>
      For each class, you can specify any number of names (including none) of the <strong>allowed</strong> and <strong>forbidden</strong> fields.
      If at least one <strong>allowed</strong> tag is specified, only the <strong>allowed</strong> fields will be allowed for the class.
      If no <strong>allowed</strong> fields are specified, any fields except for the <strong>forbidden</strong> ones will be allowed for the class.
      </p>

      <p>Any fields of classes not specified in <strong>field-filter</strong> are acceptable.</p>

      <h3>Example</h3>

      <p>
      The following example is a predefined set "Lost UI" (see <span class="ui_action">Settings | Sets of Objects...</span>).
      It lets you find all AWT/Swing UI controls that are not in the window hierarchy.
      </p>

      <p>
      UI controls are instances of <i>java.awt.Component</i> and its subclasses.
      Class <i>java.awt.Container</i> is a subclass of <i>java.awt.Component</i> and represents controls that contain other controls.
      To be shown, a control must be contained in windows, represented with objects of the class
      <i>java.awt.Window</i> with subclasses; <i>java.awt.Window</i> extends <i>java.awt.Container</i>.
      </p>

      <p>
      Our goal is to find any UI control (i.e. instance of <i>java.awt.Component</i>) not accessible
      from the window hierarchy. So we start from the windows (see the <strong>from</strong> section).
      </p>

      <p>
      We know that <i>java.awt.Container</i> stores its children in the field named <i>component</i> which is an array of
      components. According to this we form the <strong>object-filter</strong> and <strong>field-filter</strong> sections.
      Note that we have to include <i>java.awt.Component[]</i> to the object filter, so that the result of the entire
      <strong>reachable-objects</strong> tag includes arrays of components as well as components.
      </p>

      <p>
      To complete the task, we use a combination of <strong>and</strong> and <strong>not</strong> tags,
      to retrieve components that are not accessible from the windows in the specified way.
      </p>

      <pre><code>&lt;and&gt;
  &lt;objects class="java.awt.Component"/&gt;
  &lt;not&gt;

    <strong>&lt;reachable-objects&gt;</strong>
      &lt;from&gt;
        &lt;objects class="java.awt.Window"/&gt;
      &lt;/from&gt;

      &lt;object-filter&gt;
        &lt;or&gt;
          &lt;objects class="java.awt.Component"/&gt;
          &lt;objects class="java.awt.Component[]"/&gt;
        &lt;/or&gt;
      &lt;/object-filter&gt;

      &lt;field-filter&gt;
        &lt;class name="java.awt.Container"&gt;
          &lt;allowed field="component"/&gt;
        &lt;/class&gt;
      &lt;/field-filter&gt;
    <strong>&lt;/reachable-objects&gt;</strong>

  &lt;/not&gt;
&lt;/and&gt;</code></pre>

    </li>

    <li>
      <p>Tag <strong>retained-objects</strong> retrieves all objects that will be garbage-collected if all objects of the given set
      are garbage-collected. The given set is included. In other words, the retained set of set A is A itself plus all
      the objects accessible from A and only from A. These objects are called the retained set, and its size is called the retained size
      (see <a href="#sizes">Shallow and retained sizes</a> for more details).
      </p>

      <h3>Example</h3>

      <p>The following specifies of all objects that will be garbage collected if all objects of the class <code class="nobr">com.company.A</code> and
      its subclasses are garbage collected: </p>

      <pre><code>&lt;retained-objects&gt;
  &lt;objects class="com.company.A"/&gt;
&lt;/retained-objects&gt;</code></pre>
  </li>

  <li>
    <p>
      Tag <strong>generation</strong> returns objects from specified <a href="#generations">generations</a>.
    </p>

    <h3>Example</h3>

    <p>
      Objects from generation 3:  <code class="nobr"><i>&lt;generation name="#3:*"&gt;</i></code>
    </p>
    <p>
      Objects from all generation(s) with description "foo": <code class="nobr"><i>&lt;generation name="*: foo"&gt;</i></code>
    </p>
    <p>
      All strings from generation #5:
    </p>
    <pre><code>&lt;and&gt;
  &lt;objects class="java.lang.String"/&gt;
  &lt;generation name="#5:*"&gt;
&lt;/and&gt;</code></pre>
  </li>

  <li>
    <p>
      Tags <strong>strong-reachable</strong>, <strong>weak-soft-reachable</strong>, <strong>pending-finalization</strong>, <strong>unreachable</strong>
      return all objects of particular <a href="#reachability">reachability scope</a>.
    </p>

    <h3>Example</h3>

    <p>
      All weak or soft reachable strings:
    </p>
      <pre><code>&lt;and&gt;
  &lt;objects class="java.lang.String"/&gt;
  &lt;weak-soft-reachable/&gt;
&lt;/and&gt;</code></pre>
  </li>
    
  </ul>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='garbage_collection'>9&nbsp;Garbage collection</h1>

  <h2>Garbage collection telemetry</h2>

  <p>
    Garbage collection telemetry graphs shown in the <span class="ui_text">Memory</span> tab
    will help you estimate garbage collector load.
    If garbage collection takes a significant amount of time, it is advised to
    run <a href="#allocations">object allocation recording</a> to pin-point and optimize the problematic code.
  </p>

  <p>
    The "Garbage Collections" and "Time Spent in GC" graphs are always available.
  </p>

  <figure>
    <img alt="" src="resources/gc_telemetry.png"/>
  </figure>

  <p>You can explicitly run garbage collection using "Force Garbage Collection" toolbar button:</p>

  <figure>
    <img alt="" src="resources/gc_toolbar.png"/>
  </figure>

  <h2>Garbage collection in memory snapshot</h2>

  <p>
    If memory snapshot contains <a href="#allocations">recorded allocations</a>,
    "Garbage Collection" view, in addition to garbage collection telemetry described above,
    will also contain methods that were the sources of <a href="#excessive_gc">excessive garbage allocation</a>.
  </p>

  <p>
    See <a href="#performance_problems">Solving performance problems</a> for details on why one should
    avoid excessive garbage allocation.
  </p>

  <p>
    The shown number and shallow sizes correspond to the objects that were created and recycled
    since the <a href="#allocations">object allocation recording</a> was started and prior to the moment of the
    snapshot capture.
  </p>

  <ul>
    <li>
      <h3>Call tree</h3>
      <p>
        Shows a top-down call tree with methods in which collected objects were created,
        for each particular thread ("by thread")
      </p>
      <figure>
        <img alt="" src="resources/gc_call_tree_by_thread.png"/>
      </figure>
      <p>
        or with calls from all threads merged ("all threads together").
      </p>
      <figure>
        <img alt="" src="resources/gc_call_tree_all_threads.png"/>
      </figure>
      <p>
        The tree is shown according to current <a href="#filters">filters</a>.
      </p>
    </li>
    <li>
      <h3>Hot spots</h3>
      <p>
        Shows methods that made the biggest contribution to creating objects that were collected,
        either by object count or shallow size:
      </p>
      <figure>
        <img alt="" src="resources/gc_hot_spots.png"/>
      </figure>
      <p>
        Methods are shown according to current <a href="#filters">filters</a>:
        <ul>
          <li>
            non-filtered methods (typically, methods from the source code of profiled application)
          </li>
          <li>
            filtered methods (typically, methods from core classes and used libraries) that were
            directly called from non-filtered methods or are at the top of thread stack trace (<code class="nobr">Thread.run()</code>).
          </li>
        </ul>
      </p>
    </li>
    <li>
      <h3>Method list</h3>
      <p>
        Methods are shown according to current <a href="#filters">filters</a>:
        <ul>
          <li>
            non-filtered methods (typically, methods from the source code of profiled application)
          </li>
          <li>
            filtered methods (typically, methods from core classes and used libraries) that were
            directly called from non-filtered methods or are at the top of thread stack trace (<code class="nobr">Thread.run()</code>).
          </li>
        </ul>
      </p>
      <p>
        For each method, the list shows the number and shallow size of collected objects it had created.
      </p>
      <p>
        You can narrow down the list by typing a method's name in the text field.
      </p>
      <figure>
        <img alt="" src="resources/gc_method_list.png"/>
      </figure>
    </li>
    <li>
      <h3>Ages</h3>
      <p>
        Recorded objects are shown distributed by how long they existed.
        This information is helpful in tuning garbage collector parameters.
      </p>
      <figure>
        <img alt="" src="resources/object_ages_garbage.png"/>
      </figure>
    </li>
  </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='monitor_profiling'>10&nbsp;Monitor profiling</h1>

  <p>
    Monitor profiling helps you analyze synchronization issues, including:
    <ul>
      <li>
        which threads were calling wait(), and for how long
      </li>
      <li>
        which threads were blocked on attempt to acquire a monitor held by another thread (synchronized methods/blocks), and for how long
      </li>
    </ul>
  </p>
  <p>
    The times are measured as <a href="#times">wall time</a>.
  </p>

  <p>
    To start monitor profiling use "Start Monitor Profiling" toolbar button,
    after the profiler is <a href="#connect">connected</a> to the profiled application.
  </p>

  <figure>
    <img alt="" src="resources/monitors_start.png"/>
  </figure>

  <p>
    Monitor profiling results are shown in the "Monitor Usage" view.
    Results can be grouped by waiting thread, by blocker thread or by monitor class name.
  </p>

  <figure>
    <img alt="" src="resources/monitors_view.png"/>
  </figure>

  <p>
    <img src="resources/waiter_thread.png"/> - waiting thread (thread which called wait())<br alt=""/>
    <img src="resources/blocked_thread.png"/> - blocked thread (thread failed to immediately enter the synchronized method/block)<br alt=""/>
    <img alt="" src="resources/owner_thread.png"/> - blocker thread (thread that held the monitor preventing the blocked thread from entering the synchronized method/block)
  </p>
  <p>
    (1) comboboxes to select results grouping<br/>
    (2) checkbox to show blocked threads only (i.e. to filter out waiting threads)<br/>
    (3) method back traces for the selection in the upper table<br/>
  </p>

  <p>
    Percents in the tree are shown using the duration of monitor profiling
    (i.e. time passed since last start or clear) as 100%. This allows you to estimate
    the average percentage of time when thread waits/is blocked.
  </p>

  <p>
    In some cases, it may also be useful to launch the application with monitor profiling started
    (see <a href="#startup_options">Startup options</a>).
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='exception_telemetry'>11&nbsp;Exception telemetry</h1>


  <p>
    "Exceptions" telemetry shows exceptions which were thrown in the profiled application.
  </p>

  <figure>
    <img alt="" src="resources/exception_telemetry.png"/>
  </figure>

  <p>
    Exceptions may be grouped by their exception class or by thread in which they occurred.
    Selecting an exception in the upper table allows viewing the exception stack traces.
  </p>

  <p>
    Checkbox "Show exceptions thrown and caught inside filtered methods" enables to filter out
    exceptions which have been thrown and caught in methods of library classes. By default, the checkbox is
    unselected, as such kind of exceptions are usually of no interest when profiling your application.
  </p>

  <p>
    You can clear recorded exceptions with the help of corresponding toolbar button:
  </p>

  <figure>
    <img alt="" src="resources/clear_exception_telemetry.png"/>
  </figure>

  <p>
    You can compare exception statistics of two snapshots with the help of
    <span class="ui_action">File | Compare Snapshot with...</span>.
  </p>

  <h2>Disabling/enabling exception telemetry</h2>

  <p>
    Exception telemetry helps discovering performance issues and logic errors.
    In most cases, there is no significant overhead of collecting this information.
  </p>

  <p>
    However, it makes sense to disable it in production Java EE servers
    in order to ensure minimum profiling overhead.
  </p>

  <p>
    Whether the exception telemetry is enabled by default depends on the JVM
    and can be adjusted with the following <a href="#startup_options">startup options</a>:
  </p>
  <ul>
    <li>
      <code class="nobr">exceptions=on</code> enables exception events in the JVM and immediately starts recording the exception telemetry.
      This is the default mode on Sun/Oracle HotSpot, OpenJDK, JRockit (i.e. non-IBM JVMs).
    </li>
    <li>
      <code class="nobr">exceptions=off</code> enables exception events in the JVM but does not immediately start recording the exception telemetry
      that can instead be recorded later in runtime.
    </li>
    <li>
      <code class="nobr">exceptions=disable</code> fully disables exception events in the JVM to totally eliminate corresponding overhead.
      This is the <strong>default mode on IBM JVMs</strong> because the overhead is significant.
    </li>
  </ul>

  <p>
    When you are <a href="#connect">connected</a> to the profiled application, use
    corresponding toolbar button to enable/disable the telemetry.
  </p>

  <figure>
    <img alt="" src="resources/exceptions_disable.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='probes'>12&nbsp;Probes: monitor events of various kinds</h1>

  <h2>What is it for?</h2>

  <p>
    Get almost unlimited analysis capabilities by
    recording <i>events</i> specific to your particular application,
    and automatically recognize problems typical to wide range of applications.
  </p>

  <h2>Customizable to fit your needs...</h2>
  <p>
    Gather information about your application according to your own rules
    by setting up your custom <i>probes</i>.
  </p>

  <h2>Customizable to fit your needs...</h2>
  <p>
    Recognize typical problems with the help of <a href="#builtin_probes">built-in probes</a>
    which are ready to use out-of-the-box.
    Also, as the source code of the built-in probes is available,
    use it as a good example should you decide creating custom probes.
  </p>

  <h2>What kind of events can be monitored?</h2>
  <ul>
    <li>
      <h3>Enter or exit particular method</h3>
      <p>
        Bytecode instrumentation engine will inject calls to your probes to the methods
        which you specified.
        The probes are written in Java.
        You can access method parameters, method return value,
        the object for which the method is called,
        as well as intercept uncaught exceptions thrown in the method.
        This provides virtually unlimited capabilities to monitor applications.
        <a href="#event_method_call">Read more...</a>
      </p>
    </li>
    <li>
      <h3>Class load/unload</h3>
      <p>
        <a href="#classloading">Class loading probe</a>
        monitors class load and unload events
      </p>
    </li>
  </ul>
  <p class="hint">
    Please also consider <a href="#triggers">triggers</a>.
    They provide a wider range of events to monitor than probes do.
    However, triggered actions should be chosen from a predefined set,
    while probes can implement any necessary functionality.

  </p>

  <h2>What kind of information can be recorded on event?</h2>
  <p>
    <a href="#data_storage">Data storage</a> allows you to uniformly record the following information for each event:
  </p>
  <ul>
    <li>Where it happened: stack trace, thread</li>
    <li>When it happened</li>
    <li>If applicable, event duration and consumed CPU time</li>
    <li>Event-specific numerical or text information.
      For example, this can be the number of bytes written to a stream,
      or the URL of processed HTTP request etc. - you can record whatever you want.
    </li>
  </ul>

  <p>
    Although it is intended to use <a href="#data_storage">data storage</a> to gather information,
    if you wish you can also store it your own way, e.g. write it to your application's log,
    to a file or simply write to console.
  </p>

  <h2>How to access the recorded information?</h2>

  <p>
    <a href="#probes_ui">Probes UI</a> provides rich set of tools to analyze the gathered information,
    or to export it for external processing.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='probes_ui'>12.1&nbsp;Events in user interface</h1>

  <p>
    The probes and their results are shown in tab "Events".
  </p>

  <p>
    The tab is available when the profiler is <a href="#connect">connected to profiled application</a>,
    as well as browsing saved snapshot.
  </p>

  <p class="hint">
    Some functionality is available for a saved snapshot only.
  </p>

  <p>
    The view consists of two parts:
  </p>

  <figure>
    <img alt="" src="resources/probes_ui_overview.png"/>
  </figure>

  <h3>1. Table selector</h3>
  <p>
    Shows all available <a href="#tables">tables</a> as a tree:
    dependent tables are show as nested nodes of their master tables.
  </p>
  <p>
    Selected table is shown in <a href="#probes_ui_tables">Events by Table</a> (see below).
  </p>
  <p>
    Also, the table selector controls events from which tables are
    shown in <a href="#probes_ui_timeline">Event Timeline</a> and <a href="#probes_ui_call_tree">Event Call Tree</a>
    views (see below) via checkboxes.
  </p>

  <h3>2. The views</h3>
  <ul>
    <li>
      <a href="#probes_ui_tables">Events by Table</a> shows events in the table,
      which is selected in the table selector (1).
    </li>
    <li>
      <a href="#probes_ui_timeline">Event Timeline</a> shows event sequence in a table form.
      Use the table selector (1) to specify which events to include.
    </li>
    <li>
      <a href="#probes_ui_timeline_chart">Event Timeline Chart</a> shows event sequence graphically.
      Use the table selector (1) to specify which events to include.
    </li>
    <li>
      <a href="#probes_ui_call_tree">Event Call Tree</a> shows events distributed by stack trace.
      Use the table selector (1) to specify which events to include.
    </li>
    <li><a href="#cpu_usage_estimation">CPU Usage Estimation</a> for given event(s)</li>
  </ul>

  <h2>Navigation between the views</h2>
  <p>
    To open selected event(s) in another view, use corresponding popup menu items.
    <a href="#probes_ui_navigation">Read more...</a>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='probes_ui_tables'>12.1.1&nbsp;Events by Table</h1>


  <p>
    This view shows events in a particular <a href="#tables">table</a>.
    If the table has dependent tables, they are presented as slave views:
  </p>

  <figure>
    <img alt="" src="resources/tables_view.png"/>
  </figure>

  <p>
    Number of events in table is shown in the title.
  </p>

  <h2>Table columns. Grouping and visibility.</h2>

  <p>
    Events can be presented as a plain list, as well as grouped by arbitrary column(s).
  </p>

  <p>
    For each group you can see sum, minimum and maximum values for numeric columns.
  </p>

  <p>
    In addition to own table columns, you can also get statistics on
    associated rows of dependent columns: the number of the rows,
    as well as sum, minimum and maximum values of the dependent table's metrics.
  </p>

  <p>
    Also, you can hide columns to give more space for others.
  </p>

  <p>
    All this can be configured via "Configure columns and groping" action:
  </p>

  
  <figure>
    <img alt="" src="resources/configure_columns_action.png"/>
  </figure>

  
  <figure>
    <img alt="" src="resources/configure_columns.png"/>
  </figure>

  <figure>
    <img alt="" src="resources/rows_grouped.png"/>
  </figure>

  <h2>Navigation between views</h2>
  <p>
    To open selected event(s) in another view, use corresponding popup menu items.
    <a href="#probes_ui_navigation">Read more...</a>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='probes_ui_table_messages'>12.1.1.1&nbsp;Profiler events in table 'Messages'</h1>

  <p>
    Profiler events such as switching profiling modes, starting/stopping profiling,
    capturing snapshots etc. are logged to the log file,
    as well to built-in <a href="#tables">table</a> "Messages" (categories "Profiler" and "Profiler UI").
  </p>

  <p>
    You can add your own messages in your probes via
    utility class <a href="#messages">com.yourkit.probes.builtin.Messages</a>.
  </p>

  <p>
    You can see "Messages" table in the <a href="#probes_ui">probes UI</a>:
  </p>
  <figure>
    <img alt="" src="resources/table_message.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='probes_ui_timeline'>12.1.2&nbsp;Event Timeline</h1>


  <p>
    This view shows a sequence of events from different tables,
    allowing to analyze nested and sequential events of different kind.
  </p>

  <p>
    Choose which tables to include via <a href="#probes_ui">the table selector</a>.
  </p>

  <figure>
    <img alt="" src="resources/timeline.png"/>
  </figure>

  <h2>Navigation between views</h2>
  <p>
    To open selected event(s) in another view, use corresponding popup menu items.
    <a href="#probes_ui_navigation">Read more...</a>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='probes_ui_timeline_chart'>12.1.3&nbsp;Event Timeline Chart</h1>


  <p>
    This view presents event sequence graphically.
    It is complementary to <a href="#probes_ui_timeline">Event Timeline</a>
    showing event sequence in a table form.
  </p>

  <figure>
    <img alt="" src="resources/timeline_chart.png"/>
  </figure>

  <p>
    Usage hints:
  </p>
  <ul>
    <li>choose included events via <a href="#probes_ui">the table selector</a></li>
    <li>change scale with the toolbar control or Ctrl + mouse wheel</li>
    <li>to see particular event detail in a tooltip hover the event with the mouse cursor</li>
    <li>to open particular event in other views use a popup menu</li>
  </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='probes_ui_call_tree'>12.1.4&nbsp;Event Call Tree</h1>


  <p>
    This view shows events distributed by stack trace.
  </p>

  <p>
    For each table it shows where and how many events have happened.
  </p>

  <p>
    Choose which tables to include via <a href="#probes_ui">the table selector</a>.
  </p>

  <figure>
    <img alt="" src="resources/probes_ui_call_tree.png"/>
  </figure>

  <h2>Navigation between views</h2>
  <p>
    To open selected event(s) in another view, use corresponding popup menu items.
    <a href="#probes_ui_navigation">Read more...</a>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='probes_ui_stacks'>12.1.5&nbsp;Event stack traces</h1>


  <p>
    If event stack trace is available, top method is shown as a hyperlink.
    To see the stack trace, click the link or use a popup menu:
  </p>

  <figure>
    <img alt="" src="resources/probes_view_stack_trace.png"/>
  </figure>

  <p class="hint">
    The stack is recorded when event starts and when event ends.
    You can also <a href="#cpu_usage_estimation">estimate CPU usage</a> inside the event.
  </p>

  <p>
    You can apply <a href="#filters">filters</a> or see full stack trace:
  </p>

  <figure>
    <img alt="" src="resources/probes_stack_trace.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='probes_ui_navigation'>12.1.6&nbsp;Navigation between views</h1>


  <h2>Navigation inside "Events" tab</h2>

  <p>
    To open event(s) selected in
    <a href="#probes_ui_tables">Events by Table</a>,
    <a href="#probes_ui_timeline">Event Timeline</a> or
    <a href="#probes_ui_call_tree">Event Call Tree</a>
    in another view,
    use corresponding popup menu items:
  </p>

  <ul>
    <li>
      <p>
        In "Events by Table":
      </p>
      <figure>
        <img alt="" src="resources/probes_ui_table_view_in.png"/>
      </figure>
    </li>
    <li>
      <p>
        In "Event Timeline":
      </p>
      <figure>
        <img alt="" src="resources/probes_ui_timeline_view_in.png"/>
      </figure>
    </li>
    <li>
      <p>
        In "Event Call Tree":
      </p>
      <figure>
        <img alt="" src="resources/probes_ui_call_tree_view_in.png"/>
      </figure>
    </li>
  </ul>

  <h2>Navigation from "Events" to graphs</h2>

  <p>
    To open event(s) selected in
    <a href="#probes_ui_tables">Events by Table</a>,
    <a href="#probes_ui_timeline">Event Timeline</a> or
    <a href="#probes_ui_call_tree">Event Call Tree</a>
    in a telemetry graph or in <a href="#threads">Threads</a>,
    use corresponding popup menu items:
  </p>
  <figure>
    <img alt="" src="resources/probes_ui_view_time_in_graph.png"/>
  </figure>

  <h2>Navigation from graphs to "Events"</h2>

  <p>
    Use telemetry graph popup menu to open in <a href="#probes_ui_timeline">Event Timeline</a>
    the event nearest to the selected time point:
  </p>
  <figure>
    <img alt="" src="resources/probes_ui_graph_view_in_timeline.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='probes_ui_range'>12.1.7&nbsp;Events in range</h1>

  <p>
    Instead of examining all recorded events,
    you can focus on events intersecting with given event or group of events.
  </p>

  <p>
    For example, select event corresponding to particular servlet request,
    to see nested events such as database operations, file I/O, socket connections etc.
  </p>

  <p>
    To invoke the action, use popup menu:
  </p>
  <figure>
    <img alt="" src="resources/probes_view_intersected_menu.png"/>
  </figure>

  <p>
    As the result, a new "Events" tab will open.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='event_inspections'>12.2&nbsp;Event inspections</h1>

  <p class="hint">
    See also <a href="#inspections_mem">Memory inspections</a>
  </p>

  <p>
    Typical behavioral problems can be recognized with the help of the "Inspections" feature.
    Inspections enable automatic high-level analysis of <a href="#builtin_probes">built-in probe</a> results.
    Each inspection automatically detects a specific issue.
    Performing this type of analysis by hand would be a very complicated (if at all possible) task.
  </p>

  <p>
    With the help of inspections you can easily find the causes and possible solutions of usual
    problems.
  </p>

  <p>
    The feature is presented with "Inspections" view.
  </p>

  <figure>
    <img alt="" src="resources/event_inspections.png"/>
  </figure>

  <p>
    (1) To run all inspections as a batch use "Run All Inspections" button.<br/>
    (2) To run a single inspection, select it in the tree and use "Run This Inspection Only" button
    (this is especially useful if you want to apply the changes made to an inspection's options).
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='builtin_probes'>12.3&nbsp;Built-in probes</h1>

  <p>
    We have prepared a set of probes to help investigating typical problems.
    The probes are ready to use out-of-the-box.
    Also you can use them as good examples to start with should you decide creating custom probes.
  </p>

  <p>
    The following built-in probes are available at the moment:
  </p>
  <ul>
    <li><code class="nobr">com.yourkit.probes.builtin.Servlets</code> - JSP/Servlet requests</li>
    <li><code class="nobr">com.yourkit.probes.builtin.Databases</code> - JDBC/SQL database connections and requests</li>
    <li><code class="nobr">com.yourkit.probes.builtin.MongoDB</code> - MongoDB requests</li>
    <li><code class="nobr">com.yourkit.probes.builtin.Cassandra</code> - Cassandra database requests</li>
    <li><code class="nobr">com.yourkit.probes.builtin.HBase</code> - HBase database requests</li>
    <li>
      <code class="nobr">com.yourkit.probes.builtin.JPA_Hibernate</code>,<br/>
      <code class="nobr">com.yourkit.probes.builtin.JPA_EclipseLink</code>,<br/>
      <code class="nobr">com.yourkit.probes.builtin.JPA_OpenJPA</code>,<br/>
      <code class="nobr">com.yourkit.probes.builtin.JPA_DataNucleus</code>
      - JPA calls
    </li>
    <li><code class="nobr">com.yourkit.probes.builtin.Sockets</code> - socket I/O operations via streams and NIO channels</li>
    <li><code class="nobr">com.yourkit.probes.builtin.AsyncChannels</code> - socket I/O operations via asynchronous channels</li>
    <li><code class="nobr">com.yourkit.probes.builtin.Files</code> - file I/O operations via streams, random access files, NIO channels</li>
    <li><code class="nobr">com.yourkit.probes.builtin.Threads</code> - thread creation, start, name change. <a href="#threads_probe">Read more...</a></li>
    <li><code class="nobr">com.yourkit.probes.builtin.Processes</code> - external processes launched via <code class="nobr">Runtime.exec()</code> and <code class="nobr">ProcessBuilder.start()</code></li>
    <li><code class="nobr">Class loading</code> - class load and unload events. <a href="#classloading">Read more...</a></li>
    <li><code class="nobr">com.yourkit.probes.builtin.JUnitTests</code> - execution of JUnit tests</li>
    <li><code class="nobr">com.yourkit.probes.builtin.TestNG</code> - execution of TestNG tests</li>
    <li><code class="nobr">com.yourkit.probes.builtin.AWTEvents</code> - long AWT/Swing events, which cause UI irresponsiveness. <a href="#awtevents">Read more...</a></li>
    <li><code class="nobr">com.yourkit.probes.builtin.JNDI</code> - JNDI calls</li>
  </ul>

  <p>
    Also, the package <code class="nobr">com.yourkit.probes.builtin</code> contains utility class
    <a href="#messages">com.yourkit.probes.builtin.Messages</a> providing means to log arbitrary text messages
    from within probes.
  </p>

  <h2>Registering built-in probes</h2>

  <p>
    Built-in probes are enabled by default.
    You can change their activity mode or disable them.
    <a href="#register_probes">Read more...</a>.
  </p>

  <h2>Source code location</h2>

  <p>
    Source code of the built-in probes can be found in <code class="nobr"><i>&lt;Profiler Installation Directory&gt;</i>/probes/src</code>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='threads_probe'>12.3.1&nbsp;com.yourkit.probes.builtin.Threads</h1>

  <h2>Description</h2>

  <p>
    Probes to monitor some aspects of thread life cycle:
  </p>
  <ul>
    <li>
      where (frame/thread) and when thread objects (instances of <code class="nobr">java.lang.Thread</code> or its subclass)
      are created
    </li>
    <li>
      where (frame/thread) and when threads are started (<code class="nobr">Thread.start()</code> invoked)
    </li>
    <li>
      where (frame/thread) and when thread name is changed (<code class="nobr">Thread.setName()</code> invoked)
    </li>
  </ul>

  <h2>Problem detection: threads created but not started</h2>

  <p>
    The table rows represent <a href="#event_kinds">lasting events</a>.
    The event starts when thread object is created,
    and ends when thread is started.
  </p>
  <p>
    Thus, non-closed events in the table correspond to threads which has not started.
    Such threads indicate potential design flaw.
    However, note that threads actually started in native code can be shown as not started,
    because their <code class="nobr">start()</code> method is not called.
  </p>

  <h2>Problem detection: anonymous threads</h2>

  <p>
    Thread constructor allows not to specify thread name explicitly.
    Such threads get automatically generated name in form <code class="nobr">Thread-<i>&lt;number&gt;</i></code>.
  </p>

  <p>
    To improve maintainability and clearness of your application,
    avoid creating anonymous threads, specifying thread name explicitly.
  </p>

  <p>
    To check if there are anonymous threads in the profiled application,
    sort the table by name column and look for threads named <code class="nobr">Thread-<i>&lt;number&gt;</i></code>.
  </p>

  <h2>Problem detection: several threads with same name</h2>

  <p>
    Group by name column and sort by row count to check if there are threads with same name.
  </p>

  <p>
    To improve maintainability and clearness of your application,
    ensure thread names are unique.
  </p>

  <h2>Source code location</h2>

  <p>
    <code class="nobr"><i>&lt;Profiler Installation Directory&gt;</i>/probes/src</code>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='classloading'>12.3.2&nbsp;Class loading probe</h1>

  <h2>Description</h2>

  <p>
    Probe records class load and unload events.
  </p>

  <p>
    Results are available in the probes UI in tab "Class loading".
  </p>
  <figure>
    <img alt="" src="resources/classloading.png"/>
  </figure>

  <p>
    You can quickly access them from "Classes" telemetry clicking link "Detail...":
  </p>
  <figure>
    <img alt="" src="resources/classloading_link.png"/>
  </figure>

  <h2>Source code location</h2>

  <p>
    There is no source code available for this probe, as it is based on low-level JVM events,
    available via native API only (JVMTI).
  </p>

  <h2>Enabling/disabling the probe via startup options</h2>

  <p>
    This probe has no associated probe class (see above), thus a pseudo-name <code class="nobr">com.yourkit.probes.builtin.ClassLoading</code>
    should be used in corresponding <a href="#startup_options">startup options</a>,
    e.g. <code class="nobr">probe_off=com.yourkit.probes.builtin.ClassLoading</code> disables the class loading probe.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='awtevents'>12.3.3&nbsp;com.yourkit.probes.builtin.AWTEvents</h1>

  <h2>Description</h2>

  <p>
    This built-in probe records AWT/Swing events longer than 0.3 second,
    which can cause UI irresponsiveness.
  </p>

  <h2>Problem detection: irresponsive UI</h2>

  <p>
    If a long operation is performed directly in the event queue thread,
    UI may become irresponsive: do not redraw, do not accept user input etc.
  </p>

  <p>
    Good practice is to perform long operations in a separate thread,
    and use the event queue to present prepared results only.
  </p>

  <p class="hint">
    For analysis of the results provided by this probe,
    select AWT event in probes table and apply
    <a href="#cpu_usage_estimation">CPU usage estimation</a>.
  </p>

  <h2>Source code location</h2>

  <p>
    <code class="nobr"><i>&lt;Profiler Installation Directory&gt;</i>/probes/src</code>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='messages'>12.3.4&nbsp;com.yourkit.probes.builtin.Messages</h1>


  <h2>Description</h2>

  <p>
    This class is not a probe class itself nor contains probe classes.
  </p>
  <p>
    Instead, it provides a utility method to store arbitrary text messages.
  </p>
  <p>
    For this purposes, the class defined <a href="#tables">a table</a> named "Messages"
    with columns of string type, and introduces method
    <code class="nobr">public static void message(String category, String message, String detail)</code>
    which creates new row in the table and sets corresponding column values.
  </p>

  <p>
    The messages can be <a href="#probes_ui_table_messages">seen in UI</a>.
  </p>

  <h2>Source code location</h2>

  <p>
    <code class="nobr"><i>&lt;Profiler Installation Directory&gt;</i>/probes/src</code>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='probe_class'>12.4&nbsp;Probe classes</h1>

  <p>
    <i>Probe class</i> is a Java class intended to monitor execution of particular methods.
  </p>
  <p>
    Bytecode instrumentation engine will inject calls to your probes to the methods
    which you specified.
  </p>
  <p>
    You can access method parameters, method return value,
    the object for which the method is called,
    as well as intercept uncaught exceptions thrown in the method.
  </p>
  <p>
    This provides virtually unlimited capabilities to monitor applications.
    <a href="#event_method_call">Read more...</a>
  </p>

  <h2>Probe life cycle</h2>

  <ul>
    <li>
      Write the probe class(es)
    </li>
    <li>
      <a href="#compile_probes">Compile</a> the probe class(es)
    </li>
    <li>
      <a href="#register_probes">Register</a> the probe class(es) to make them work
    </li>
    <li>
      (Optional)
      To deactivate the probe in runtime, <a href="#unregister_probes">unregister</a> its class(es)
    </li>
  </ul>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='compile_probes'>12.4.1&nbsp;Compiling probe classes</h1>

  <p>
    After you have written your <a href="#probe_class">probe classes</a>,
    compile them with Java compiler (<code class="nobr">javac</code>) as regular Java classes.
  </p>

  <p>
    Please add <code class="nobr">yjp.jar</code> to the compiler class path
    to make classes in package <code class="nobr">com.yourkit.probe</code> accessible.
  </p>

  <p class="hint">
    Unlike compile time, you do not need to add <code class="nobr">yjp.jar</code> to class path in runtime.
    All necessary classes in <code class="nobr">com.yourkit.probe</code> will be automatically
    loaded by the profiler agent.
  </p>

  <p>
    Optionally, you can put compiled classes to a JAR file.
    The probe classes are self-explanatory,
    so there is no need in any additional description in the JAR file manifest.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='register_probes'>12.4.2&nbsp;Probe registration, activity modes</h1>

  <p>
    To apply a <a href="#probe_class">probe</a>, it should be registered.
  </p>

  <p>
    <a href="#builtin_probes">Built-in</a> probes are pre-compiled and are ready for registration out of the box.
    If you have written a custom probe, <a href="#compile_probes">compile</a> it before registering.
  </p>
  <p>
    There are two ways to register probes:
  </p>
  <ul>
     <li><a href="#startup">On startup</a> (via startup options)</li>
     <li><a href="#runtime">In runtime</a> (via API)</li>
  </ul>

  <h2 id="modes">Probe activity modes</h2>

  <p>
    When a probe is registered, its target classes are permanently instrumented with
    the probe callbacks, which behave depending on the probe <i>activity mode</i>:
  </p>
  <ul>
    <li>
      <p>
        <strong>On</strong>: the callbacks are active and do their job.
      </p>
    </li>
    <li>
      <p>
        <strong>Off</strong>: the callbacks are empty and do nothing.
        The effect is the same as if the probe was not registered at all.
        The probe overhead in this mode is almost negligible.
      </p>
    </li>
    <li>
      <p>
        <strong>Auto</strong>:
        the probe is active only while CPU profiling is running:
        the probe automatically turns <strong>On</strong> when CPU profiling starts
        and then automatically turns <strong>Off</strong> when CPU profiling stops.
        This mode is intended for the probes whose results are naturally associated with CPU profiling session,
        and/or would impose undesirable overhead when no profiling is being performed.
        When CPU profiling results are cleared, either by starting CPU profiling or explicitly,
        the tables of the Auto probes are automatically cleared too.
      </p>
    </li>
  </ul>

  <p>
    Initial activity mode is controlled via corresponding startup options (see below).
  </p>

  <h2 id="change">Obtaining and changing activity mode in runtime</h2>

  <ul>
    <li>
      Using the profiler UI:
      when the profiler is <a href="#connect">connected</a> to a profiled application,
      switch to the "Events" tab and press the "Manage Probes" button.
    </li>
    <li>
      Using <a href="#api">API</a>:
      use methods <code class="nobr">getProbeActivityModes()</code> and <code class="nobr">setProbeActivityModes()</code>
      of <code class="nobr">com.yourkit.api.Controller</code>
    </li>
  </ul>

  <h2 id="default_modes">Default activity modes</h2>

  <table class="tbl-with-border tbl-with-strong-thead">
    <thead>
      <tr>
        <td>Probes</td>
        <td>Default mode</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a href="#builtin_probes">JSP/Servlets, databases, files, sockets</a></td>
        <td>Auto</td>
      </tr>
      <tr>
        <td>
          <a href="#classloading">Class loading</a>,
          <a href="#threads_probe">threads</a>,
          <a href="#builtin_probes">processes</a>,
          <a href="#awtevents">AWT events</a>
        </td>
        <td>On</td>
      </tr>
      <tr>
        <td>
          <a href="#builtin_probes">JUnit and TestNG tests</a>
        </td>
        <td>On (*)</td>
      </tr>
      <tr>
        <td>user-defined probes</td>
        <td>n/a (On or Auto explicitly specified)</td>
      </tr>
    </tbody>
  </table>
  <p>(*) Only if the agent loads on start. In <a href="#attach_agent">attach mode</a> the probe is by default disabled.</p>
  <p/>

  <h2 id="startup">Probe registration on startup</h2>

  <p>
    Register probes on startup to apply them without altering the profiled application source code.
    This is especially important for applications such as Java EE servers,
    and/or production versions of the software.
  </p>

  <p>
    Also, registration on startup is the simplest way to apply probes.
  </p>

  <p>
    The following <a href="#startup_options">startup options</a> control the initial mode.
    They work for both built-in and user-defined probes.
  </p>
  <table class="tbl-with-border tbl-with-strong-thead">
    <thead>
      <tr>
        <td>Startup option</td>
        <td>Description</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>
          <p>
            <code class="nobr">probe_on</code>=<i>&lt;full qualified probe class name or pattern&gt;</i>
          </p>

          <p>
            <code class="nobr">probe_off</code>=<i>&lt;full qualified probe class name or pattern&gt;</i>
          </p>

          <p>
            <code class="nobr">probe_auto</code>=<i>&lt;full qualified probe class name or pattern&gt;</i>
          </p>
        </td>
        <td>
          <p>
            Until any of the <code class="nobr">probe_*</code> options is processed, or if none of them is specified,
            the list of probes to be registered on startup consists of the built-in probes
            in their default mode, either <strong>On</strong> or <strong>Auto</strong> (see <a href="#default_modes">table</a>).
          </p>

          <p>
            The options set the initial mode of matching probes to <strong>On</strong>, <strong>Off</strong>, <strong>Auto</strong>.
          </p>

          <p>
            If the specified full qualified name is a pattern, i.e. contains <code>*</code> as a wildcard,
            the mode of all matching probes to be registered will be changed to the specified mode.
          </p>
          <p>
            If a full qualified name without the wildcard is specified,
            the probe will be added to the list of probes to be registered,
            and its initial mode will be as the option specifies.
          </p>

          <p>
            You can later change the mode of these probes in runtime by using the UI or the API.
          </p>

          <p>
            Note:
            the order of <code class="nobr">probe_*</code> options matter:
            they are applied from left to right, and further options can override the previous ones.
          </p>
        </td>
      </tr>
      <tr>
        <td>
          <code class="nobr">probe_disable</code>=<i>&lt;full qualified probe class name or pattern&gt;</i>
        </td>
        <td>
          <p>
            Until any of the <code class="nobr">probe_*</code> options is processed, or if none of them is specified,
            the list of probes to be registered on startup consists of the built-in probes
            in their default mode, either <strong>On</strong> or <strong>Auto</strong> (see <a href="#default_modes">table</a>).
          </p>

          <p>
            <code class="nobr">probe_disable</code> removes matching probes from the list of probes to be registered on startup.
          </p>

          <p>
            This totally eliminates the matching probes: no classes will be instrumented with their callbacks.
          </p>

          <p>
            You won't be able to change the probe mode in runtime by using the UI.
            Although you will be able to use the API to register the probe in runtime,
            it's instead recommended to use the option <code class="nobr">probe_off</code> and
            activate the probe on demand by changing its mode to <strong>On</strong> or <strong>Auto</strong>.
          </p>

          <p>
            Note:
            the order of <code class="nobr">probe_*</code> options matter:
            they are applied from left to right, and further options can override the previous ones.
          </p>
        </td>
      </tr>
    </tbody>
  </table>

  <br/>

  <p>
    To specify where a custom probe class should be loaded from, use the following options:
  </p>

  <table class="tbl-with-border tbl-with-strong-thead">
    <thead>
      <tr>
        <td>Startup option</td>
        <td>Description</td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>
          <code class="nobr">probeclasspath</code>=<i>&lt;classpath&gt;</i>
        </td>
        <td>
          <p>
            Add the list of jar files and/or directories to system class path to search probe classes in.
            If several path elements are specified they should be separated with the system-specific path separator which is ';' on Windows and ':' on other platforms.
            There is no need to specify the path for <a href="#builtin_probes">built-in probes</a>.
          </p>

          <p>
            Note:
            this option alone does not automatically register any probe classes,
            it just defines where they are located.
            You must explicitly specify which probe classes to register by using
            the options <code class="nobr">probe_on</code>, <code class="nobr">probe_off</code> or <code class="nobr">probe_auto</code>.
          </p>
        </td>
      </tr>

      <tr>
        <td>
          <code class="nobr">probebootclasspath</code>=<i>&lt;classpath&gt;</i>
        </td>
        <td>
          <p>
            Add the list of jar files and/or directories to boot class path to probe classes in.
            If several path elements are specified they should be separated with the system-specific path separator which is ';' on Windows and  ':' on other platforms.
            There is no need to specify the path for <a href="#builtin_probes">built-in probes</a>.
          </p>

          <p>
            Note:
            this option alone does not automatically register any probe classes,
            it just defines where they are located.
            You must explicitly specify which probe classes to register by using
            the options <code class="nobr">probe_on</code>, <code class="nobr">probe_off</code> or <code class="nobr">probe_auto</code>.
          </p>
        </td>
      </tr>
    </tbody>
  </table>

  <br/>

  <h2>Examples</h2>

  <p>
    1. <code class="nobr">probe_on=*</code><br/>
    <br/>
    All (built-in) probes are On. This was the default behavior in the previous versions.
  </p>

  <p>
    2. <code class="nobr">probe_off=com.yourkit.probes.builtin.Databases</code><br/>
    <br/>
    <em>A short form is available for built-in probes: use a dot instead of the package name <code class="nobr">probe_off=.Databases</code></em><br/>
    <br/>
    <code class="nobr">Databases</code> probe will be Off. Other probes will be in their default mode.
  </p>

  <p>
    3. <code class="nobr">probe_disable=*,probe_on=com.foo.Bar</code><br/>
    <br/>
    Disable all built-in probes and register a user-defined probe class <code class="nobr">com.foo.Bar</code>,
    whose initial mode is On.
  </p>

  <p>
    4. <code class="nobr">probe_auto=com.foo.Bar</code><br/>
    <br/>
    Register a user-defined probe class <code class="nobr">com.foo.Bar</code>, whose initial mode is Auto.
    The built-in probes will be in their default mode.
  </p>

  <br/>

  <h2 id="runtime">Probe registration in runtime</h2>

  <p>
    Use <a href="#api">API</a> to register probes programmatically in runtime.
  </p>

  <p>
    To register the probe, invoke static method <code class="nobr">registerProbes()</code>
    of class <code class="nobr">com.yourkit.probes.Probes</code>:
  </p>
<pre><code>// register probe classes
public static void registerProbes(Class... probeClasses);

// register probe classes by class name
public static void registerProbes(String... probeClassNames);</code></pre>

  <p>
    When probes are registered by name using
    <code class="nobr">registerProbes(String...)</code>,
    the probe classes will be searched in paths specified with the help
    of startup options
    <code class="nobr">probeclasspath=<i>&lt;classpath&gt;</i></code> and
    <code class="nobr">probebootclasspath=<i>&lt;classpath&gt;</i></code> (see above).
    There is no need to specify the paths for <a href="#builtin_probes">built-in probes</a>.
  </p>

  <p>
    Using <code class="nobr">registerProbes(Class...)</code>
    you already supply loaded probe classes,
    thus no search in paths is performed.
  </p>

  <p>
    Example:
  </p>
<pre><code>import com.yourkit.probes.*;
// ...
Probes.registerProbes(MyProbe.class);
Probes.registerProbes("com.foo.Probe1", "com.foo.Probe2");</code></pre>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='unregister_probes'>12.4.3&nbsp;Probe unregistration</h1>

  <p>
    <a href="#register_probes">Registered</a> probe can be unregistered in runtime.
    This means that all methods which have been instrumented with the probe's callbacks
    will be returned to their original state.
  </p>

  <p class="hint">
    We strongly recommend to change the probe's <a href="#register_probes">activity mode</a>
    to <strong>Off</strong> instead.
  </p>

  <p>
    Probe unregistration is only possible using the profiler <a href="#api">API</a>:
    invoke static method <code class="nobr">unregisterProbes()</code> of class <code class="nobr">com.yourkit.probes.Probes</code>:
  </p>

<pre><code>public static void unregisterProbes(final String... probeClassNames);
public static void unregisterProbes(final Class... probeClasses);</code></pre>

  <h2>Examples</h2>
<pre><code>import com.yourkit.probes.*;
// ...
Probes.unregisterProbes(MyProbe.class);
Probes.unregisterProbes("com.foo.Probe1", "com.foo.Probe2");</code></pre>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='event_method_call'>12.5&nbsp;Monitoring method invocation events</h1>

  <p>
    <a href="#probe_class">Probe class</a> for monitoring method invocation events is a Java class which
    meets the following requirements:
  </p>
  <ul>
    <li>
      It must be a public class. If it is an inner class, it also must be static.
    </li>
    <li>
      <p>
        It must be annotated with <a href="#method_pattern">@MethodPattern</a> annotation
        in order to specify which methods the probe will be applied to.
      </p>
    </li>
    <li>
      <p>
        It must define at least one of the following <i>callback</i> methods (must be public static too):
      </p>
      <ul>
        <li>
          <a href="#onenter">onEnter</a> - callback to be invoked on method enter
        </li>
        <li>
          <a href="#onreturn">onReturn</a> - callback to be invoked on normal method exit
          (i.e. via <code class="nobr">return</code> or when a void method body execution completes)
        </li>
        <li>
          <a href="#onexception">onUncaughtException or onUncaughtExceptionExt</a> - callback to be invoked when the method
          execution is terminated because of an uncaught exception
        </li>
      </ul>
    </li>
  </ul>

  <p>
    Bytecode instrumentation engine will inject calls to your probes to the methods
    which you specified on probe registration.
  </p>

  <p>
    You can access method parameters, method return value,
    the object for which the method is called,
    as well as intercept uncaught exceptions thrown in the method.
    This provides virtually unlimited capabilities to monitor applications.
  </p>

  <h2>Probe life cycle</h2>

  <ul>
    <li>
      <p>
        Write the probe classes.
      </p>
      <p>
        How to write the probe class and how many probe classes you need, depends on your task.
      </p>
      <p>
        You may intend one probe class to handle one method call only,
        or you can write a probe with a pattern which corresponds to several methods which you want to handle uniformly.
        Also, you may need several probes to solve one complex task.
      </p>
      <p>
        Take a look at <a href="#builtin_probes">the built-in probes</a>
        to get some ideas on how to write your own ones.
      </p>
    </li>
    <li>
      <a href="#compile_probes">Compile</a> the probe classes.
    </li>
    <li>
      <p>
        <a href="#register_probes">Register</a> the probe classes to make them work.
      </p>
      <p>
        Upon successful registration of the probe, methods matching the probe <a href="#method_pattern">pattern</a>
        will be instrumented according to the following <a href="#probe_class_rules">rules</a>.
      </p>
    </li>
    <li>
      (Optional)
      If needed to return all instrumented methods to their original state,
      <a href="#unregister_probes">unregister</a> the probe.
    </li>
  </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='method_pattern'>12.5.1&nbsp;Probe class annotation @MethodPattern</h1>

  <p>
    <a href="#event_method_call">Probe class</a> must be annotated with <code class="nobr">@MethodPattern</code> annotation
    in order to specify which methods the callbacks will be applied to.
  </p>

  <p>
    One or more method patterns can be specified in the following format ('*' wildcard is allowed):
  </p>
  <p>
    <code class="nobr"><i>class_name</i> <strong>:</strong> <i>method_name</i> <strong>(</strong> <i>parameter_types</i> <strong>)</strong></code>
  </p>
  <p>
    You can optionally specify that class or method must have particular annotations.
    Put <code class="nobr">@annotation</code> before the class and/or the method pattern accordingly:
  </p>
  <p>
    <code class="nobr">[<i>@class_annotation</i>] <i>class_name</i> <strong>:</strong> [<i>@method_annotation</i>] <i>method_name</i> <strong>(</strong> <i>parameter_types</i> <strong>)</strong></code>
  </p>

  <table class="tbl-with-border tbl-with-strong-thead">
    <thead>
      <tr>
        <td>Part</td>
        <td width="50%">Description</td>
        <td width="40%">Examples</td>
      </tr>
    </thead>
    <tbody>
      
      <tr>
        <td><code class="nobr">class_name</code></td>
        <td>
          Full qualified class name, dot-separated.
          Inner class part(s) are separated with "$" sign.
        </td>
        <td>
          <p>
            Particular class: <code class="nobr">com.foo.Bar</code>
          </p>
          <p>
            Class with name ending with 'Helper': <code class="nobr">*Helper</code>
          </p>
          <p>
            Any class in a package: <code class="nobr">java.io.*</code>
          </p>
          <p>
            Any class: <code>*</code>
          </p>
        </td>
      </tr>

      
      <tr>
        <td><code class="nobr">class_annotation</code> (optional)</td>
        <td>
          Specify that matching classes must have particular annotation.
          If not specified, class with any annotations or with no annotations at all will match.
        </td>
        <td>
          <p>
            All <code class="nobr">toString</code> methods in classes in package <code class="nobr">com.bar</code> annotated with <code class="nobr">@Foo</code>:<br/>
            <code class="nobr">@Foo com.bar.* : toString()</code>
          </p>
        </td>
      </tr>

      
      <tr>
        <td><code class="nobr">method_name</code></td>
        <td>
          Method name.
          To specify a constructor, use <code class="nobr"><i>&lt;init&gt;</i></code>.
        </td>
        <td>
          <p>
            Method with particular name: <code class="nobr">toString</code>
          </p>
          <p>
            Any getter: <code class="nobr">get*</code>
          </p>
          <p>
            Any method, including constructors: <code>*</code>
          </p>
        </td>
      </tr>

      
      <tr>
        <td><code class="nobr">method_annotation</code> (optional)</td>
        <td>
          Specify that matching methods must have particular annotation.
          If not specified, methods with any annotations or with no annotations at all will match.
        </td>
        <td>
          <p>
            All JUnit tests: <code class="nobr">*:@org.junit.Test *()</code>
          </p>
        </td>
      </tr>

      
      <tr>
        <td><code class="nobr">parameter_types</code></td>
        <td>
          <p>
            Comma-separated list of parameter types.
            Space characters between type names and commas are allowed (but not required).
          </p>
          <p>
            Class names should be full qualified, dot-separated,
            except for
            <code class="nobr">java.lang.Object</code>,
            <code class="nobr">java.lang.Object[]</code>,
            <code class="nobr">java.lang.String</code>,
            <code class="nobr">java.lang.String[]</code>
            for which a short form is allowed:
            <code class="nobr">Object</code>,
            <code class="nobr">Object[]</code>,
            <code class="nobr">String</code>,
            <code class="nobr">String[]</code>.
          </p>
          <p>
            Primitive types should be named as in Java source code: <code class="nobr">int</code>, <code class="nobr">char</code> etc.
          </p>
          <p>
            Arrays are specified as <code class="nobr"><i>&lt;type&gt;</i>[]</code>.
          </p>
          <p>
            Use empty string to specify a method with no parameters.
          </p>
          <p>

          </p>
        </td>
        <td>
          <p>
            No parameters: empty
          </p>
          <p>
            Any number of parameters, including zero:
            <code>*</code>
          </p>
          <p>
            3 parameters of particular types:
            <code class="nobr">String, int, int</code>
          </p>
          <p>
            First parameter is an array of class com.Foo:
            <code class="nobr">com.Foo[], *</code>
          </p>
        </td>
      </tr>
    </tbody>
  </table>

  <br/>
  <p>
    The annotation is declared as...
  </p>

<pre><code>package com.yourkit.probes;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
public @interface MethodPattern {
  String[] value();
}</code></pre>

  <p>
    ...and specifies one or more patterns for a probe. For example:
  </p>

<pre><code>import com.yourkit.probes.*;

// Instrument calls of method 'findPerson' in class 'com.foo.Person', which has 2 parameters of particular types
@MethodPattern("com.foo.Person:findPerson(String, int)")
public class MyProbe1 {
  //...
}

// Instrument all methods in classes 'com.Foo' and 'com.Bar'
@MethodPattern(
  {
    // should match at least one of them
    "com.Foo:*(*)",
    "com.Bar:*(*)"
  }
)
public class MyProbe2 {
  //...
}

// Instrument methods toString() in all classes in package com.foo
@MethodPattern("com.foo.*:toString()")
public class MyProbe3 {
  //...
}

// Instrument all methods in classes whose names end with 'Helper' and have int[][] as a first parameter
@MethodPattern("*Helper:(int[][],*)")
public class MyProbe4 {
  //...
}</code></pre>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='onenter'>12.5.2&nbsp;Callback onEnter()</h1>

  <p>
    To execute a code on method entry, define callback method <code class="nobr">onEnter()</code>
    in <a href="#event_method_call">probe class</a>.
  </p>

  <p>
    Only one method named <code class="nobr">onEnter()</code> can exist in a probe class.
    You can omit <code class="nobr">onEnter()</code> method if it is not needed for your probe.
  </p>

  <h2>Parameters</h2>

  <p>
    The callback can have any number of parameters, including zero.
  </p>

  <p>
    Each of the parameters must be annotated with one of the following annotations:
  </p>

  <ul>
    <li><a href="#annot_param">@Param</a></li>
    <li><a href="#annot_params">@Params</a></li>
    <li><a href="#annot_this">@This</a></li>
    <li><a href="#annot_classref">@ClassRef</a></li>
    <li><a href="#annot_methodname">@MethodName</a></li>
    <li><a href="#annot_methodparametertypes">@MethodParameterTypes</a></li>
    <li><a href="#annot_methodsignature">@MethodSignature</a></li>
  </ul>

  <br/>

  <h2>Return type</h2>

  <p>
    <code class="nobr">onEnter()</code> can be void or return a value.
  </p>
  <p>
    If <code class="nobr">onEnter()</code> is not void,
    the returned value will be accessible
    in <a href="#onreturn">onReturn()</a>,
    <a href="#onexception">onUncaughtException()</a> and
    <a href="#onexception">onUncaughtExceptionExt()</a>
    callbacks of the same probe class with the help of
    a parameter annotated with <a href="#annot_onenterresult">@OnEnterResult</a>.
    This approach enables effective way of data transfer
    between method enter and exit callbacks
    (the value is passed via stack).
  </p>

  <p>
    Example 1:
  </p>

<pre><code>import com.yourkit.probes.*;

// Instrument calls of method 'findPerson' in class 'com.foo.Person', which has 2 parameters
@MethodPattern("com.foo.Person:findPerson(String, int)")
public class MyProbe {
  public static void onEnter(
    @Param(1) Object param1,
    @Param(2) int param2
  ) {
    //...
  }
}</code></pre>

  <p>
    Example 2:
  </p>

<pre><code>import com.yourkit.probes.*;

// Instrument calls of method(s) 'findPerson' in class 'com.foo.Person', with any signature,
// and print method execution times
@MethodPattern("com.foo.Person:findPerson(*)")
public class MyProbe {
  public static long onEnter() {
    return System.currentTimeMillis();
  }

  public static void onReturn(
    @OnEnterResult long enterTime
  ) {
    long exitTime = System.currentTimeMillis();
    System.out.println("method execution time: " + (exitTime - enterTime));
  }
}</code> </pre>

  <h2 id="constructor">Special notes on instrumenting a constructor</h2>

  <p>
    Using callback parameter annotated with <code class="nobr">@This</code>
    in a probe applied to a constructor affects
    the point where the call to <code class="nobr">onEnter()</code> is injected.
    Please find detail <a href="#constructor">here</a>.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='onreturn'>12.5.3&nbsp;Callback onReturn()</h1>

  <p>
    To execute a code when method normally exits
    (i.e. via <code class="nobr">return</code> or when a void method body execution completes),
    define callback method <code class="nobr">onReturn()</code>
    in <a href="#event_method_call">probe class</a>.
  </p>

  <p>
    Only one method named <code class="nobr">onReturn()</code> can exist in a probe class.
    You can omit <code class="nobr">onReturn()</code> method if it is not needed for your probe.
  </p>

  <h2>Parameters</h2>

  <p>
    The callback can have any number of parameters, including zero.
  </p>

  <p>
    Each of the parameters must be annotated with one of the following annotations:
  </p>

  <ul>
    <li><a href="#annot_param">@Param</a></li>
    <li><a href="#annot_params">@Params</a></li>
    <li><a href="#annot_this">@This</a></li>
    <li><a href="#annot_classref">@ClassRef</a></li>
    <li><a href="#annot_methodname">@MethodName</a></li>
    <li><a href="#annot_methodparametertypes">@MethodParameterTypes</a></li>
    <li><a href="#annot_methodsignature">@MethodSignature</a></li>
    <li><a href="#annot_onenterresult">@OnEnterResult</a></li>
    <li><a href="#annot_returnvalue">@ReturnValue</a></li>
  </ul>

  <h2>Return type</h2>

  <p>
    <code class="nobr">onReturn()</code> can be void or return a value.
  </p>

  <p>
    If <code class="nobr">onReturn()</code> is void, the original return value will be returned.
  </p>

  <p>
    The following pseudo-code demonstrates how the callback works:
  </p>

  <p>
    Before instrumentation:
  </p>
<pre><code>ReturnType foo() {
  bar(); // do something
  return result;
}</code></pre>

  <p>
    After instrumentation with <code class="nobr">void onReturn()</code>:
  </p>
<pre><code>ReturnType foo() {
  bar(); // do something
  SomeProbeClass.onReturn(...);
  return result;
}</code></pre>

  <p>
    Declare <code class="nobr">onReturn()</code> as non-void to change the value
    returned from the instrumented method.
    If <code class="nobr">onReturn()</code> is non-void, its return type must
    be the same as the return type of method to be instrumented.
    If the types mismatch, the probe will not be applied to the method.
    If needed, access the original return value with the help of <a href="#annot_returnvalue">@ReturnValue</a>
    annotated parameter, and optionally return the original return value or a different value.
  </p>

  <p class="hint">
    The capability to change return value
    has more to do with debugging than with monitoring or profiling,
    as it affects application logic.
    Be very careful: inappropriate use can break the application.
  </p>

  <p>
    After instrumentation with <code class="nobr">ReturnType onReturn()</code>:
  </p>
<pre><code>ReturnType foo() {
  bar(); // do something
  return SomeProbeClass.onReturn(...); // return value must be ReturnType
}</code></pre>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='onexception'>12.5.4&nbsp;Callbacks onUncaughtException() and onUncaughtExceptionExt()</h1>

  <p>
    To execute a code when method terminates because of an uncaught exception (a throwable),
    define callback method <code class="nobr">onUncaughtException()</code> or <code class="nobr">onUncaughtExceptionExt()</code>
    in <a href="#event_method_call">probe class</a>.
  </p>

  <p>
    Only one method named <code class="nobr">onUncaughtException()</code> or <code class="nobr">onUncaughtExceptionExt()</code>
    can exist in a probe class.
    You can omit these callback methods if uncaught exception handling is not needed for your probe.
  </p>

  <h2>Difference between onUncaughtException() and onUncaughtExceptionExt()</h2>

  <p>
    <code class="nobr">onUncaughtException()</code> is intended to monitor possible uncaught exceptions
    without changing the logic of instrumented code.
    After the callback returns, the exception will be automatically re-thrown.
  </p>

  <p>
    <code class="nobr">onUncaughtExceptionExt()</code> does not automatically re-throw
    the original exception.
    This provides an opportunity to alter instrumented code behavior
    by suppressing the exception and, for a non-void method,
    returning a value instead.
  </p>

  <p class="hint">
    The capabilities provided with <code class="nobr">onUncaughtExceptionExt()</code>
    have more to do with debugging than with monitoring or profiling,
    as they affect application logic.
    Be very careful: inappropriate use can break the application.
  </p>

  <h2>Parameters</h2>

  <p>
    The callback can have any number of parameters, including zero.
  </p>

  <p>
    Each of the parameters must be annotated with one of the following annotations:
  </p>

  <ul>
    <li><a href="#annot_param">@Param</a></li>
    <li><a href="#annot_params">@Params</a></li>
    <li><a href="#annot_this">@This</a></li>
    <li><a href="#annot_classref">@ClassRef</a></li>
    <li><a href="#annot_methodname">@MethodName</a></li>
    <li><a href="#annot_methodparametertypes">@MethodParameterTypes</a></li>
    <li><a href="#annot_methodsignature">@MethodSignature</a></li>
    <li><a href="#annot_onenterresult">@OnEnterResult</a></li>
    <li><a href="#annot_thrownexception">@ThrownException</a></li>
</ul>

  <br/>
  <h2>Return type of onUncaughtException</h2>

  <p>
    <code class="nobr">onUncaughtException()</code> must be void.
  </p>

  <p>
    Technically, <code class="nobr">onUncaughtException()</code> is called inside
    try/finally block surrounding instrumented method body:
  </p>

  <ul>
    <li>
      After <code class="nobr">onUncaughtException()</code> returns,
      the exception will be automatically re-thrown
    </li>
    <li>
      If an uncaught exception happens inside <code class="nobr">onUncaughtException()</code> body,
      it will be thrown instead of the original exception
    </li>
  </ul>

  <p>
    The following pseudo-code demonstrates how the callback works:
  </p>

  <p>
    Before instrumentation:
  </p>
<pre><code>ReturnType foo() {
  bar(); // do something
  return result;
}</code></pre>

  <p>
    After instrumentation with <code class="nobr">onUncaughtException()</code>:
  </p>
<pre><code>ReturnType foo() {
  try {
    bar(); // do something
    return result;
  }
  catch (Throwable e) {
    SomeProbeClass.onUncaughtException(...);
    throw e; // automatically re-throw original exception
  }
}</code></pre>

  <h2>Return type of onUncaughtExceptionExt</h2>

  <p>
    <code class="nobr">onUncaughtExceptionExt()</code> return type must
    be the same as the return type of method to be instrumented.
    If the types mismatch, the probe will not be applied to the method.
  </p>

  <p>
    The following pseudo-code demonstrates how the callback works:
  </p>

  <p>
    Before instrumentation:
  </p>
<pre><code>ReturnType foo() {
  bar(); // do something
  return result;
}</code></pre>

  <p>
    After instrumentation with <code class="nobr">onUncaughtExceptionExt()</code>:
  </p>
<pre><code>ReturnType foo() {
  try {
    bar(); // do something
    return result;
  }
  catch (Throwable e) {
    // may throw exception or return a value
    return SomeProbeClass.onUncaughtExceptionExt(...); // return value must be ReturnType
  }
}</code></pre>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='annot_param'>12.5.5&nbsp;Callback method parameter annotation @Param</h1>

  <p>
    Callback parameter annotated with <code class="nobr">@Param(<i>&lt;number&gt;</i>)</code>
    provides the value of the instrumented method parameter with given number.
    Parameters are numbered starting with 1.
  </p>

  <h2>In which callbacks can be used</h2>

  <p>
    Parameter annotated with <code class="nobr">@Param(<i>&lt;number&gt;</i>)</code> can be used in <a href="#event_method_call">any callback</a>.
  </p>

  <p>
    If the callback parameter is used in
    <a href="#onreturn">onReturn()</a>,
    <a href="#onexception">onUncaughtException()</a> or
    <a href="#onexception">onUncaughtExceptionExt()</a>
    the original value of the instrumented method parameter variable will be provided,
    even if the parameter variable was modified inside the instrumented method body.
  </p>

  <p>
    However, note that parameter of a reference type can refer an object
    which state is modified inside the instrumented method body.
    In this case, if you need the original state, access the parameter in <a href="#onenter">onEnter()</a>.
  </p>

  <p>
    The following code snippet illustrates the rules:
  </p>
<pre><code>// Class being instrumented
class Foo {
  void bar(StringBuffer buffer, Object obj, int number) {
    buffer.append("some string"); // change object state
    obj = null; // modify parameter variable
    ++number; // modify parameter variable
  }
}

//...

// Probe class which instruments Foo.bar()
@MethodPattern("Foo:bar(java.lang.StringBuffer, Object, int)")
public class MyProbe {
  public static void onEnter(
    @Param(1) StringBuffer buffer
    @Param(2) Object obj,
    @Param(3) int number
  ) {
    System.out.println(buffer.toString()); // will print original 'buffer' content
    System.out.println(obj); // will print original 'obj'
    System.out.println(number); // will print original 'number'
  }

  public static void onExit(
    @Param(1) StringBuffer buffer
    @Param(2) Object obj,
    @Param(3) int number
  ) {
    System.out.println(buffer.toString()); // will print modified 'buffer' content
    System.out.println(obj); // will print original 'obj' (not null)
    System.out.println(number); // will print original 'number'
  }
}</code></pre>

  <h2>Parameter count mismatch</h2>

  <p>
    If parameter number in <code class="nobr">@Param(<i>&lt;number&gt;</i>)</code> is bigger than the actual number
    of method parameters,
    it will be assigned with <code class="nobr">null</code>, if declared as a reference type,
    or with 0, if declared as primitive type.
  </p>

  <h2>Declaration type</h2>

  <p>
    Parameter annotated with <code class="nobr">@Param(<i>&lt;number&gt;</i>)</code>
    can be declared as a reference type or as a primitive type.
  </p>

  <p>
    If the callback parameter is declared as <code class="nobr">java.lang.Object</code>,
    it will be assigned with object reference as is if the actual parameter type is a reference type,
    or with a boxed value if the actual parameter type is primitive.
  </p>

  <p>
    If the callback parameter
    is declared as some reference type other than <code class="nobr">java.lang.Object</code>,
    it will be assigned with the actual method parameter value only if it is declared as strictly the same type.
    Otherwise the callback parameter value will be <code class="nobr">null</code>.
  </p>

  <p>
    If the callback parameter is declared as a primitive type,
    it will be assigned with the actual method parameter value only if it is declared as strictly the same type.
    Otherwise it will be assigned with 0; no type conversions will be performed.
    For example, <code class="nobr">int</code> will not be cast to <code class="nobr">long</code>.
  </p>

  <table class="tbl-with-border tbl-with-strong-thead">
    <thead>
      <tr>
        <td>
          Type of callback parameter annotated with @Param
        </td>
        <td>
          Actual instrumented method parameter type
        </td>
        <td>
          Resulting value of the callback parameter
        </td>
      </tr>
    </thead>
    <tbody>
     <tr>
       <td rowspan="2"><code class="nobr">java.lang.Object</code></td>
       <td>any reference type</td>
       <td>the value as is</td>
     </tr>
     <tr>
       <td>any primitive type</td>
       <td>a boxed value</td>
     </tr>

     <tr>
       <td rowspan="2">some reference type <code class="nobr">T1</code> other than <code class="nobr">java.lang.Object</code></td>
       <td>same reference type <code class="nobr">T1</code></td>
       <td>the value as is</td>
     </tr>
     <tr>
       <td>any reference or primitive type <code class="nobr">T2 != T1</code></td>
       <td>null</td>
     </tr>

     <tr>
       <td rowspan="2">some primitive type <code class="nobr">T1</code></td>
       <td>same primitive type <code class="nobr">T1</code></td>
       <td>the value as is</td>
     </tr>
     <tr>
       <td>any reference or primitive type <code class="nobr">T2 != T1</code></td>
       <td>0</td>
     </tr>
    </tbody>
  </table>

  <br/>
  <p class="hint">
    Note: The type matching rules for <code class="nobr">@Param</code> are similar
    to ones for <a href="#annot_returnvalue">@ReturnValue</a>
    and differ from the rules for <a href="#annot_this">@This</a>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='annot_params'>12.5.6&nbsp;Callback method parameter annotation @Params</h1>

  <p>
    Callback parameter annotated with <code class="nobr">@Params</code>
    provides the values of all parameters passed to the instrumented method.
  </p>

  <h2>In which callbacks can be used</h2>

  <p>
    Parameter annotated with <code class="nobr">@Params</code> can be used in <a href="#event_method_call">any callback</a>.
  </p>

  <h2>Declaration type</h2>

  <p>
    Parameter annotated with <code class="nobr">@Params</code> must be declared as <code class="nobr">java.lang.Object[]</code>.
  </p>

  <h2>Description</h2>

  <p>
    Parameter annotated with <code class="nobr">@Params</code> will be assigned with a newly created array
    with length equal to the number of method parameters.
    First parameter is stored in the array at index 0, second parameter - at index 1 etc.
    If instrumented method has no parameters, parameter annotated with <code class="nobr">@Params</code>
    will be assigned with an empty array.
  </p>

  <p>
    Parameters of reference types will be stored as is.
    Parameters of primitive types will be stored boxed.
  </p>

  <p>
    Note, that each time a callback with parameter annotated with <code class="nobr">@Params</code>
    is invoked, a new array is created.
    For performance considerations,
    use <a href="#annot_param">@Param({number})</a> instead whenever possible.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='annot_this'>12.5.7&nbsp;Callback method parameter annotation @This</h1>

  <p>
    Callback parameter annotated with <code class="nobr">@This</code>
    will be assigned with a reference to the object whose method is being executed.
  </p>

  <h2>Declaration type</h2>

  <p>
    Callback parameter annotated with <code class="nobr">@This</code>
    should be declared as a reference type,
    capable to store a reference to the objects whose method(s) the probe is applied to.
  </p>

  <p>
    To make the probe applicable to any method (even static!),
    declare the callback parameter as <code class="nobr">java.lang.Object</code>.
    If needed, cast the value to appropriate class in the callback body.
  </p>

  <p>
    If the callback parameter
    is declared as some reference type <code>T</code> other than <code class="nobr">java.lang.Object</code>,
    the probe callbacks will only be called for methods of class <code>T</code>
    or of a class which extends <code>T</code> or implements <code>T</code>.
    In particular this means that callback with parameter annotated with <code class="nobr">@This</code>
    declared as <code class="nobr">T != java.lang.Object</code> will never be called for a static method.
  </p>

  <h2>In which callbacks can be used</h2>

  <p>
    Parameter annotated with <code class="nobr">@This</code> can be used in <a href="#event_method_call">any callback</a>.
  </p>

  <p>
    However, if more than one probe callback
    has parameters annotated with <code class="nobr">@This</code>,
    all of them must be declared as same type.
  </p>

<pre><code>@MethodPattern("*:findPerson(*)")
public class GoodProbe1 {
  public static void onEnter() {/*....*/} // will only be called to methods of Person (because of onReturn()'s parameter)
  public static void onReturn(@This Person person) {/*...*/} // will only be called to methods of Person
}

@MethodPattern("*:foo(*)")
public class GoodProbe2 {
  public static void onEnter(@This Object _this) {/*....*/} // will be called to any methods matching the pattern
  public static void onReturn(@This Object _this) {/*...*/} // will be called to any methods matching the pattern
}

@MethodPattern("*:bar(*)")
public class BadProbe2 { // the probe is invalid - @This type mismatch
  public static void onEnter(@This Object _this) {/*....*/}
  public static void onUncaughtException(@This String _this) {/*...*/}
}</code></pre>

  <h2>Special notes on instrumenting a static method</h2>

  <p>
    If callback is applied to a static method,
    parameter annotated with <code class="nobr">@This</code> will be <code class="nobr">null</code>.
  </p>

  <h2 id="constructor">Special notes on instrumenting a constructor</h2>

  <p>
    If probe is applied to a constructor,
    it may be important to account all activity in super constructors,
    e.g. to properly measure the constructor execution time
    or handle nested events should the constructor execution be considered
    <a href="#event_kinds">a lasting event</a>.
  </p>

  <p>
    However, the bytecode verifier forbids access to the object reference
    before the constructor of its superclass (<code class="nobr">super(...);</code>)
    or another constructor of the same class (<code class="nobr">this(...);</code>) is invoked.
  </p>

  <p>
    Hence using callback parameter annotated with <code class="nobr">@This</code>
    in a probe applied to a constructor affects
    the point where the call to <a href="#onenter">onEnter()</a> is injected,
    as well as the scope of exceptions monitored via
    <a href="#onexception">onUncaughtException()</a> or
    <a href="#onexception">onUncaughtExceptionExt()</a>.
    See the table below for detail.
  </p>

  <table class="tbl-with-border">
    <thead>
      <tr>
        
        <td/>
        <td width="40%">
          If <code class="nobr">@This</code> is used in <a href="#onenter">onEnter()</a>, or
          <a href="#onexception">onUncaughtException()</a>, or
          <a href="#onexception">onUncaughtExceptionExt()</a>, or
          if <code class="nobr">@This</code> declared as non-<code class="nobr">java.lang.Object</code>
          is used in <a href="#onreturn">onReturn()</a>
        </td>
        <td width="40%">
          Otherwise
        </td>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code class="nobr">onEnter()</code> injection point</td>
        <td>
          <a href="#onenter">onEnter()</a> will be called
          right after the call to <code class="nobr">super(...)</code> or <code class="nobr">this(...)</code>
        </td>
        <td>
          <a href="#onenter">onEnter()</a> will be injected at the very start of the constructor,
          i.e. before the call to <code class="nobr">super(...)</code> or <code class="nobr">this(...)</code>
        </td>
      </tr>

      <tr>
        <td><code class="nobr">onUncaughtException()</code> or <code class="nobr">onUncaughtExceptionExt()</code> monitored scope</td>
        <td>
          The scope of monitored exceptions
          will start right after the call to <code class="nobr">super(...)</code> or <code class="nobr">this(...)</code>
        </td>
        <td>
          The scope of monitored exceptions
          will be the whole method,
          i.e. will include the call to <code class="nobr">super(...)</code> or <code class="nobr">this(...)</code>
        </td>
      </tr>
    </tbody>
  </table>

  <br/>

  <p>
    In particular, this means that using <code class="nobr">@This</code> may not let to
    monitor what happens inside <code class="nobr">super(...)</code> or <code class="nobr">this(...)</code>.
  </p>

  <p>
    If you need both <a href="#onenter">onEnter()</a> and <a href="#onreturn">onReturn()</a>
    and want to avoid this limitation,
    do not use <code class="nobr">@This</code> in <a href="#onenter">onEnter()</a>;
    use it in <a href="#onreturn">onReturn()</a> only and declare it as <code class="nobr">java.lang.Object</code>.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='annot_classref'>12.5.8&nbsp;Callback method parameter annotation @ClassRef</h1>

  <p>
    Callback parameter annotated with <code class="nobr">@ClassRef</code>
    will be assigned with a reference to the class where the method being executed is defined.
  </p>

  <h2>Declaration type</h2>

  <p>
    Callback parameter annotated with <code class="nobr">@ClassRef</code>
    should be declared as <code class="nobr">java.lang.Class</code>.
  </p>

  <h2>In which callbacks can be used</h2>

  <p>
    Parameter annotated with <code class="nobr">@ClassRef</code> can be used in <a href="#event_method_call">any callback</a>.
  </p>

  <h2>Notes on using @ClassRef vs @This</h2>

  <p>
    Use <code class="nobr">@ClassRef</code> when applying probe to static methods,
    because <a href="#annot_this">@This</a> is <code class="nobr">null</code> in that case.
  </p>

  <p>
    When applying probe to non-static methods,
    you can either use <code class="nobr">@ClassRef</code> or
    call <code class="nobr">getClass()</code> method of the object passed via <a href="#annot_this">@This</a>.
  </p>

  <p>
    However, please note the difference:
    the class returned by <code class="nobr">getClass()</code>
    method will be the actual class of the object whose method is running,
    while <code class="nobr">@ClassRef</code> will give the class where the method is defined.
    The result will be different if the method is defined in a base class
    and is not overridden in derived classes.
  </p>

  <p>
    Example:
  </p>
<pre><code>package com.foo;

class Base {
  void f() {...}
  void g() {...}
}

class Derived extends Base {
 // f() is overridden, g() is not overridden
 void f() {...}
}

...

@MethodPattern("foo.bar.*:*(*)")
public class MyProbe {
  public static void onEnter(@This Base _this, @ClassRef Class _class) {
    System.out.println(_this.getClass());
    System.out.println(_class);
  }
}

...

Derived obj = new Derived();

// Applying MyProbe to this call will print:
// class com.foo.Derived
// class com.foo.Derived
obj.f();

// Applying MyProbe to this call will print:
// class com.foo.Derived
// class com.foo.Base
obj.g();</code></pre>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='annot_methodname'>12.5.9&nbsp;Callback method parameter annotation @MethodName</h1>

  <p>
    Callback parameter annotated with <code class="nobr">@MethodName</code>
    will be assigned with the name of the method being executed.
  </p>

  <p>
    For constructors, the name will be <code class="nobr"><i>&lt;init&gt;</i></code>.
  </p>

  <h2>Declaration type</h2>

  <p>
    Callback parameter annotated with <code class="nobr">@MethodName</code>
    should be declared as <code class="nobr">java.lang.String</code>.
  </p>

  <h2>In which callbacks can be used</h2>

  <p>
    Parameter annotated with <code class="nobr">@MethodName</code> can be used in <a href="#event_method_call">any callback</a>.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='annot_methodparametertypes'>12.5.10&nbsp;Callback method parameter annotation @MethodParameterTypes</h1>

  <p>
    Callback parameter annotated with <code class="nobr">@MethodParameterTypes</code>
    will be assigned with the list of parameter types of the method being executed.
  </p>

  <h2>Declaration type</h2>

  <p>
    Callback parameter annotated with <code class="nobr">@MethodParameterTypes</code>
    should be declared as <code class="nobr">java.lang.String</code>.
  </p>

  <h2>In which callbacks can be used</h2>

  <p>
    Parameter annotated with <code class="nobr">@MethodParameterTypes</code> can be used in <a href="#event_method_call">any callback</a>.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='annot_methodsignature'>12.5.11&nbsp;Callback method parameter annotation @MethodSignature</h1>

  <p>
    Callback parameter annotated with <code class="nobr">@MethodSignature</code>
    will be assigned with the signature of the method being executed.
  </p>

  <h2>Declaration type</h2>

  <p>
    Callback parameter annotated with <code class="nobr">@MethodSignature</code>
    should be declared as <code class="nobr">java.lang.String</code>.
  </p>

  <h2>In which callbacks can be used</h2>

  <p>
    Parameter annotated with <code class="nobr">@MethodSignature</code> can be used in <a href="#event_method_call">any callback</a>.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='annot_onenterresult'>12.5.12&nbsp;Callback method parameter annotation @OnEnterResult</h1>

  <p>
    Callback parameter annotated with <code class="nobr">@OnEnterResult</code>
    will be assigned with a value returned from <a href="#onenter">onEnter()</a>
    defined in the same probe class.
    This approach enables effective way of data transfer
    between method enter and exit callbacks
    (the value is stored in the stack).
  </p>

  <h2>In which callbacks can be used</h2>

  <p>
    Parameter annotated with <code class="nobr">@OnEnterResult</code>
    can be used in <a href="#onreturn">onReturn()</a>,
    <a href="#onexception">onUncaughtException()</a> and
    <a href="#onexception">onUncaughtExceptionExt()</a>,
    and only if the probe class has non-void <a href="#onenter">onEnter()</a>
    defined.
  </p>

  <h2>Declaration type</h2>

  <p>
    Parameter annotated with <code class="nobr">@OnEnterResult</code> must be declared with the same
    type as the return type of <a href="#onenter">onEnter()</a>.
    If <a href="#onenter">onEnter()</a> is declared void,
    <code class="nobr">@OnEnterResult</code> cannot be used.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='annot_returnvalue'>12.5.13&nbsp;Callback method parameter annotation @ReturnValue</h1>

  <p>
    Callback parameter annotated with <code class="nobr">@ReturnValue</code>
    provides the instrumented method's return value.
  </p>

  <h2>In which callbacks can be used</h2>

  <p>
    Parameter annotated with <code class="nobr">@ReturnValue</code> can be used in
    <a href="#onreturn">onReturn()</a> only.
  </p>

  <h2>Declaration type</h2>

  <p>
    Parameter annotated with <code class="nobr">@ReturnValue</code>
    can be declared as a reference type or as a primitive type.
  </p>

  <p>
    If the callback parameter is declared as <code class="nobr">java.lang.Object</code>,
    it will be assigned with object reference as is if the actual parameter type is a reference type,
    or with a boxed value if the actual parameter type is primitive.
  </p>

  <p>
    If the callback parameter
    is declared as some reference type other than <code class="nobr">java.lang.Object</code>,
    it will be assigned with the actual method parameter value only if it is declared as strictly the same type.
    Otherwise the callback parameter value will be <code class="nobr">null</code>.
  </p>

  <p>
    If the callback parameter is declared as a primitive type,
    it will be assigned with the actual method parameter value only if it is declared as strictly the same type.
    Otherwise it will be assigned with 0; no type conversions will be performed.
    For example, <code class="nobr">int</code> will not be cast to <code class="nobr">long</code>.
  </p>

  <table class="tbl-with-border tbl-with-strong-thead">
    <thead>
      <tr>
        <td>
          Type of callback parameter annotated with @ReturnValue
        </td>
        <td>
          Actual instrumented method return value type
        </td>
        <td>
          Resulting value of the callback parameter
        </td>
      </tr>
    </thead>
     <tbody>
       <tr>
         <td rowspan="3"><code class="nobr">java.lang.Object</code></td>
         <td>any reference type</td>
         <td>the value as is</td>
       </tr>
       <tr>
         <td>any primitive type</td>
         <td>a boxed value</td>
       </tr>
       <tr>
         <td>void</td>
         <td>null</td>
       </tr>

       <tr>
         <td rowspan="3">some reference type <code class="nobr">T1</code> other than <code class="nobr">java.lang.Object</code></td>
         <td>same reference type <code class="nobr">T1</code></td>
         <td>the value as is</td>
       </tr>
       <tr>
         <td>any reference or primitive type <code class="nobr">T2 != T1</code></td>
         <td>null</td>
       </tr>
       <tr>
         <td>void</td>
         <td>null</td>
       </tr>

       <tr>
         <td rowspan="3">some primitive type <code class="nobr">T1</code></td>
         <td>same primitive type <code class="nobr">T1</code></td>
         <td>the value as is</td>
       </tr>
       <tr>
         <td>any reference or primitive type <code class="nobr">T2 != T1</code></td>
         <td>0</td>
       </tr>
       <tr>
         <td>void</td>
         <td>0</td>
       </tr>
    </tbody>
  </table>

  <br/>
  <p class="hint">
    Note: The type matching rules for <code class="nobr">@ReturnValue</code> are similar
    to ones for <a href="#annot_param">@Param</a>
    and differ from the rules for <a href="#annot_this">@This</a>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='annot_thrownexception'>12.5.14&nbsp;Callback method parameter annotation @ThrownException</h1>

  <p>
    Callback parameter annotated with <code class="nobr">@ThrownException</code>
    provides the uncaught exception instance thrown in the instrumented method.
  </p>

  <h2>In which callbacks can be used</h2>

  <p>
    Parameter annotated with <code class="nobr">@ThrownException</code> can only be used in
    <a href="#onexception">onUncaughtException()</a> or
    <a href="#onexception">onUncaughtExceptionExt()</a>.
  </p>

  <h2>Declaration type</h2>

  <p>
    Parameter annotated with <code class="nobr">@ThrownException</code> must be declared as <code class="nobr">java.lang.Throwable</code>.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='probe_class_rules'>12.5.15&nbsp;Probe application rules</h1>

  <p>
    The following describes rules which define whether
    <a href="#event_method_call">a probe class</a> will be applied to particular method.
  </p>

  <h2>Probe validation on registration</h2>

  <p>
    On probe <a href="#register_probes">registration</a>
    its annotation, callbacks and their parameters are validated.
    If any violations of the specification are found,
    the probe is not registered, and thus will not be applied to any methods.
  </p>

  <h2>Both loaded and new classes will be instrumented</h2>

  <p>
    The probe will be applied to methods of classes which have been loaded
    at the moment of probe registration,
    as well as of classes loaded afterwards.
  </p>

  <h2>Which methods will be instrumented</h2>

  <p>
    The probe's callback(s) are applied to methods that match the
    probe's <a href="#method_pattern">method pattern</a>.
  </p>
  <p>
    If there is a mismatch in number and/or type of parameters
    of an instrumented method and callback parameters annotated with
    <a href="#annot_param">@Param</a>,
    the callback will be called anyway, passing <code class="nobr">null</code> or 0
    for missing parameters.
    Please read about <a href="#annot_param">@Param</a> for detail.
  </p>
  <p>
    If there is a mismatch in return type
    of an instrumented method and callback parameter annotated with
    <a href="#annot_returnvalue">@ReturnValue</a>,
    the callback will be called anyway, passing <code class="nobr">null</code> or 0
    as the callback parameter value.
    Please read about <a href="#annot_returnvalue">@ReturnValue</a> for detail.
  </p>
  <p>
    If callbacks have parameter annotated with <a href="#annot_this">@This</a>
    not declared as <code class="nobr">java.lang.Object</code>,
    the callbacks will be called for instances of corresponding classes only.
    Please read about <a href="#annot_this">@This</a> for detail.
  </p>
  <p>
    Also, there are special requirements for non-void <a href="#onreturn">onReturn()</a>
    and <a href="#onexception">onExceptionExt()</a> callbacks.
    Please read the callback descriptions for detail.
  </p>

  <h2>Probe unregistration</h2>

  <p>
    If probe is <a href="#unregister_probes">unregistered</a> in runtime,
    all methods which have been instrumented with its callbacks
    will be returned to their original state.
  </p>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='data_storage'>12.6&nbsp;Data storage</h1>


<p>
  Data storage allows you to uniformly record the following information for each event:
</p>
<ul>
  <li>Where it happened: stack trace, thread</li>
  <li>When it happened: process uptime</li>
  <li>Event-specific numerical or text information.
    For example, this can be a number of bytes written to a stream,
    or an URL string of request being processed etc. - you can record whatever you want.
  </li>
</ul>
<p>
  This information will be available as telemetry when you connect to the monitored application,
  as well as saved in captured snapshots.
</p>
<p>
  The UI will provide rich set of tools to analyze the gathered information,
  or to export it for external processing.
</p>
<p>
  Although it is intended to use the storage to gather information,
  if you wish you can also store it your own way, e.g. write it to your application's log,
  to a file or simply write to console.
</p>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='tables'>12.6.1&nbsp;Tables, rows, columns</h1>

  <p>
    Conceptually, the storage is based on
    <a class="ext" href="http://en.wikipedia.org/wiki/Relational_model">the relation database model</a>.
  </p>

  <p>
    The information is stored in <i>tables</i>.
  </p>

  <p>
    Each table has fixed number of <i>columns</i> and arbitrary number of <i>rows</i>.
  </p>

  <p>
    Each column can store values of particular type, which is specified on table creation.
    Supported types are: <code class="nobr">int</code>, <code class="nobr">long</code>, <code class="nobr">String</code>.
    Also, column can refer to particular row in another table;
    such columns are called foreign keys.
  </p>

  <p>
    Each column has a name which is a free form text describing column content
    when table data is presented to user.
  </p>

  <p>
    The number of columns, their types and names are specified on table creation and cannot be changed afterwards.
  </p>

  <p>
    Each row stores information for all columns according to their data types.
  </p>

  <p>
    When table is created, it contains no rows.
    New rows can be added and existing rows updated. Row removal is not supported.
  </p>

  <p>
    Rows are numbered starting with 1.
    This number is called <i>row index</i>.
  </p>

  <p>
    The number of rows is limited via startup option
    <a href="#probetablelengthlimit">probetablelengthlimit</a>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='event_kinds'>12.6.2&nbsp;Lasting events and point events</h1>

  <h2>Event kinds</h2>

  <p>
    Each table row contains information on some event.
  </p>

  <p>
    There are two kinds of events:
  </p>
  <ul>
    <li>
      <strong>Lasting event:</strong>
      this is something which lasts in time.
      At some point in time it starts, and at a later point in time it ends.
      The lasting event duration can be measured as end time minus start time.
    </li>
    <li>
      <strong>Point event:</strong>
      this is some "fact" which just happens at some point of time.
      The concept of duration is not applicable for the point events.
    </li>
  </ul>

  <h2>Which kind to use?</h2>

  <p>
    Whether particular event is lasting event or point event,
    depends on your tasks.
  </p>

  <p>
    For example, you may think of method <code class="nobr">Foo.bar()</code>
    execution as of a lasting event,
    which starts when the method enters and ends when the method exits,
    if you are interested to know how long the method execution takes,
    or to discover other events which happen while <code class="nobr">Foo.bar()</code> is running,
    e.g. what kind of I/O it performs, whether it accesses database or other resources etc.
  </p>
  <p>
    In case you are only interested in <code class="nobr">Foo.bar()</code> invocations as in a fact,
    you may think of them as of point events.
  </p>

  <h2>Technical detail</h2>

  <p>
    On <a href="#table_api">table creation</a>,
    you decide which kind of events the table is intended for,
    specifying appropriate parameters of the table object constructor.
  </p>

  <p>
    So, each table can store either of the event kinds.
  </p>

  <p>
    A lasting event starts when table row is created with <code class="nobr">Table.createRow()</code>
    and ends when the row is closed with <code class="nobr">Table.closeRow()</code>.
    <code class="nobr">Table.closeRow()</code> must not be used for tables with point events.
  </p>

  <p>
    Thread, stack trace and/or times are recorded for all events on row creation,
    and also on row closing for lasting events.
  </p>

  <p>
    For lasting events recorded as some table rows it is possible to find rows
    in other tables which correspond to events which happened <i>during</i> the lasting event.
    For example, if processing of JSP pages is recorded as lasting events in some table,
    and database access events are recorded in another table,
    it will be possible to learn which SQL activities happen during particular JSP page processing.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='table_api'>12.6.3&nbsp;Table API</h1>

  <p>
    To create a table, create instance of class <code class="nobr">com.yourkit.probes.Table</code>.
    You will need that instance to create rows, as well as to close table rows
    for <a href="#event_kinds">lasting events</a>.
  </p>

  <p>
    Table columns are described with instances of classes
    <code class="nobr">com.yourkit.probes.IntColumn</code>,
    <code class="nobr">com.yourkit.probes.LongColumn</code>,
    <code class="nobr">com.yourkit.probes.StringColumn</code>,
    <code class="nobr">com.yourkit.probes.ForeignKeyColumn</code>.
  </p>

  <p>
    The column instances are passed as parameters to <code class="nobr">com.yourkit.probes.Table</code>
    constructor.
    They are also used to set or modify values at specified row.
  </p>

  <p>
    Please see <a href="https://www.yourkit.com/docs/2017/api/index.html">Javadoc</a> for detail.
  </p>

  <p>
    Please also read about <a href="#compile_probes">compiling probe classes</a>.
  </p>

  <p>
    Please find examples of the API usage in <a href="#builtin_probes">the built-in probes</a> source code.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='scalability'>12.6.4&nbsp;Scalability</h1>


<p>
  To avoid infinite growth of collected data,
  it is possible to limit
  the number of events to be recorded in the profiler agent.
</p>

<ul>
  <li>
    <p>
      When writing a probe:
      <a href="#table_api">table API</a> method
      <code class="nobr">Table.setMinimumRecordedLastingEventTime()</code>
      suppresses recording of non-interesting short events.
      See the method's Javadoc for detail.
      Built-in probe <a href="#awtevents">AWTEvents</a> is an example of using the method.
    </p>
  </li>
  <li>
    <p>
      In profiler agent: <a href="#startup_options">startup option</a>
      <code class="nobr">probetablelengthlimit=<i>&lt;number of rows&gt;</i></code>
      limits the number of rows to be stored by the profiler agent per <a href="#tables">table</a>.
      If a table reaches the limit, it will no longer be populated until cleared.
      Default value is 20000.
    </p>
  </li>
</ul>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='perf_charts'>13&nbsp;Performance charts</h1>

  <p>
    The "Performance charts" tab shows all telemetry graphs
    in the same place one above the other, with their time axis synchronized.
  </p>
  <p>
    You can easily correlate higher level events with basic telemetry graphs,
    as well as to simultaneously see basic telemetry graphs from different tabs e.g. CPU and Memory.
  </p>
  <figure>
    <img alt="" src="resources/perf_charts.png"/>
  </figure>
  <p>
    In addition to the basic telemetry graphs,
    high level statistics for EE and SE applications is presented:
  </p>
  <ul>
    <li>
      JSP/Servlet requests:
      <ul>
        <li>count, per second</li>
        <li>request duration (average, max)</li>
      </ul>
    </li>
    <li>
      JDBC/SQL database connections:
      <ul>
        <li>how many opened and closed, per second</li>
        <li>live time (average, max)</li>
      </ul>
    </li>
    <li>
      JDBC/SQL database requests:
      <ul>
        <li>count, per second</li>
        <li>call duration (average, max)</li>
      </ul>
    </li>
    <li>
      NoSQL databases requests (includes <code class="nobr">MongoDB</code>, <code class="nobr">Cassandra</code>, <code class="nobr">HBase</code>):
      <ul>
        <li>count, per second</li>
        <li>request duration (average, max)</li>
      </ul>
    </li>
    <li>
      Sockets:
      <ul>
        <li>how many connections opened with <code class="nobr">accept()</code> or <code class="nobr">connect()</code> and how many closed, per second</li>
        <li>for how long connections stayed open (average, max)</li>
        <li>bytes read from sockets, per second</li>
        <li>bytes written to sockets, per second</li>
      </ul>
    </li>
    <li>
      File I/O (includes <code class="nobr">FileInputStream</code>, <code class="nobr">FileOutputStream</code>, <code class="nobr">RandomAccessFile</code>):
      <ul>
        <li>how many files opened and closed, per second</li>
        <li>for how long files stayed open (average, max)</li>
        <li>bytes read from files, per second</li>
        <li>bytes written to files, per second</li>
      </ul>
    </li>
  </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='inspections'>14&nbsp;Inspections: automatic recognition of typical problems</h1>

  <p>
    Typical problems can be recognized with the help of the "Inspections" feature.
    Inspections enable automatic high-level analysis of profiled application snapshots.
    Each inspection automatically detects a specific issue.
    Performing this type of analysis by hand would be a very complicated (if at all possible) task.
  </p>

  <p>
    The "Inspections" tab offers the following kinds of inspections:
  </p>

  <ul>
    <li>
      <a href="#inspections_mem">Memory inspections</a>
      are available in memory snapshots and recognize typical memory-related problems
    </li>
    <li>
      <a href="#event_inspections">Event inspections</a> recognize typical behavioral problems
    </li>
  </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='triggers'>15&nbsp;Automatically trigger actions on event</h1>

  <p>
    The triggers allow you to configure actions to be automatically performed on following events:
  </p>
  <ul>
    <li>execution of particular method</li>
    <li>high CPU usage</li>
    <li>high memory usage</li>
    <li>out of memory exception</li>
    <li>JVM start</li>
    <li>JVM exit</li>
    <li>timer</li>
  </ul>
  <p>
    The possible actions include:
  </p>
  <ul>
    <li>log events to console, file, agent log or <a href="#data_storage">data storage</a></li>
    <li>control profiling</li>
    <li>capture snapshots</li>
  </ul>

  <h2>Triggers in user interface</h2>

  <p>
    When you are connected to the profiled application,
    click corresponding toolbar button to view or change the triggers:
  </p>

  <figure>
    <img alt="" src="resources/triggers_control_panel.png"/>
  </figure>

  <figure>
    <img alt="" src="resources/triggers.png"/>
  </figure>

  <figure>
    <img alt="" src="resources/trigger_templates_menu.png"/>
  </figure>

  <h2>How to specify triggers on startup</h2>

  <p>
    To specify triggers to be applied from profiled application start,
    use startup option <a href="#triggers">triggers=&lt;path&gt;</a> which points to
    a file with trigger description (see below).
  </p>
  <p>
    If the option is not specified, the trigger description is read from
    <code class="nobr"><i>&lt;user home&gt;</i>/.yjp/triggers.txt</code>,
    where <i>user home</i> corresponds to the account under which a profiled application is launched.
  </p>
  <p>
    By default, that file does not exist, thus no triggers are applied.
  </p>

  <h2>Setting triggers via API</h2>

  <p>
    To get or set the triggers programmatically, use the following <a href="#api">profiler API</a> methods:
  </p>
  <ul>
    <li>
      Controller.getTriggers()
    </li>
    <li>
      Controller.setTriggers(String triggersDescription, boolean append)
    </li>
  </ul>

  <h2>The triggers description format</h2>

  <p>
    The trigger description file is a text file in UTF-8.
    It contains the list of events and corresponding actions.
    The lines describing the actions start with space characters.
  </p>

  <pre><code>event_name [parameters...]
    action_name [parameters...]
    action_name [parameters...]
    ...
event_name [parameters...]
    action_name [parameters...]
    action_name [parameters...]
    ...
...</code></pre>

  <p>
    Instead of manually forming the description, please use the "Edit Triggers" dialog (see above):
    configure necessary triggers and actions, then use export actions in popup menu.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='snapshot_on_high_memory_usage'>15.1&nbsp;Automatically capture snapshot on high memory usage</h1>

  <p>
    You can instruct the profiler to automatically capture memory snapshot when
    used memory reaches the specified threshold.
  </p>

  <p>
    When used memory constantly increases, this often means there's a memory leak.
    Based on this concept, this feature greatly simplifies the
    detection of such situations in e.g. long-running applications such as servers.
    One of the benefits is that, after being triggered, the feature requires no further human interaction.
  </p>

  <p class="hint">
    Please also consider the built-in ability of modern Sun Java virtual machines to
    <a href="#out_of_memory">dump memory on OutOfMemoryError</a>.
    The JVM's internal lightweight dumping algorithm is used. This algorithm is specially designed to work
    in low memory conditions, when the JVM general purpose profiling interface JVMTI used by profilers may fail
    due to low resources.
  </p>

  <p>
    To toggle this feature, <a href="#connect">connect</a> to the profiled application
    and press the button shown on the picture below to edit triggers:
  </p>

  <figure>
    <img alt="" src="resources/triggers_control_panel.png"/>
  </figure>

  <p>
    Use corresponding template menu to add the trigger and actions, then edit parameters if necessary:
  </p>

  <figure>
    <img alt="" src="resources/trigger_templates_menu_memory_usage.png"/>
  </figure>

  <p>
    Then, if the threshold is reached, a memory snapshot will be created, a notification will be shown in the UI
    and the feature will deactivate. You can enable it again afterwards.
  </p>

  <figure>
    <img alt="" src="resources/snapshot_event2.png"/>
  </figure>

  <h2>How to trigger the snapshots from the start</h2>

  <p>
    Use startup option <a href="#usedmem">usedmem</a> or
    <a href="#usedmemhprof">usedmemhprof</a>.
  </p>

  <h2>How to add the trigger with the help of the profiler API</h2>

  <p>
    Export the template using corresponding popup menu item,
    and pass it to <a href="#api">API</a> method <code class="nobr">com.yourkit.api.Controller.setTriggers()</code>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='periodic'>15.2&nbsp;Capture snapshots periodically</h1>

  <p class="hint">
    Please also consider the ability to capture memory snapshots
    <a href="#snapshot_on_high_memory_usage">on high memory usage</a> or <a href="#out_of_memory">on OutOfMemoryError</a>.
  </p>

  <p>
    You can instruct the profiler to capture a snapshot after a specified period of time.
  </p>

  <p>
    When used memory constantly increases, this often means there is a memory leak. This feature greatly simplifies
    the detection of such situations in e.g. long-running applications such as servers.
    One of the benefits is that, after being triggered, the feature requires no further human interaction.
  </p>

  <p>
    To toggle this feature, <a href="#connect">connect</a> to the profiled application
    and press the button shown on the picture below to edit triggers:
  </p>

  <figure>
    <img alt="" src="resources/triggers_control_panel.png"/>
  </figure>

  <p>
    Use corresponding template menu to add the trigger and actions, then edit parameters if necessary:
  </p>

  <figure>
    <img alt="" src="resources/trigger_templates_menu_periodic.png"/>
  </figure>

  <p>
    Then, every time the specified period elapses, a memory snapshot will be created and the following
    notification will be shown in the UI:
  </p>

  <figure>
    <img alt="" src="resources/snapshot_event2.png"/>
  </figure>

  <br/>
  <br/>

  <h2>How to trigger the snapshots from the start</h2>

  <p>
    Use startup option
    <a href="#periodicperf">periodicperf</a>,
    <a href="#periodicmem">periodicmem</a>,
    <a href="#periodichprof">periodichprof</a>.
  </p>

  <h2>How to capture snapshots periodically with the help of the profiler API</h2>

  <p>
    Export the template using corresponding popup menu item,
    and pass it to <a href="#api">API</a> method <code class="nobr">com.yourkit.api.Controller.setTriggers()</code>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='summary'>16&nbsp;Summary, snapshot annotation, automatic deobfuscation</h1>

  <p>
    The "Summary" tab provides an overview of JVM properties and parameters of profiled application,
    as well as a summary of application telemetry information.
  </p>

  <p>
    The tab is available when the profiler is <a href="#connect">connected to profiled application</a>,
    or when you open a saved snapshot.
  </p>

  <figure>
    <img alt="" src="resources/telemetry_summary.png"/>
  </figure>

  <h2>Automatic deobfuscation</h2>

  <p>
    If the profiled application is obfuscated, YourKit Java Profiler can automatically restore
    original names of classes, fields and methods if you specify the path to the obfuscation log file (1).
    Deobfuscator can be configured for a specific snapshot, as well as when you are connected to the profiled
    application (in this case the deobfuscator will apply to live results and will be chosen by default
    for captured snapshots).
  </p>

  <figure>
    <img alt="" src="resources/telemetry_deobfuscate.png"/>
  </figure>

  <h2>Snapshot annotation</h2>

  <p>
    The "Summary" view for a snapshot lets you store free-form text descriptions directly in the snapshot file (2).
  </p>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='ide_integration'>17&nbsp;IDE integration</h1>

  <p>
    IDE integration provides:
    <ul>
      <li>ability to start profiled applications directly from an IDE</li>
      <li>easy navigation from profiling results to profiled application source code</li>
    </ul>
  </p>

  <p>
    Please find details for each particular supported IDE:
    <ul>
      <li><a href="#eclipse">Eclipse</a></li>
      <li><a href="#idea">IntelliJ IDEA</a></li>
      <li><a href="#netbeans">NetBeans</a></li>
      <li><a href="#jdeveloper">JDeveloper</a></li>
    </ul>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='eclipse'>17.1&nbsp;Eclipse</h1>

  <p>
    The plugin supports Eclipse 3.5-4.x.
  </p>

  <h2>Plugin installation</h2>

  <p>
    To enable integration, you should install the profiler plugin.
  </p>

  <p>
    To install the plugin, <a href="#running_profiler">run the profiler</a>.
  </p>

  <p>
    When you run the profiler for the first time or after updating to a newer profiler version,
    you will be automatically prompted to install the plugin. Also, you can explicitly launch the plugin installation wizard
    via <span class="ui_action">Tools | Integrate with IDE...</span>.
  </p>

  <figure>
    <img alt="" src="resources/eclipse_wizard.png"/>
  </figure>

  <p>
    The wizard will automatically open <a href="#eclipse_update_site">these instructions</a> in your browser.
    Please follow them to complete the plugin installation.
  </p>

  <hr/>

  <h2 id="profiling">Profiling from Eclipse</h2>

  <p>
    After the plugin is installed, <span class="ui_action">Profile</span> actions appear
    in the toolbar ...
  </p>
  <figure>
    <img alt="" src="resources/eclipse_toolbar.png"/>
  </figure>

  <p>
    <br/>
    ... in the main menu ...
  </p>
  <figure>
    <img alt="" src="resources/eclipse_main_menu.png"/>
  </figure>

  <p>
    <br/>
    ... and in context menus.
  </p>
  <figure>
    <img alt="" src="resources/eclipse_context_menu.png"/>
  </figure>

  <p>
    Additional launch parameters can be configured
    with <span class="ui_action">Run | Profile...</span>, tab <span class="ui_text">YourKit Java Profiler</span>.
  </p>

  <figure>
    <img alt="" src="resources/eclipse_run_conf_flat.png"/>
  </figure>

  <p>
    The <span class="ui_action">Profile</span> action starts the profiled application, and connects to it in profiler UI
    (unless opposite behavior is configured).
    The output of the profiled application appears in console, same as for <span class="ui_action">Run</span> action.
  </p>

  <figure>
    <img alt="" src="resources/eclipse_console.png"/>
  </figure>

  <h2>32-bit or 64-bit JRE selection</h2>

  <p class="hint">
    This topic is not applicable to Mac OS X where the profiler agent a universal binary.
  </p>

  <p>
    On a 64-bit machine, the <span class="ui_action">Profile</span> action must know whether the JVM
    for launching the profiled application is 32-bit or 64-bit,
    in order to supply appropriate profiler agent version.
  </p>

  <p>
    By default, the plugin attempts to automatically detect the JVM kind by obtaining available information from Eclipse.
  </p>

  <p>
    For particular run configurations this may happen that the automatic detection is not possible.
    In this case <span class="ui_action">Profile</span> will fail with an error like
    <code class="nobr">Error occurred during initialization of VM. Could not find agent library</code>
    printed in the Eclipse console.
    In this case use the "32-bit or 64-bit JRE Selection" section to specify Java bitness explicitly.
  </p>

  <h2>Navigation action</h2>

  <p>
    When profiling applications, you usually need to browse the related source code to understand
    the performance problems at hands.
    After the problem is located, you edit the source code to fix it.
  </p>

  <p>
    Instead of forcing you to tell profiler where the source code of your application is located
    and showing the code in feature-restricted custom-made "editor surrogate", YourKit provides an alternative approach.
    When you have a method, class or field selected in the profiler UI,
    just invoke <span class="ui_action">Tools | Open in IDE (F7)</span>,
    to automatically open the underlying source code in the editor of your IDE - the best place to browse and edit code.
  </p>

  <p>
    The navigation action works on the current selection and is available in both CPU and memory views.
    Take note of the extremely useful ability to locate the code of anonymous classes and their methods,
    which is a very difficult thing to do manually.
  </p>

  <figure>
    <img alt="" src="resources/open_declaration.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='eclipse_update_site'>17.2&nbsp;Completing Eclipse plugin installation</h1>

  <p>
    Please follow instructions for your IDE:
  </p>

  <ul>
    <li>
      <a href="#complete_eclipse35">Eclipse 3.5-4.x</a>
    </li>
    <li>
      <a href="#complete_myeclipse2014">MyEclipse 2014 or newer</a>
    </li>
    <li>
      <a href="#complete_myeclipse85">MyEclipse 8.5-2013</a>
    </li>
  </ul>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='complete_eclipse35'>17.2.1&nbsp;Completing Eclipse 3.5-4.x plugin installation</h1>

  <ul>
    <li><a href="#install">Install the plugin</a></li>
    <li><a href="#check">Check that the plugin is successfully installed</a></li>
  </ul>

  <p>
  </p>

  <h2 id="install">Install the plugin</h2>

  <p class="hint">
    If you already have installed the plugin from the YourKit Java Profiler version you use (i.e. having the same update site URL - see below), just make sure it is up to date:
    go to <span class="ui_action">Help | Check for Updates</span> in Eclipse's main menu.
  </p>

  <ul>
    <li>
      <p>
        Go to <span class="ui_action">Help | Install New Software...</span> in Eclipse's main menu:
      </p>
      <figure>
        <img alt="" src="resources/eclipse35_menu_update.png"/>
      </figure>
    </li>
    <li>
      <p>
        Press "Add..." button:
      </p>
      <figure>
        <img alt="" src="resources/eclipse35_button_add_site.png"/>
      </figure>
    </li>
    <li>
      <p>
        Copy appropriate URL:
      </p>
      <table class="tbl-with-border tbl-with-strong-thead">
        <thead>
          <tr>
            <td>Profiler version</td>
            <td>URL</td>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>YourKit Java Profiler 2017.02</td>
            <td><code class="nobr">https://www.yourkit.com/download/yjp2017_02_for_eclipse/</code></td>
          </tr>
          <tr>
            <td>YourKit Java Profiler 2016.02</td>
            <td><code class="nobr">https://www.yourkit.com/download/yjp2016_for_eclipse/</code></td>
          </tr>
          <tr>
            <td>YourKit Java Profiler 2015</td>
            <td><code class="nobr">https://www.yourkit.com/download/yjp2015_for_eclipse/</code></td>
          </tr>
          <tr>
            <td>YourKit Java Profiler 2014</td>
            <td><code class="nobr">https://www.yourkit.com/download/yjp2014_for_eclipse/</code></td>
          </tr>
        </tbody>
      </table>
      <p>
        ... and paste it to the "Location" field:<br/>
      </p>
      <figure>
        <img alt="" src="resources/eclipse35_site_url.png"/>
      </figure>

      <p>
        <b>Important:</b> Eclipse update manager needs internet access.
        If your computer sits behind a proxy server, you will need to configure Eclipse accordingly:
        go to Window -&gt; Preferences, then General -&gt; Network Connections and enter the host name or IP and port of your proxy server.
      </p>

      <p>
        <b>If there is no internet access, use the bundled update site archive:</b><br/>
        <code class="nobr"><i>&lt;Profiler Installation Directory&gt;</i>/lib/eclipse-plugin/yjp<i>&lt;version&gt;</i>_for_eclipse.zip</code>
      </p>
    </li>
    <li>
      <p>
        Select YourKit Java Profiler plugin and press "Next":
      </p>
      <figure>
        <img alt="" src="resources/eclipse35_button_next.png"/>
      </figure>
    </li>
    <li>
      Indicate that you agree with the license, when asked.
    </li>
    <li>
      Restart Eclipse as suggested.
    </li>
  </ul>

  <p>
  </p>

  <h2 id="check">Check that the plugin is successfully installed</h2>

  <p>
    After restarting Eclipse, you should see <span class="ui_action">Profile</span> action in the toolbar:
  </p>
  <figure>
    <img alt="" src="resources/eclipse35_toolbar.gif"/>
  </figure>
  <p>
    <a href="#profiling">Read about using the plugin...</a>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='complete_myeclipse2014'>17.2.2&nbsp;Completing MyEclipse 2014 or newer plugin installation</h1>

  <ul>
    <li><a href="#install">Install the plugin</a></li>
    <li><a href="#check">Check that the plugin is successfully installed</a></li>
  </ul>

  <p>
  </p>

  <h2 id="install">Install the plugin</h2>

  <p class="hint">
    If you already have installed the plugin from the YourKit Java Profiler version you use (i.e. having the same update site URL - see below), just make sure it is up to date:
    go to <span class="ui_action">Help | Check for Updates...</span> in the main menu.
  </p>

  <ul>
    <li>
      <p>
        Go to <span class="ui_action">Help | Install from Site...</span> in the main menu:
      </p>
      <figure>
        <img alt="" src="resources/myeclipse2014_menu.png"/>
      </figure>
    </li>
    <li>
      <p>
        Press "Add..." button:
      </p>
      <figure>
        
        <img alt="" src="resources/myeclipse2014_button_add.png"/>
      </figure>
    </li>
    <li>
      <p>
        Copy appropriate URL:
      </p>
      <table class="tbl-with-border tbl-with-strong-thead">
        <thead>
          <tr>
            <td>Profiler version</td>
            <td>URL</td>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>YourKit Java Profiler 2017.02</td>
            <td><code class="nobr">https://www.yourkit.com/download/yjp2017_02_for_eclipse/</code></td>
          </tr>
          <tr>
            <td>YourKit Java Profiler 2016.02</td>
            <td><code class="nobr">https://www.yourkit.com/download/yjp2016_for_eclipse/</code></td>
          </tr>
          <tr>
            <td>YourKit Java Profiler 2015</td>
            <td><code class="nobr">https://www.yourkit.com/download/yjp2015_for_eclipse/</code></td>
          </tr>
          <tr>
            <td>YourKit Java Profiler 2014</td>
            <td><code class="nobr">https://www.yourkit.com/download/yjp2014_for_eclipse/</code></td>
          </tr>
        </tbody>
      </table>
      <p>
        ... and paste it to the "Location" field:<br/>
      </p>
      <figure>
        
        <img alt="" src="resources/myeclipse2014_url.png"/>
      </figure>

      <p>
        <b>Important:</b> Eclipse update manager needs internet access.
        If your computer sits behind a proxy server, you will need to configure Eclipse accordingly:
        go to Window -&gt; Preferences, then General -&gt; Network Connections and enter the host name or IP and port of your proxy server.
      </p>

      <p>
        <b>If there is no internet access, use the bundled update site archive:</b><br/>
        <code class="nobr"><i>&lt;Profiler Installation Directory&gt;</i>/lib/eclipse-plugin/yjp<i>&lt;version&gt;</i>_for_eclipse.zip</code>
      </p>
    </li>
    <li>
      <p>
        Select YourKit Java Profiler plugin and press "Next":
      </p>
      <figure>
        
        <img alt="" src="resources/myeclipse2014_button_next.png"/>
      </figure>
    </li>
    <li>
      Indicate that you agree with the license, when asked.
    </li>
    <li>
      Restart MyEclipse as suggested.
    </li>
  </ul>

  <p>
  </p>

  <h2 id="check">Check that the plugin is successfully installed</h2>

  <p>
    After restarting MyEclipse, you should see <span class="ui_action">Profile</span> action in the toolbar:
  </p>
  <figure>
    <img alt="" src="resources/myeclipse2014_toolbar.png"/>
  </figure>
  <p>
    <a href="#profiling">Read about using the plugin...</a>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='complete_myeclipse85'>17.2.3&nbsp;Completing MyEclipse 8.5-2013 plugin installation</h1>

  <ul>
    <li><a href="#install">Install the plugin</a></li>
    <li><a href="#check">Check that the plugin is successfully installed</a></li>
  </ul>

  <p>
  </p>

  <h2 id="install">Install the plugin</h2>

  <p class="hint">
    If you already have installed the plugin from the YourKit Java Profiler version you use (i.e. having the same update site URL - see below), just make sure it is up to date:
    go to <span class="ui_action">Help | MyEclipse Configuration Center | Software...</span> in the main menu.
  </p>

  <ul>
    <li>
      <p>
        Go to <span class="ui_action">Help | MyEclipse Configuration Center</span> in the main menu:
      </p>
      <figure>
        <img alt="" src="resources/myeclipse85_menu_update.gif"/>
      </figure>
    </li>
    <li>
      <p>
        Switch to Software and press "Add Site" button:
      </p>
      <figure>
        <img alt="" src="resources/myeclipse85_button_add_site.gif"/>
      </figure>
    </li>
    <li>
      <p>
        Copy appropriate URL:
      </p>
      <table class="tbl-with-border tbl-with-strong-thead">
        <thead>
          <tr>
            <td>Profiler version</td>
            <td>URL</td>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>YourKit Java Profiler 2017.02</td>
            <td><code class="nobr">https://www.yourkit.com/download/yjp2017_02_for_eclipse/</code></td>
          </tr>
          <tr>
            <td>YourKit Java Profiler 2016.02</td>
            <td><code class="nobr">https://www.yourkit.com/download/yjp2016_for_eclipse/</code></td>
          </tr>
          <tr>
            <td>YourKit Java Profiler 2015</td>
            <td><code class="nobr">https://www.yourkit.com/download/yjp2015_for_eclipse/</code></td>
          </tr>
          <tr>
            <td>YourKit Java Profiler 2014</td>
            <td><code class="nobr">https://www.yourkit.com/download/yjp2014_for_eclipse/</code></td>
          </tr>
        </tbody>
      </table>
      <p>
        ... and paste it to the "URL" field.<br/>
      </p>
      <p>
        Please also specify arbitrary name for the update site, e.g. "YourKit":
      </p>
      <figure>
        <img alt="" src="resources/myeclipse85_site_url.gif"/>
      </figure>

      <p>
        <b>Important:</b> Eclipse update manager needs internet access.
        If your computer sits behind a proxy server, you will need to configure Eclipse accordingly:
        go to Window -&gt; Preferences, then General -&gt; Network Connections and enter the host name or IP and port of your proxy server.
      </p>

      <p>
        <b>If there is no internet access, use the bundled update site archive:</b><br/>
        <code class="nobr"><i>&lt;Profiler Installation Directory&gt;</i>/lib/eclipse-plugin/yjp<i>&lt;version&gt;</i>_for_eclipse.zip</code>
      </p>
    </li>
    <li>
      <p>
        In pop-up, press "Add to Profile...":
      </p>
      <figure>
        <img alt="" src="resources/myeclipse85_menu_add_to.gif"/>
      </figure>
    </li>
    <li>
      <p>
        Press "Apply 1 change...":
      </p>
      <figure>
        <img alt="" src="resources/myeclipse85_button_apply_change.gif"/>
      </figure>
    </li>
    <li>
      <p>
        Accept the license and press "Next":
      </p>
      <figure>
        <img alt="" src="resources/myeclipse85_licenses_button_next.gif"/>
      </figure>
    </li>
    <li>
      Restart MyEclipse as suggested.
    </li>
  </ul>

  <p>
  </p>

  <h2 id="check">Check that the plugin is successfully installed</h2>

  <p>
    After restarting MyEclipse, you should see <span class="ui_action">Profile</span> action in the toolbar:
  </p>
  <figure>
    <img alt="" src="resources/myeclipse85_toolbar.gif"/>
  </figure>
  <p>
    <a href="#profiling">Read about using the plugin...</a>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='idea'>17.3&nbsp;IntelliJ IDEA</h1>

  <p>
    IntelliJ IDEA versions 8 to 2016.3 are supported.
  </p>

  <h2>Plugin installation</h2>

  <p>
    To enable integration, you should install the profiler plugin.
  </p>

  <p>
    To install the plugin, <a href="#running_profiler">run the profiler</a>.
  </p>

  <p>
    When you run the profiler for the first time or after updating to a newer profiler version,
    you will be automatically prompted to install the plugin. Also, you can explicitly launch the plugin installation wizard
    via <span class="ui_action">Tools | Integrate with IDE...</span>.
  </p>

  <figure>
    <img alt="" src="resources/idea_wizard.png"/>
  </figure>

  <h2>Profiling from IDEA</h2>

  <p>
    After the plugin is installed, the <span class="ui_action">Profile</span> actions are added to the main toolbar ...
  </p>
  <figure>
    <img alt="" src="resources/idea_toolbar.png"/>
  </figure>

  <p>
    <br/>
    ... to the main menu ...
  </p>
  <figure>
    <img alt="" src="resources/idea_main_menu.png"/>
  </figure>

  <p>
    <br/>
    ... and to context popup menus:
  </p>
  <figure>
    <img alt="" src="resources/idea_context_menu.png"/>
  </figure>

  <p>
    To configure profiler parameters
    open the <span class="ui_action">Run/Debug Configurations</span> dialog,
    select the configuration and select the <span class="ui_action">Startup/Connection</span> tab.
  </p>

  <figure>
    <img alt="" src="resources/idea_run_conf.png"/>
  </figure>

  <p>
    The <span class="ui_action">Profile</span> action starts the profiled application, and connects to it in profiler UI
    (unless opposite behavior is configured).
    The output of the profiled application appears in console, same as for <span class="ui_action">Run</span> action.
  </p>

  <figure>
    <img alt="" src="resources/idea_console.png"/>
  </figure>

  <h2>32-bit or 64-bit JRE selection</h2>

  <p class="hint">
    This topic is not applicable to Mac OS X where the profiler agent a universal binary.
  </p>

  <p>
    On a 64-bit machine, the <span class="ui_action">Profile</span> action must know whether the JVM
    for launching the profiled application is 32-bit or 64-bit,
    in order to supply appropriate profiler agent version.
  </p>

  <p>
    By default, the plugin attempts to automatically detect the JVM kind by obtaining available information from IDEA.
  </p>

  <p>
    For particular run configurations this may happen that the automatic detection is not possible.
    In this case <span class="ui_action">Profile</span> will fail with an error like
    <code class="nobr">Error occurred during initialization of VM. Could not find agent library</code>
    printed in the IDEA console.
    In this case use the "32-bit or 64-bit JRE Selection" section to specify Java bitness explicitly.
  </p>

  <h2>Navigation action</h2>

  <p>
    When profiling applications, you usually need to browse the related source code to understand
    the performance problems at hands.
    After the problem is located, you edit the source code to fix it.
  </p>

  <p>
    Instead of forcing you to tell profiler where the source code of your application is located
    and showing the code in feature-restricted custom-made "editor surrogate", YourKit provides an alternative approach.
    When you have a method, class or field selected in the profiler UI,
    just invoke <span class="ui_action">Tools | Open in IDE (F7)</span>,
    to automatically open the underlying source code in the editor of your IDE - the best place to browse and edit code.
  </p>

  <p>
    The navigation action works on the current selection and is available in both CPU and memory views.
    Take note of the extremely useful ability to locate the code of anonymous classes and their methods,
    which is a very difficult thing to do manually.
  </p>

  <figure>
    <img alt="" src="resources/open_declaration.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='netbeans'>17.4&nbsp;NetBeans</h1>

  <p>
    NetBeans versions from 7.0 to 8.2 are supported.
  </p>

  <h2>Plugin installation</h2>

  <p>
    To enable integration, you should install the profiler plugin.
  </p>

  <p>
    To install the plugin, <a href="#running_profiler">run the profiler</a>.
  </p>

  <p>
    When you run the profiler for the first time or after updating to a newer profiler version,
    you will be automatically prompted to install the plugin. Also, you can explicitly launch the plugin installation wizard
    via <span class="ui_action">Tools | Integrate with IDE...</span>.
  </p>

  <figure>
    <img alt="" src="resources/netbeans_wizard.png"/>
  </figure>

  <h2>Profiling from NetBeans</h2>

  <p>
    After the plugin is installed, <span class="ui_action">Profile</span> actions are added to the main toolbar ...
  </p>
  <figure>
    <img alt="" src="resources/netbeans_toolbar.png"/>
  </figure>

  <p>
    ... and to context menu of the editor:
  </p>
  <figure>
    <img alt="" src="resources/netbeans_context_menu1.png"/>
  </figure>
  <figure>
    <img alt="" src="resources/netbeans_context_menu2.png"/>
  </figure>

  <p>
    To configure profiling parameters in NetBeans use
    <span class="ui_action">Tools | Options</span>, section
    <span class="ui_text">YourKit Profiler</span>:
  </p>

  <figure>
    <img alt="" src="resources/netbeans_run_conf.png"/>
  </figure>

  <p>
    The <span class="ui_action">Profile</span> action starts the profiled application, and connects to it in profiler UI
    (unless opposite behavior is configured).
    The output of the profiled application appears in console, same as for <span class="ui_action">Run</span> action.
  </p>

  <figure>
    <img alt="" src="resources/netbeans_console1.png"/>
  </figure>
  <figure>
    <img alt="" src="resources/netbeans_console2.png"/>
  </figure>

  <h2>32-bit or 64-bit JRE selection</h2>

  <p class="hint">
    This topic is not applicable to Mac OS X where the profiler agent a universal binary.
  </p>

  <p>
    On a 64-bit machine, the <span class="ui_action">Profile</span> action must know whether the JVM
    for launching the profiled application is 32-bit or 64-bit,
    in order to supply appropriate profiler agent version.
  </p>

  <p>
    By default, the plugin attempts to automatically detect the JVM kind by obtaining available information from NetBeans.
  </p>

  <p>
    For particular run configurations this may happen that the automatic detection is not possible.
    In this case <span class="ui_action">Profile</span> will fail with an error like
    <code class="nobr">Error occurred during initialization of VM. Could not find agent library</code>
    printed in the NetBeans console.
    In this case use the "32-bit or 64-bit JRE Selection" section to specify Java bitness explicitly.
  </p>

  <h2>Navigation action</h2>

  <p>
    When profiling applications, you usually need to browse the related source code to understand
    the performance problems at hands.
    After the problem is located, you edit the source code to fix it.
  </p>

  <p>
    Instead of forcing you to tell profiler where the source code of your application is located
    and showing the code in feature-restricted custom-made "editor surrogate", YourKit provides an alternative approach.
    When you have a method, class or field selected in the profiler UI,
    just invoke <span class="ui_action">Tools | Open in IDE (F7)</span>,
    to automatically open the underlying source code in the editor of your IDE - the best place to browse and edit code.
  </p>

  <p>
    The navigation action works on the current selection and is available in both CPU and memory views.
    Take note of the extremely useful ability to locate the code of anonymous classes and their methods,
    which is a very difficult thing to do manually.
  </p>

  <figure>
    <img alt="" src="resources/open_declaration.png"/>
  </figure>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='jdeveloper'>17.5&nbsp;JDeveloper</h1>

  <p>
    JDeveloper 11g is supported (11.1.2 and newer).
  </p>

  <h2>Plugin installation</h2>

  <p>
    To enable integration, you should install the profiler plugin.
  </p>

  <p>
    To install the plugin, <a href="#running_profiler">run the profiler</a>.
  </p>

  <p>
    When you run the profiler for the first time or after updating to a newer profiler version,
    you will be automatically prompted to install the plugin. Also, you can explicitly launch the plugin installation wizard
    via <span class="ui_action">Tools | Integrate with IDE...</span>.
  </p>

  <figure>
    <img alt="" src="resources/jdeveloper_wizard.png"/>
  </figure>

  <h2>Profiling from JDeveloper</h2>

  <p>
    After the plugin is installed, <span class="ui_action">Profile</span> actions are added to the main menu ...
  </p>
  <figure>
    <img alt="" src="resources/jdeveloper_main_menu.gif"/>
  </figure>

  <p>
    ... and to context menus:
  </p>
  <figure>
    <img alt="" src="resources/jdeveloper_context_menu1.png"/>
  </figure>

  <p>
    ...and in the main toolbar:
  </p>
  <figure>
    <img alt="" src="resources/jdeveloper_toolbar.png"/>
  </figure>

  <p>
    You can configure profiling parameters in the
    <span class="ui_text">Project Properties</span> dialog's node <span class="ui_text">YourKit Java Profiler</span>.
  </p>

  <figure>
    <img alt="" src="resources/jdeveloper_run_conf.png"/>
  </figure>

  <p>
    The <span class="ui_action">Profile</span> action starts the profiled application, and connects to it in profiler UI
    (unless opposite behavior is configured).
    The output of the profiled application appears in console, same as for <span class="ui_action">Run</span> action.
  </p>

  <figure>
    <img alt="" src="resources/jdeveloper_console.png"/>
  </figure>

  <h2>32-bit or 64-bit JRE selection</h2>

  <p class="hint">
    This topic is not applicable to Mac OS X where the profiler agent a universal binary.
  </p>

  <p>
    On a 64-bit machine, the <span class="ui_action">Profile</span> action must know whether the JVM
    for launching the profiled application is 32-bit or 64-bit,
    in order to supply appropriate profiler agent version.
  </p>

  <p>
    By default, the plugin attempts to automatically detect the JVM kind by obtaining available information from JDeveloper.
  </p>

  <p>
    For particular run configurations this may happen that the automatic detection is not possible.
    In this case <span class="ui_action">Profile</span> will fail with an error like
    <code class="nobr">Error occurred during initialization of VM. Could not find agent library</code>
    printed in the JDeveloper console.
    In this case use the "32-bit or 64-bit JRE Selection" section to specify Java bitness explicitly.
  </p>

  <h2>Navigation action</h2>

  <p>
    When profiling applications, you usually need to browse the related source code to understand
    the performance problems at hands.
    After the problem is located, you edit the source code to fix it.
  </p>

  <p>
    Instead of forcing you to tell profiler where the source code of your application is located
    and showing the code in feature-restricted custom-made "editor surrogate", YourKit provides an alternative approach.
    When you have a method, class or field selected in the profiler UI,
    just invoke <span class="ui_action">Tools | Open in IDE (F7)</span>,
    to automatically open the underlying source code in the editor of your IDE - the best place to browse and edit code.
  </p>

  <p>
    The navigation action works on the current selection and is available in both CPU and memory views.
  </p>

  <figure>
    <img alt="" src="resources/open_declaration.png"/>
  </figure>

  <p>
    <b>Note:</b> navigation to inner classes is not possible because JDeveloper does not provide appropriate API.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='times'>18&nbsp;Time measurement (CPU time, wall time)</h1>

  <p>
    There are two ways to measure time:
  </p>

  <ul>
    <li>
      <b>CPU time</b> - the time actually spent by CPU executing method code
    </li>
    <li>
      <b>Wall time</b> - the real-world time elapsed between method entry and method exit.
      If there are other threads/processes concurrently running on the system,
      they can affect the results.
    </li>
  </ul>

  <p>
  </p>

  <h2>CPU sampling/tracing</h2>

  <p>
    You can customize CPU vs wall time measurement
    in <a href="#sampling_settings">CPU sampling settings</a> and
    <a href="#tracing_settings">CPU tracing settings</a>.
    By default, sampling measures wall time for I/O methods only,
    tracing - for all methods.
  </p>

  <h2>Monitor profiling</h2>

  <p>
    <a href="#monitor_profiling">Monitor profiling</a> measures wall time for all waits and blocks.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='filters'>19&nbsp;Filters</h1>

  <p>
    <i>Filters</i> help you to ignore methods and instances of classes which you are not interested in,
    such as standard Java classes, libraries, framework internals, application server core classes etc.,
    so you can more easily focus on own classes of the profiled application.
  </p>

  <h2>Filters are applied in the profiler UI</h2>

  <p>
    While reviewing profiling results in a snapshot or in live views,
    you can use different filters or use none at all.
    In other words, you do not need to start a new profiling session to start or stop using filters.
    Views are automatically updated when filter settings are changed.
  </p>

  <p>
    Filters reduce the depth of call trees and length of stack traces,
    by skipping successive calls of methods from filtered classes,
    so you can more easily see the methods of the profiled application.
  </p>
  <p>
    Filters are applied to views where method call stacks are shown,
    as well as to hot spot and method list views.
  </p>
  <p>
    Non-filtered methods are marked with a filled arrow <img alt="" src="resources/legend_call.png"/>.
    Filtered methods have an outlined arrow <img alt="" src="resources/legend_call_filtered.png"/>:
  </p>

  <figure>
    <img alt="" src="resources/filters_example.png"/>
  </figure>

  <p>
    Some <a href="#inspections">automatic inspections</a> use filter settings
    to focus on potential problems in own code of profiled application.
  </p>

  <h2>Switch between applying and not applying filters in the profiler UI</h2>

  <p>
    A quick way to turn applying the configured filters on/off is to use
    the main menu item <span class="ui_action">Settings | Collapse Filtered Calls</span>
    <figure>
      <img alt="" src="resources/collapse_filtered_calls_menu.png"/>
    </figure>
  </p>

  <h2 id="format">Configuring filters</h2>

  <p>
    Select <span class="ui_action">Settings | Filters...</span> in the main menu to configure filters.
  </p>

  <figure>
    <img alt="" src="resources/filters_edit.png"/>
  </figure>

  <p>
    Each filter is specified as a list of class or method patterns to be filtered, one pattern per line.
  </p>

  <p>
    To filter all methods in given class(es), use this format:
  </p>

  <p>
    <code class="nobr"><i>&lt;fully qualified class name&gt;</i></code>
  </p>

  <p>
    To filter particular methods in given class(es), use this format:
  </p>

  <p>
    <code class="nobr"><i>&lt;fully qualified class name&gt;</i> : <i>&lt;method name&gt;</i> ( <i>&lt;comma-separated parameter types&gt;</i> ) </code>
  </p>

  <p>
    Wildcards ('*') are accepted.
  </p>

  <h2>Examples</h2>

  <p>
    <code class="nobr">foo.bar.MyClass</code> - filter all methods of given class<br/>
    <code class="nobr">foo.bar.MyClass:*(*)</code> - same as above<br/>
    <code class="nobr">bar.*</code> - filter methods in all matching classes<br/>
    <code class="nobr">bar.* : print*(*)</code> - filter all methods from bar.* with name starting with 'print' and any number of parameters<br/>
    <code class="nobr">* : toString()</code> - filter toString() in all classes<br/>
    <code class="nobr">com.foo.* : <i>&lt;init&gt;</i>(int, String)</code> - filter constructors of classes in com.foo.* with given signature<br/>
  </p>

  <p>
    To specify classes or methods which must not be filtered, prepend the pattern with '+'.
  </p>

  <p>
    Example:
    filter classes in packages 'foo' and 'bar' (with subpackages), but not in package 'bar.myclasses' (with subpackages):
  </p>
  <p>
    <code class="nobr">foo.*</code><br/>
    <code class="nobr">bar.*</code><br/>
    <code class="nobr">+bar.myclasses.*</code>
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='snapshot_dir'>20&nbsp;Snapshot directory customization</h1>

  <h2>Quick overview</h2>

  <p>
    <i>Snapshot directory</i> is the directory where snapshot files are created.
  </p>

  <p>
    By default, the snapshot directory is <code class="nobr"><i>&lt;user home&gt;</i>/Snapshots</code>
  </p>

  <p>
    For some reason you may want to change the snapshot directory location.
    For example, the user home can be located on a disk with insufficient free space,
    or on a network drive with slow access.
    To change the snapshot directory, select <span class="ui_action">Settings | Snapshot Directory...</span>
    in the main menu.
  </p>

  <h2>Quick overview</h2>

  <p class="hint">
    This is an advanced topic.
    The following text contains technical details that you do not normally
    have to know to profile your applications.
  </p>

  <p>
    Action <span class="ui_action">Settings | Snapshot Directory...</span> stores the specified
    directory in file <code class="nobr"><i>&lt;user home&gt;</i>/.yjp/snapshotdir.txt</code>
  </p>

  <p>
    This is a text file in UTF-8 encoding. The file may not exist until you customize the directory first time.
  </p>

  <p>
    When the profiler UI and the profiled application run under same user,
    the situation is very simple:
    snapshots are stored in directory specified in <code class="nobr"><i>&lt;user home&gt;</i>/.yjp/snapshotdir.txt</code>,
    or, if the file does not exist or defines an invalid directory,
    the default location <code class="nobr"><i>&lt;user home&gt;</i>/Snapshots</code> will be used.
  </p>

  <p>
    When the profiled application runs under different user (e.g. it is started as a service),
    the profiler UI and the profiler agent loaded as a part of the profiled application
    will have different home directories and different access rights to file system.
    As the result, the directory which you have configured in the profiler UI
    can be inaccessible for the profiled application, and your setting will be ignored.
  </p>

  <p>
    Please find below detail on the order in which the snapshot directory is chosen in different cases.
  </p>

  <p>
    We will refer the user which runs the profiler UI as <strong>UI user</strong>,
    and the user which runs the profiled application as <strong>agent user</strong>.
    These can be the same user or different users, as mentioned above.
  </p>

  <p class="hint">
    The basic idea is: if possible, use the directory configured in the profiler UI,
    otherwise use settings in the profiled application user home
  </p>

  <p>
    <strong>
      Performance snapshots of local or remote applications captured from within the profiler UI,
      transferred memory snapshots of remote applications,
      or snapshots unpacked opening ZIP/GZIP archives:
    </strong>
  </p>
  <p>
    Snapshot is created by <strong>UI user</strong> in
  </p>
  <ul>
    <li>
      the directory specified in <code class="nobr"><i>&lt;UI user home&gt;</i>/.yjp/snapshotdir.txt</code>,
      if the file contains a directory to which <strong>UI user</strong> has read and write access
    </li>
    <li>
      <code class="nobr"><i>&lt;UI user home&gt;</i>/Snapshots</code>
    </li>
  </ul>

  <h2>Memory snapshots of local applications captured from within the profiler UI</h2>

  <p>
    Snapshot is created by <strong>agent user</strong> in
  </p>
  <ul>
    <li>
      the directory specified with <code class="nobr">dir</code> <a href="#startup_options">startup option</a>
      of the profiled application, if specified
    </li>
    <li>
      the directory specified in <code class="nobr"><i>&lt;UI user home&gt;</i>/.yjp/snapshotdir.txt</code>,
      if the file exists and contains a directory to which <strong>agent user</strong> has read and write access
    </li>
    <li>
      <code class="nobr"><i>&lt;UI user home&gt;</i>/Snapshots</code> if <strong>agent user</strong> has read and write access
    </li>
    <li>
      the directory specified in <code class="nobr"><i>&lt;agent user home&gt;</i>/.yjp/snapshotdir.txt</code>,
      if the file contains a directory to which <strong>agent user</strong> has read and write access
    </li>
    <li>
      <code class="nobr"><i>&lt;agent user home&gt;</i>/Snapshots</code>
    </li>
  </ul>

  <h2>Snapshots captured on exit, on trigger, via the profiler API or command line tool</h2>

  <p>
    Snapshot is created by <strong>agent user</strong> in
  </p>
  <ul>
    <li>
      the directory specified with <code class="nobr">dir</code> <a href="#startup_options">startup option</a>
      of the profiled application, if specified
    </li>
    <li>
      the directory specified in <code class="nobr"><i>&lt;agent user home&gt;</i>/.yjp/snapshotdir.txt</code>,
      if the file contains a directory to which <strong>agent user</strong> has read and write access
    </li>
    <li>
      <code class="nobr"><i>&lt;agent user home&gt;</i>/Snapshots</code>
    </li>
  </ul>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='export'>21&nbsp;Export of profiling results to HTML, CSV, XML, plain text</h1>

  <p>
    You can export all reports and data to:
  </p>
  <ul>
    <li>
      HTML, optionally packing all generated files to a single ZIP archive
    </li>
    <li>
      CSV ("comma separated values") format
    </li>
    <li>
      XML
    </li>
    <li>
      Plain text format
    </li>
  </ul>

  <br/>

  <h2>Export from UI</h2>

  <p>
    Use File | Export to... (Ctrl+S) to export current view:
  </p>

  <figure>
    <img alt="" src="resources/export_dialog.png"/>
  </figure>

  <p>
    To export telemetry data, right-click a graph to invoke a popup menu:
  </p>
  <figure>
    <img alt="" src="resources/export_telemetry.png"/>
  </figure>

  <p>
    <span class="ui_action">File | Copy To Clipboard...</span> (Ctrl+C or another platform specific shortcut) action copies text of selected row in all trees and lists.
  </p>

  <h2 id="commandline">Export with command line tool</h2>

  <p>
    You can automatically export some basic views using the following command:
  </p>

  <p>
    <code class="nobr">java -jar <i>&lt;Profiler Installation Directory&gt;</i>/lib/yjp.jar -export <i>&lt;snapshot file&gt;</i> <i>&lt;target directory&gt;</i></code><br/>
  </p>
  <p>
    Note: the target directory where the resulting files will be created must exist when you issue the command.
  </p>

  <h2>Exported views</h2>

  <p>
    The following views can be exported:
  </p>
  <ul>
    <li>
      Class list - for memory snapshot
    </li>
    <li>
      Class loaders - for memory snapshot
    </li>
    <li>
      Method list (CPU) - if recorded
    </li>
    <li>
      Call tree (CPU) - if recorded
    </li>
    <li>
      Method list (allocations) - for memory snapshot, if allocations recorded
    </li>
    <li>
      Method list (garbage collection) - for memory snapshot, if allocations recorded
    </li>
    <li>
      Summary
    </li>
    <li>
      Probe tables
    </li>
    <li>
      Telemetry graphs
    </li>
  </ul>

  <p>
    By default, all the views are exported, if corresponding data is present in the snapshot.
  </p>

  <p>
    To export only particular views, specify one or several of the following system properties:
  </p>
  <ul>
    <li><code class="nobr">export.class.list</code></li>
    <li><code class="nobr">export.class.loaders</code></li>
    <li><code class="nobr">export.method.list.cpu</code></li>
    <li><code class="nobr">export.call.tree.cpu</code></li>
    <li><code class="nobr">export.method.list.alloc</code></li>
    <li><code class="nobr">export.method.list.gc</code></li>
    <li><code class="nobr">export.summary</code></li>
    <li><code class="nobr">export.probes</code></li>
    <li><code class="nobr">export.charts</code></li>
  </ul>

  <p>
    If at least one of the properties is specified, only specified views will be exported.
    If none of the properties is specified, all available views will be exported.
  </p>

  <p>
    By default, <a href="#filters">filters</a> are not applied
    when exporting call trees and method lists,
    in order to provide all available profiling information for further processing.
    Thus the results may look differently than in the UI where the filters are applied by default.
    To apply the filters to the exported results, specify system property <li><code class="nobr">export.apply.filters</code></li>
  </p>

  <p>
    Example:
  </p>
  <ul>
    <li>
      <code class="nobr">java -Dexport.method.list.cpu -Dexport.class.list -Dexport.apply.filters -jar /usr/yjp/lib/yjp.jar -export foo.snapshot outputDir</code>
      - export CPU method list and class list only, and apply the filters
    </li>
    <li>
      <code class="nobr">java -jar /usr/yjp/lib/yjp.jar -export foo.snapshot outputDir</code>
      - export all available views, the filters will not be applied
    </li>
  </ul>

  <h2>Export formats</h2>

  <p>
    By default, views are exported in each of applicable formats (HTML, CSV, XML, plain text).
  </p>

  <p>
    To export in only particular formats, specify one or several of the following system properties:
  </p>
  <ul>
    <li><code class="nobr">export.txt</code></li>
    <li><code class="nobr">export.html</code></li>
    <li><code class="nobr">export.csv</code></li>
    <li><code class="nobr">export.xml</code></li>
  </ul>

  <p>
    If at least one of the properties is specified, export will be performed in only specified format(s).
    If none of the properties is specified, export will be performed in all formats available for each of the views.
  </p>

  <p>
    Example:
  </p>
  <ul>
    <li>
      <code class="nobr">java -Dexport.method.list.cpu -Dexport.class.list -Dexport.txt -jar /usr/yjp/lib/yjp.jar -export foo.snapshot outputDir</code>
      - export CPU method list and class list only, and only as text
    </li>
    <li>
      <code class="nobr">java -Dexport.csv -jar /usr/yjp/lib/yjp.jar -export foo.snapshot outputDir</code>
      - export all available views, and only as CSV
    </li>
    <li>
      <code class="nobr">java -jar /usr/yjp/lib/yjp.jar -export foo.snapshot outputDir</code>
      - export all available views in all available formats
    </li>
  </ul>

<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='api'>22&nbsp;Profiler API</h1>

  <p>
    The profiler API allows you to control profiling programmatically.
    Also, in your automatic memory tests you can open saved memory snapshots and examine them via the <a href="#language">set description language</a>.
  </p>

  <p class="hint">
    To control profiling programmatically, also consider <a href="#command_line_tool">command line tool</a>
    which in some cases may be a simpler approach.
  </p>

  <p>
    Please find API JavaDoc <a href="https://www.yourkit.com/docs/2017/api/index.html">here</a>
  </p>

  <p>
    Class <code class="nobr">com.yourkit.api.Controller</code>
    allows you to profile (i.e. turn on and off profiling modes and capture snapshots)
    the application itself or another Java application.
    To use this part of the API, please include <code class="nobr"><i>&lt;Profiler Installation Directory&gt;</i>/lib/yjp-controller-api-redist.jar</code> in the classpath.
  </p>

  <p>
    Classes in <code class="nobr">com.yourkit.probes.*</code>
    provide API for <a href="#probes">probes</a>.
  </p>

  <p>
    Classes <code class="nobr">com.yourkit.api.MemorySnapshot</code> and <code class="nobr">com.yourkit.api.Annotations</code>
    support the analysis of captured memory snapshots and snapshot annotation.
    To use this part of the API, please include <code class="nobr"><i>&lt;Profiler Installation Directory&gt;</i>/lib/yjp.jar</code> in the classpath.
    <b>Important:</b> Do not remove <code class="nobr">yjp.jar</code> from the installation directory.
    The API will not work with <code class="nobr">yjp.jar</code> moved to an arbitrary directory,
    because it needs the other files from the installation.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;<br><h1 id='command_line_tool'>23&nbsp;Command line tool to control profiling</h1>

  <p>
    Command line tool is another way to control profiling, in addition to the profiler UI and <a href="#api">API</a>.
  </p>
  <p>
    It has much in common with API and may also be used for automated profiling.
    You may prefer the command line tool to API in some cases as an easier solution
    not requiring any Java code to be written.
    However the command line tool provides less functionality than the API.
  </p>

  <p>
    Also, the command line tool may be useful in remote profiling when you only have console
    access to the remote machine and no UI is available.
  </p>

  <p>
    Run the tool with the following command:<br/>
    <code class="nobr">java -jar <i>&lt;Profiler Installation Directory&gt;</i>/lib/yjp-controller-api-redist.jar <i>&lt;options&gt;</i></code>
  </p>

  <p>
    To get list of available options, run:<br/>
    <code class="nobr">java -jar <i>&lt;Profiler Installation Directory&gt;</i>/lib/yjp-controller-api-redist.jar</code>
  </p>

  <p class="hint">
    Also consider <a href="#connect">connecting</a> to a remote application
    from a locally running profiler UI, which may be a better approach.
  </p>
<div class="yk_top_link"><a href="#top">[top]</a></div>&nbsp;
        </div>
      </div>

      <div id="footer-id" class="row color-theme">
        <div class="col-xs-offset-0 col-xs-12    col-md-offset-1 col-md-10    col-lg-offset-2 col-lg-8">
          Copyright (c) 2003-2017 YourKit. All rights reserved.
        </div>
      </div>
    </div>
  </body>
</html>
